<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="RBX6f6173ced4904d96bfd3b92e3983ed42">
		<Properties>
			<bool name="AllowThirdPartySales">false</bool>
			<token name="AnimationWeightedBlendFix">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="ClientAnimatorThrottling">1</token>
			<BinaryString name="CollisionGroupData">AQEABP////8HRGVmYXVsdA==</BinaryString>
			<Ref name="CurrentCamera">RBXc4d0e01c0730441984b8c460ecc1c009</Ref>
			<double name="DistributedGameTime">0</double>
			<bool name="ExplicitAutoJoints">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<Vector3 name="GlobalWind">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<float name="Gravity">0</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<token name="HumanoidOnlySetCollisionsOnStateChange">2</token>
			<token name="InterpolationThrottling">1</token>
			<token name="LevelOfDetail">0</token>
			<token name="MeshPartHeadsAndAccessories">2</token>
			<CoordinateFrame name="ModelMeshCFrame">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
			<Vector3 name="ModelMeshSize">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<token name="ModelStreamingMode">0</token>
			<string name="Name">Workspace</string>
			<bool name="NeedsPivotMigration">false</bool>
			<token name="PhysicsSteppingMethod">1</token>
			<Ref name="PrimaryPart">null</Ref>
			<token name="RejectCharacterDeletions">0</token>
			<token name="ReplicateInstanceDestroySetting">0</token>
			<token name="Retargeting">2</token>
			<float name="ScaleFactor">1</float>
			<token name="SignalBehavior">2</token>
			<int64 name="SourceAssetId">-1</int64>
			<token name="StreamOutBehavior">0</token>
			<bool name="StreamingEnabled">false</bool>
			<token name="StreamingIntegrityMode">0</token>
			<int name="StreamingMinRadius">64</int>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TerrainWeldsFixed">true</bool>
			<bool name="TouchesUseCollisionGroups">true</bool>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400012331</UniqueId>
			<OptionalCoordinateFrame name="WorldPivotData">
				<CFrame>
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CFrame>
			</OptionalCoordinateFrame>
		</Properties>
		<Item class="Camera" referent="RBXc4d0e01c0730441984b8c460ecc1c009">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<CoordinateFrame name="CFrame">
					<X>47.3887177</X>
					<Y>-34.34869</Y>
					<Z>46.9060822</Z>
					<R00>0.691168725</R00>
					<R01>0.32942912</R01>
					<R02>0.643243551</R02>
					<R10>1.49011612e-08</R10>
					<R11>0.89006424</R11>
					<R12>-0.455835193</R12>
					<R20>-0.722693443</R20>
					<R21>0.315059036</R21>
					<R22>0.615184546</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<float name="FieldOfView">1</float>
				<token name="FieldOfViewMode">0</token>
				<CoordinateFrame name="Focus">
					<X>46.1022301</X>
					<Y>-33.4370193</Y>
					<Z>45.6757126</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Camera</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">20d1792214748cc902cb375400013f46</UniqueId>
			</Properties>
		</Item>
		<Item class="Terrain" referent="RBX6fb1fcf6c89b4f2da02e78a55d01b80a">
			<Properties>
				<token name="AcquisitionMethod">0</token>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="Decoration">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]></BinaryString>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<bool name="ShorelinesUpgraded">false</bool>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<bool name="SmoothVoxelsUpgraded">false</bool>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">20d1792214748cc902cb375400013f53</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0470588282</R>
					<G>0.329411775</G>
					<B>0.360784322</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
	</Item>
	<Item class="SoundService" referent="RBXc857e7f72da24596895702474078c17a">
		<Properties>
			<token name="AmbientReverb">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">true</bool>
			<float name="RolloffScale">1</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d0e</UniqueId>
			<token name="VolumetricAudio">1</token>
		</Properties>
		<Item class="ModuleScript" referent="RBXf682a34f14f342d6bb1c51433daa9127">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Sounds</string>
				<string name="ScriptGuid">{43064EE0-878C-4491-9264-87A1A1BBE459}</string>
				<ProtectedString name="Source"><![CDATA[--# selene: allow(shadowing)

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local instanceUtil = require(Utilities.instanceUtil)
local marketplaceUtil = require(Utilities.marketplaceUtil)
local Signals = require(Utilities.Signals)

local Sounds = {
	SoundSheets = {},
	SoundFailedToLoad = Signals.create(),
}

local function getSoundIdFromURL(URL): string
	return "rbxassetid://" .. string.match(URL, "%d+")
end

local Asset = Enum.InfoType.Asset

local function createSound(moduleScript: ModuleScript, soundGroup: SoundGroup)
	local soundSheet = require(moduleScript)

	soundSheet.Properties.SoundId = getSoundIdFromURL(soundSheet.URL)
	soundSheet.Properties.SoundGroup = soundGroup

	local sound: Sound = instanceUtil.create("Sound", soundSheet.Properties, moduleScript)

	marketplaceUtil.getProductInfo(string.match(soundSheet.URL, "%d+"), Asset)
		:andThen(function(ProductInfo)
			soundSheet.ProductInfo = ProductInfo
		end)
		:catch(function(message)
			warn(message)
		end)

	soundSheet.Sound = sound

	Sounds.SoundSheets[sound.SoundId] = soundSheet
end

local function createSoundGroup(folder: Folder): SoundGroup
	local SoundGroup: SoundGroup = Instance.new("SoundGroup")
	SoundGroup.Name = folder.Name
	SoundGroup.Volume = 1

	for _, child: Instance in ipairs(folder:GetChildren()) do
		if child:IsA("ModuleScript") then
			local ModuleScript: ModuleScript = child
			createSound(ModuleScript, SoundGroup)
			ModuleScript.Parent = SoundGroup
		elseif child:IsA("Folder") then
			local folder: Folder = child
			createSoundGroup(folder).Parent = SoundGroup
		end
	end

	folder:Destroy()

	return SoundGroup
end

function Sounds.GetSoundSheetFromSoundId(soundId: string)
	return Sounds.SoundSheets[soundId]
end

function Sounds.GenerateSoundsFromURL()
	for _, child: Instance in ipairs(script.Master:GetChildren()) do
		if child:IsA("Folder") then
			local folder: Folder = child
			local soundGroup = createSoundGroup(folder)
			soundGroup.Parent = script.Master
		end
	end
end

Sounds.SoundFailedToLoad:Connect(function(soundId: string)
	local soundSheet = Sounds.GetSoundSheetFromSoundId(soundId)
	soundSheet.Sound:SetAttribute("FailedToLoad", true)
	soundSheet.FailedToLoad = true
end)

return Sounds
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">38d136ec74d9240302cc7f550001a0a9</UniqueId>
			</Properties>
			<Item class="SoundGroup" referent="RBX197bd15819aa4f7d92e185e9a515efb3">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">Master</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">38d136ec74d9240302cc7f550001a0aa</UniqueId>
					<float name="Volume">0.5</float>
				</Properties>
				<Item class="Folder" referent="RBX5e83908d45f64a3e8f788f3a489238b1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">Template</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">38d136ec74d9240302cc7f550001a0ab</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX775e292d658040e5af16535c570659a3">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Silence</string>
							<string name="ScriptGuid">{F5132879-97C3-41BD-A6DC-FC772EB66C99}</string>
							<ProtectedString name="Source"><![CDATA[export type Splice = {
	Start: number,
	End: number,
}

export type Sprite = {
	Name: string,
	Splices: { Splice },
}

export type Sheet = {
	URL: string,
	Name: string,
	Sprites: { Sprite },
	Properties: { [string]: any? },
}

return {

	URL = "https://www.roblox.com/library/6766230018/Silence",
	Name = "Silence",

	Sprites = {
		{
			Name = "Silence",
			Splices = {
				{ Start = 0, End = 0.01 },
			},
		},
	},

	Properties = {
		Volume = 1,
	},
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38d136ec74d9240302cc7f550001a0ac</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX926eda1828b14d8eb5da21ccc69c1270">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">38d136ec74d9240302cc7f550001a0ad</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX74a992f362c141ccb482272fc9bd9660">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">User Interface UI Sound Effects</string>
							<string name="ScriptGuid">{3D94EEFE-BF19-4C10-95D4-43D5AF08E007}</string>
							<ProtectedString name="Source"><![CDATA[return {

	URL = "https://www.roblox.com/library/9166479682/User-Interface-UI-Sound-Effects",
	Name = "User Interface UI Sound Effects",

	Sprites = {
		{
			Name = "Beauty Click",
			Splices = { { Start = 0, End = 0.246442 } },
		},
		{
			Name = "Bubble Click",
			Splices = {
				{ Start = 0.348829, End = 0.51863 },
				-- { Start = 0.79052, End = 1.015533 },
			},
		},
		{
			Name = "Bubble Tap",
			Splices = { { Start = 1.386387, End = 1.639377 } },
		},
		{
			Name = "Button Click",
			Splices = { { Start = 1.756943, End = 1.861413 } },
		},
		{
			Name = "Click",
			Splices = {
				-- { Start = 1.989099, End = 2.095429 },
				-- { Start = 2.152798, End = 2.406086 },
				{ Start = 2.563238, End = 2.890042 },
			},
		},
		{
			Name = "Click Button",
			Splices = { { Start = 3.025763, End = 4.563944 } },
		},
		{
			Name = "Click Swoosh",
			Splices = { { Start = 5.597112, End = 5.762002 } },
		},
		{
			Name = "Info Click",
			Splices = { { Start = 5.826812, End = 5.83589 } },
		},
		{
			Name = "Pop",
			Splices = {
				{ Start = 5.904495, End = 5.993637 },
				-- { Start = 6.247148, End = 6.283459 },
			},
		},
		{
			Name = "Pop Click",
			Splices = { {
				Start = 6.480122,
				End = 6.960506,
			} },
		},
		{
			Name = "Soft Click",
			Splices = { { Start = 7.27719, End = 7.437913 } },
		},
	},

	Properties = {
		Volume = 1,
	},
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38d136ec74d9240302cc7f550001a0b6</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBXc93296362e8b4ce38319949883c5f177">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">SoundSystem</string>
				<string name="ScriptGuid">{2F2A9D06-B466-4E04-9812-7C0239458615}</string>
				<ProtectedString name="Source"><![CDATA[--# selene: allow(shadowing)

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local attributeUtil = require(Utilities.attributeUtil)
local instanceUtil = require(Utilities.instanceUtil)
local JSON = require(Utilities.JSON)
local t = require(Utilities.t)
local TypeChecks = require(Utilities.TypeChecks)
local tagUtil = require(Utilities.tagUtil)

local SoundRegistry = require(script.SoundRegistry)

local SoundSystem = setmetatable({
	USING_METATABLE = true,
	-- Metatable = SoundRegistry,
}, SoundRegistry)

TypeChecks.Strict.SFXCheck = t.strict(t.tuple(t.string, t.Instance))

local function shouldPlaySFX(parent: Instance, spriteName: string): boolean
	-- return true if parent does not have spriteTag
	return (not tagUtil.HasTag(parent, spriteName))
end

local function PlaySound(sound: Sound)
	if not sound:GetAttribute("FailedToLoad") and not sound.IsLoaded then
		sound.Loaded:Wait()
	end

	sound:Play()
end

local function createSoundAttributes(splice)
	local duration = (splice.End - splice.Start) / splice.Sound.PlaybackSpeed

	return {
		CreationTime = workspace:GetServerTimeNow(),

		Start = splice.Start,
		End = splice.End,

		Duration = duration,

		Hash = JSON.GenerateGUID(false),
	}
end

function SoundSystem.PlaySFX(spriteName: string, parent: Instance): Sound?
	TypeChecks.Strict.SFXCheck(spriteName, parent)

	if shouldPlaySFX(parent, spriteName) then
		tagUtil.AddTag(parent, spriteName)
		local splice: Splice = SoundRegistry.getRandomSpliceFromSprite(spriteName)
		if splice then
			local sound: Sound = splice.Sound:Clone()
			sound.Archivable = false

			local soundAttributes = createSoundAttributes(splice)
			soundAttributes.Play = true

			attributeUtil.SetAttributes(sound, soundAttributes)

			instanceUtil.setProperties(
				sound,
				{ Name = spriteName, TimePosition = splice.Start, Playing = true },
				parent
			)

			PlaySound(sound)

			return sound
		else
			warn(spriteName .. " is NOT a valid member of Sounds")
		end
	end
end

function SoundSystem.LoopSFX(spriteName: string, parent: Instance, loops: integer): Sound?
	TypeChecks.Strict.SFXCheck(spriteName, parent)

	if shouldPlaySFX(parent, spriteName) then
		tagUtil.AddTag(parent, spriteName)
		local splice: Splice = SoundRegistry.getRandomSpliceFromSprite(spriteName)
		if splice then
			local sound: Sound = splice.Sound:Clone()
			sound.Archivable = false

			local soundAttributes = createSoundAttributes(splice)
			soundAttributes.Loop = true
			soundAttributes.Intervals = loops

			attributeUtil.SetAttributes(sound, soundAttributes)

			instanceUtil.setProperties(
				sound,
				{ Name = spriteName, TimePosition = splice.Start, Playing = true, Looped = true },
				parent
			)

			PlaySound(sound)

			return sound
		else
			warn(spriteName .. " is NOT a valid member of Sounds")
		end
	end
end

local function StopSound(sound: Sound)
	sound:Stop()
	sound:Destroy()
end

function SoundSystem.StopSFX(spriteName: string, parent: Instance, sound: Sound?)
	if parent then
		TypeChecks.Strict.SFXCheck(spriteName, parent)

		local sound = sound or parent:FindFirstChild(spriteName)
		if sound then
			StopSound(sound)
			tagUtil.RemoveTag(parent, spriteName)
		end
	end
end

tagUtil.doForTagged(
	"Sound",
	t.wrap(function(sound: Sound)
		local currentTime = workspace:GetServerTimeNow()

		local soundAttributes = attributeUtil.GetAttributes(sound)

		if soundAttributes.Hash then
			local replicationTime = currentTime - soundAttributes.CreationTime
			if soundAttributes.Play then
				local totalPlayTime = soundAttributes.Duration - replicationTime
				task.delay(totalPlayTime, SoundSystem.StopSFX, sound.Name, sound.Parent, sound)
			elseif soundAttributes.Loop then
				while sound.IsPlaying do
					if soundAttributes.Intervals ~= 0 then
						sound.TimePosition = soundAttributes.Start
						task.wait(soundAttributes.Duration)
						soundAttributes.Intervals -= 1
					else
						break
					end
				end
				SoundSystem.StopSFX(sound.Name, sound.Parent, sound)
			end
		end
	end, t.instanceIsA("Sound"))
)

return SoundSystem
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags">QXV0by1SdW4=</BinaryString>
				<UniqueId name="UniqueId">38d136ec74d9240302cc7f550001a0d6</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="RBXb30de23cacfb49fcac3a0b8c364d3827">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SoundRegistry</string>
					<string name="ScriptGuid">{D5B0453A-7DEC-4795-B6EE-E184DD52CE47}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local array = require(Utilities.array)

local SoundService = game:GetService("SoundService")

local Sounds = require(SoundService.Sounds)

local ContentProvider = game:GetService("ContentProvider")
local RunService = game:GetService("RunService")

local SoundRegistry = { AllSprites = {}, AllSheets = {}, IS_CYCLICAL = true }
SoundRegistry.__index = SoundRegistry

local SoundGroups = {}
SoundRegistry.SoundGroups = SoundGroups

export type Splice = {
	Start: number,
	End: number,

	Name: string,
	Number: integer,
	Next: Splice,
	Previous: Splice,
	SheetName: string,
	SpriteName: string,
	Duration: number,
	Sound: Sound,
}

local Splices: Splices = {}
SoundRegistry.Splices = Splices

local function createSplice(spliceNumber: integer, splice: Splice, sprite: Sprite)
	splice.Name = sprite.Name
	splice.Number = spliceNumber
	splice.Next = sprite.Splices[spliceNumber + 1]
	splice.Previous = sprite.Splices[spliceNumber - 1]
	splice.SheetName = sprite.SheetName
	splice.SpriteName = sprite.Name
	splice.Sound = sprite.Sound

	table.insert(Splices[sprite.Name], splice)
end

function SoundRegistry.getSplice(spliceName: string): Splice?
	return Splices[spliceName]
end

function SoundRegistry.getRandomSpliceFromSprite(spriteName: string): Splice?
	return array.random(Splices[spriteName])
end

local function registerSplice(sprite: Sprite)
	Splices[sprite.Name] = {}

	for spliceNumber: integer, splice: Splice in ipairs(sprite.Splices) do
		createSplice(spliceNumber, splice, sprite)
	end
end

export type Sprite = {
	Name: string,
	Splices: { Splice },

	Number: integer,
	Next: spriteData,
	Previous: spriteData,
	SheetName: string,
	Sound: Sound,
	SoundGroup: SoundGroup,
}

local Sprites = {}
SoundRegistry.Sprites = Sprites

local function createSprite(spriteNumber: integer, sprite: Sprite, sheet: Sheet)
	sprite.Number = spriteNumber
	sprite.Next = sheet.Sprites[spriteNumber + 1]
	sprite.Previous = sheet.Sprites[spriteNumber - 1]

	sprite.SheetName = sheet.Name
	sprite.Sound = sheet.Sound

	sprite.SoundGroup = sheet.SoundGroup

	Sprites[sprite.Name] = sprite

	registerSplice(sprite)

	table.insert(SoundGroups[sprite.SoundGroup.Name].Sprites, sprite.Name)

	table.insert(SoundRegistry.AllSprites, sprite.Name)
end

function SoundRegistry.getSprite(sheetName: string): Sprite?
	return Sprites[sheetName]
end

local function registerSprites(sheet: Sheet)
	for spriteNumber: integer, sprite: Sprite in ipairs(sheet.Sprites) do
		createSprite(spriteNumber, sprite, sheet)
	end
end

export type Sheet = {
	URL: string,
	Name: string,
	Sprites: { Sprite },
	Properties: { [string]: any? },

	script: ModuleScript,
	Sound: Sound,
	SoundId: string,
	SoundGroup: SoundGroup,
}

export type Sheets = { Sheet }

local Sheets = {}
SoundRegistry.Sheets = Sheets

local function createSheet(moduleScript: ModuleScript, soundgroup: SoundGroup)
	local sheet = require(moduleScript)

	sheet.script = moduleScript
	sheet.Sound = moduleScript.Sound
	sheet.SoundId = moduleScript.Sound.SoundId
	sheet.SoundGroup = soundgroup

	sheet.Sound.SoundGroup = soundgroup

	Sheets[moduleScript.Name] = sheet

	registerSprites(sheet)

	table.insert(SoundGroups[moduleScript.Parent.Name].Sheets, sheet.Name)

	table.insert(SoundRegistry.AllSheets, sheet.Name)
end

function SoundRegistry.getSheet(sheetName: string): Sheet?
	return Sheets[sheetName]
end

local function registerSheets(soundgroup: SoundGroup)
	for _, child: Instance in ipairs(soundgroup:GetChildren()) do
		if child:IsA("ModuleScript") then
			createSheet(child, soundgroup)
		end
	end
end

local function createSoundGroup(soundgroup: SoundGroup)
	SoundGroups[soundgroup.Name] = {
		Sheets = {},
		Sprites = {},
		SoundGroup = soundgroup,
	}

	registerSheets(soundgroup)
end

function SoundRegistry.getSoundGroup(soundgroupName: string): SoundGroup?
	return SoundGroups[soundgroupName]
end

function SoundRegistry.getRandomSheetFromSoundGroup(soundgroupName: string): string
	return array.random(SoundGroups[soundgroupName].Sheets)
end

function SoundRegistry.getRandomSpriteFromSoundGroup(soundgroupName: string): string
	return array.random(SoundGroups[soundgroupName].Sprites)
end

function SoundRegistry.remove(sheet: Sheet)
	for _, sprite in ipairs(sheet.Sprites) do
		Splices[sprite.Name] = nil
		Sprites[sprite.Name] = nil
		array.remove(SoundRegistry.AllSprites, sprite.Name)
		array.remove(SoundGroups[sheet.SoundGroup.Name].Sprites, sprite.Name)
	end

	Sheets[sheet.Name] = nil
	array.remove(SoundRegistry.AllSheets, sheet.Name)
	array.remove(SoundGroups[sheet.SoundGroup.Name].Sheets, sheet.Name)
end

local function registerSoundGroups(source: Instance)
	for _, child: Instance in ipairs(source:GetChildren()) do
		if child:IsA("SoundGroup") then
			createSoundGroup(child)
			registerSoundGroups(child)
		end
	end
end

function SoundRegistry.WaitUntilLoadedSounds()
	if not script:GetAttribute("isLoaded") then
		script:GetAttributeChangedSignal("isLoaded"):Wait()
	end
end

task.spawn(function()
	if RunService:IsServer() then
		Sounds.GenerateSoundsFromURL()
		registerSoundGroups(SoundService.Sounds.Master)
		script:SetAttribute("isLoaded", true)

		local FAILURE = Enum.AssetFetchStatus.Failure
		ContentProvider:PreloadAsync({ SoundService.Sounds }, function(contentId, AssetFetchStatus)
			if AssetFetchStatus == FAILURE then
				Sounds.SoundFailedToLoad:Fire(contentId)
			end
		end)
	elseif RunService:IsClient() then
		function SoundRegistry.WaitUntilRegisteredSounds()
			if not script:GetAttribute("isRegistered") then
				script:GetAttributeChangedSignal("isRegistered"):Wait()
			end
		end

		function SoundRegistry.WaitUntilPreloadedSounds()
			if not script:GetAttribute("isPreloaded") then
				script:GetAttributeChangedSignal("isPreloaded"):Wait()
			end
		end

		SoundRegistry.WaitUntilLoadedSounds()

		registerSoundGroups(SoundService.Sounds.Master)
		script:SetAttribute("isRegistered", true)

		ContentProvider:PreloadAsync({ SoundService.Sounds })
		script:SetAttribute("isPreloaded", true)
	end
end)

return SoundRegistry
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">38d136ec74d9240302cc7f550001a0d7</UniqueId>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="VideoCaptureService" referent="RBXf0793d7bc6814e2ab6f11d7c1545eb27">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VideoCaptureService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">118b823fbc6f4004040d84d9000002f0</UniqueId>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBX7ab70f5a140443ac8acdb8f8d68d640d">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d1a</UniqueId>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="RBXa85aed10f1da42dabd48f94bf75062ed">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d1b</UniqueId>
		</Properties>
	</Item>
	<Item class="Chat" referent="RBXda916ae9db134b56956cb374ae2854d2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BubbleChatEnabled">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LoadDefaultChat">false</bool>
			<string name="Name">Chat</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d20</UniqueId>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBXef10ddff0dd349968e048ce230ff4e75">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d21</UniqueId>
		</Properties>
	</Item>
	<Item class="Players" referent="RBX9f70a66f5bdb4d9d868bb4c56ade15d8">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="CharacterAutoLoads">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxPlayersInternal">30</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">30</int>
			<float name="RespawnTime">3</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d23</UniqueId>
			<bool name="UseStrafingAnimations">false</bool>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="RBX6714196ab1e948f7a16b38211e0aa5b0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ReplicatedFirst</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d27</UniqueId>
		</Properties>
	</Item>
	<Item class="TweenService" referent="RBX3138318fc8fc4426a95690733da1645e">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TweenService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d29</UniqueId>
		</Properties>
	</Item>
	<Item class="MaterialService" referent="RBXade2dfb5635b47e096654043cd530688">
		<Properties>
			<string name="AsphaltName">Asphalt</string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="BasaltName">Basalt</string>
			<string name="BrickName">Brick</string>
			<string name="CobblestoneName">Cobblestone</string>
			<string name="ConcreteName">Concrete</string>
			<string name="CorrodedMetalName">CorrodedMetal</string>
			<string name="CrackedLavaName">CrackedLava</string>
			<string name="DiamondPlateName">DiamondPlate</string>
			<string name="FabricName">Fabric</string>
			<string name="FoilName">Foil</string>
			<string name="GlacierName">Glacier</string>
			<string name="GraniteName">Granite</string>
			<string name="GrassName">Grass</string>
			<string name="GroundName">Ground</string>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="IceName">Ice</string>
			<string name="LeafyGrassName">LeafyGrass</string>
			<string name="LimestoneName">Limestone</string>
			<string name="MarbleName">Marble</string>
			<string name="MetalName">Metal</string>
			<string name="MudName">Mud</string>
			<string name="Name">MaterialService</string>
			<string name="PavementName">Pavement</string>
			<string name="PebbleName">Pebble</string>
			<string name="PlasticName">Plastic</string>
			<string name="RockName">Rock</string>
			<string name="SaltName">Salt</string>
			<string name="SandName">Sand</string>
			<string name="SandstoneName">Sandstone</string>
			<string name="SlateName">Slate</string>
			<string name="SmoothPlasticName">SmoothPlastic</string>
			<string name="SnowName">Snow</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d2a</UniqueId>
			<bool name="Use2022MaterialsXml">false</bool>
			<string name="WoodName">Wood</string>
			<string name="WoodPlanksName">WoodPlanks</string>
		</Properties>
	</Item>
	<Item class="TextChatService" referent="RBX9946721bc7054a6b9444d979c80d7b79">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="ChatVersion">0</token>
			<bool name="CreateDefaultCommands">true</bool>
			<bool name="CreateDefaultTextChannels">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TextChatService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d2b</UniqueId>
		</Properties>
		<Item class="ChatWindowConfiguration" referent="RBX42f0c6f6dc224cf292df523296eea7d2">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0.2999999999999999889</double>
				<bool name="Enabled">true</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/GothamSSm-Medium.otf</url></CachedFaceId>
				</Font>
				<float name="HeightScale">1</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<token name="HorizontalAlignment">1</token>
				<string name="Name">ChatWindowConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Color3 name="TextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="TextSize">14</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">0.5</double>
				<UniqueId name="UniqueId">20d1792214748cc902cb375400013f58</UniqueId>
				<token name="VerticalAlignment">1</token>
				<float name="WidthScale">1</float>
			</Properties>
		</Item>
		<Item class="ChatInputBarConfiguration" referent="RBXfc531dc9bcb24cc7a122546ceab03591">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0.2000000000000000111</double>
				<bool name="Enabled">true</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/GothamSSm-Medium.otf</url></CachedFaceId>
				</Font>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">ChatInputBarConfiguration</string>
				<Color3 name="PlaceholderColor3">
					<R>0.698039234</R>
					<G>0.698039234</G>
					<B>0.698039234</B>
				</Color3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Ref name="TargetTextChannel">null</Ref>
				<Color3 name="TextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="TextSize">14</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">0.5</double>
				<UniqueId name="UniqueId">20d1792214748cc902cb375400013f59</UniqueId>
			</Properties>
		</Item>
		<Item class="BubbleChatConfiguration" referent="RBXe223169cb4b84938a8b3d0d1539c63f5">
			<Properties>
				<string name="AdorneeName">HumanoidRootPart</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="BackgroundColor3">
					<R>0.980392158</R>
					<G>0.980392158</G>
					<B>0.980392158</B>
				</Color3>
				<double name="BackgroundTransparency">0.10000000000000000555</double>
				<float name="BubbleDuration">15</float>
				<float name="BubblesSpacing">6</float>
				<bool name="Enabled">true</bool>
				<token name="Font">18</token>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/GothamSSm-Medium.otf</url></CachedFaceId>
				</Font>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Vector3 name="LocalPlayerStudsOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="MaxDistance">100</float>
				<float name="MinimizeDistance">40</float>
				<string name="Name">BubbleChatConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Color3 name="TextColor3">
					<R>0.223529413</R>
					<G>0.23137255</G>
					<B>0.239215687</B>
				</Color3>
				<int64 name="TextSize">16</int64>
				<UniqueId name="UniqueId">118b823fbc6f4004040d84d90000301e</UniqueId>
				<float name="VerticalStudsOffset">0</float>
			</Properties>
		</Item>
	</Item>
	<Item class="PermissionsService" referent="RBX404668fdead6420bac029d0e5bdda725">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PermissionsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d2f</UniqueId>
		</Properties>
	</Item>
	<Item class="PlayerEmulatorService" referent="RBXbc1da00971454ca4a3c14c7d9609a087">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="CustomPoliciesEnabled">false</bool>
			<string name="EmulatedCountryCode"></string>
			<string name="EmulatedGameLocale"></string>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PlayerEmulatorService</string>
			<bool name="PlayerEmulationEnabled">false</bool>
			<BinaryString name="SerializedEmulatedPolicyInfo"></BinaryString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d31</UniqueId>
		</Properties>
	</Item>
	<Item class="StudioData" referent="RBXe9438d7920114961b99693d9bcc796f2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="EnableScriptCollabByDefaultOnLoad">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StudioData</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d34</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="RBXfdc320c5b1cb4357836a5024f8e0eb95">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoJumpEnabled">false</bool>
			<float name="CameraMaxZoomDistance">32</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">false</bool>
			<float name="CharacterWalkSpeed">16</float>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<token name="EnableDynamicHeads">0</token>
			<bool name="EnableMouseLockOption">false</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">0</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<token name="HumanoidStateMachineMode">0</token>
			<bool name="LoadCharacterAppearance">false</bool>
			<token name="LoadCharacterLayeredClothing">0</token>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">0</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d35</UniqueId>
			<bool name="UserEmotesEnabled">true</bool>
		</Properties>
		<Item class="StarterPlayerScripts" referent="RBX694fed7b4bfb484b87e470f7d6e8253f">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">StarterPlayerScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">20d1792214748cc902cb375400013f4f</UniqueId>
			</Properties>
			<Item class="Folder" referent="RBXb41bed2af497417eb105c52ff573138e">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">ClientCore</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0d3</UniqueId>
				</Properties>
				<Item class="LocalScript" referent="RBXa69c430c10134f86b7c2f96c5250b5c2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ClientScriptsRunner</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{2BE3DCEE-3FDF-4BE2-AFE1-9CF7F42425FC}</string>
						<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local TestService = game:GetService("TestService")

local function runScripts(require)
	for _, modulescript: ModuleScript in ipairs(CollectionService:GetTagged("Auto-Run")) do
		task.spawn(require, modulescript)
	end

	CollectionService:GetInstanceAddedSignal("Auto-Run"):Connect(function(modulescript: ModuleScript)
		task.spawn(require, modulescript)
	end)

	for _, modulescript: ModuleScript in ipairs(CollectionService:GetTagged("Auto-Run [Client]")) do
		task.spawn(require, modulescript)
	end

	CollectionService:GetInstanceAddedSignal("Auto-Run [Client]"):Connect(function(modulescript: ModuleScript)
		task.spawn(require, modulescript)
	end)
end

if RunService:IsStudio() and TestService.ENABLE_BENCHMARKER.Value then
	local timeMap = {}
	local timeList = {}
	local totalTime = 0

	runScripts(function(modulescript: ModuleScript)
		local startTime = os.clock()
		require(modulescript)
		local endTime = os.clock()
		local runTime = endTime - startTime
		totalTime += runTime

		timeMap[runTime] = modulescript
		table.insert(timeList, runTime)
	end)

	local function results()
		table.sort(timeList)
		for _, runTime: number in ipairs(timeList) do
			warn(timeMap[runTime], runTime)
		end
		warn("Total Runtime:", totalTime)
	end
	results()
else
	runScripts(require)
end
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0d4</UniqueId>
					</Properties>
				</Item>
				<Item class="LocalScript" referent="RBX46cf09bfa8314b76980a7cbd733aa34d">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">UIController</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{E7AA0265-F6C4-4454-A13C-8E888F068BD9}</string>
						<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local PlayerGui = localPlayer.PlayerGui
local PlayerScripts = localPlayer.PlayerScripts

local ContentProvider = game:GetService("ContentProvider")

for _, child: Instance in ipairs(PlayerScripts:WaitForChild("UI"):GetChildren()) do
	if child:IsA("ModuleScript") then
		local moduleScript: ModuleScript = child
		task.spawn(function()
			local UI = require(moduleScript)
			moduleScript.Parent = UI
			UI.Parent = PlayerGui
			script:SetAttribute(moduleScript.Name, true)
		end)
	end
end

ContentProvider:PreloadAsync({ PlayerGui })
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0d5</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX1a37388136ae4a1d97d22c979df5a99d">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0d9</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBXe2f42eee5b134b2db4d5bc5e0148c61c">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Screen</string>
						<string name="ScriptGuid">{A7A5430F-4E60-4C15-BCB1-36D34EB8FC3F}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local guiUtil = require(Utilities.guiUtil)
local Nature2D = require(Utilities.Nature2D)

local SoundService = game:GetService("SoundService")
local SoundSystem = require(SoundService.SoundSystem)

local UserInputService = game:GetService("UserInputService")

local screen: ScreenGui = guiUtil.createUI(
	"ScreenGui",
	{ Name = "Screen", IgnoreGuiInset = true, ResetOnSpawn = false }
)

local canvas: Frame = guiUtil.createUI("Frame", { Name = "Canvas", Size = UDim2.fromScale(1, 1) }, screen)

local timer_txt = guiUtil.createUI("TextLabel", {
	Name = "Timer",
	Text = 0,
	AnchorPoint = Vector2.new(1, 0),
	Position = UDim2.fromScale(1, 0.05),
	Size = UDim2.fromScale(0.1, 0.05),
	TextScaled = true,
	BorderSizePixel = 0,
}, canvas)

local score_txt = guiUtil.createUI("TextLabel", {
	Name = "Score",
	Text = 0,
	AnchorPoint = Vector2.new(1, 0),
	Position = UDim2.fromScale(1, 0.1),
	Size = UDim2.fromScale(0.1, 0.05),
	TextScaled = true,
	BorderSizePixel = 0,
}, canvas)

local streak_txt = guiUtil.createUI("TextLabel", {
	Name = "Streak",
	Text = 0,
	AnchorPoint = Vector2.new(1, 0),
	Position = UDim2.fromScale(1, 0.15),
	Size = UDim2.fromScale(0.1, 0.05),
	TextScaled = true,
	BorderSizePixel = 0,
}, canvas)

guiUtil.createUI("TextLabel", {
	Name = "How to left",
	Text = "A < Left",
	AnchorPoint = Vector2.new(0.5, 0),
	Position = UDim2.fromScale(0.3, 0.1),
	Size = UDim2.fromScale(0.2, 0.05),
	TextScaled = true,
	BorderSizePixel = 0,
}, canvas)

guiUtil.createUI("TextLabel", {
	Name = "How to right",
	Text = "D > Right",
	AnchorPoint = Vector2.new(0.5, 0),
	Position = UDim2.fromScale(0.7, 0.1),
	Size = UDim2.fromScale(0.2, 0.05),
	TextScaled = true,
	BorderSizePixel = 0,
}, canvas)

guiUtil.createUI("TextLabel", {
	Name = "How to score",
	Text = "Collect fruits for points",
	AnchorPoint = Vector2.new(0.5, 0),
	Position = UDim2.fromScale(0.5, 0.3),
	Size = UDim2.fromScale(0.2, 0.1),
	TextScaled = true,
	BorderSizePixel = 0,
}, canvas)

local Character = require(script.Character)
Character.Parent = canvas

local Platform = require(script.Platform)
Platform.Parent = canvas

local engine = Nature2D.init(screen)
engine.canvas.frame = canvas

local Apple = engine:Create("RigidBody", {
	Object = require(script.Apple),
	Collidable = true,
	Anchored = true,
})
Apple:SetState("Points", 4)

local Pear = engine:Create("RigidBody", {
	Object = require(script.Pear),
	Collidable = true,
	Anchored = true,
})
Pear:SetState("Points", 3)

local Orange = engine:Create("RigidBody", {
	Object = require(script.Orange),
	Collidable = true,
	Anchored = true,
})
Orange:SetState("Points", 2)

local Mango = engine:Create("RigidBody", {
	Object = require(script.Mango),
	Collidable = true,
	Anchored = true,
})
Mango:SetState("Points", 1)

local platform = engine:Create("RigidBody", {
	Object = Platform,
	Collidable = true,
	Anchored = true,
})

local function isAFruit(fruit): boolean
	return fruit:GetState("Fruit")
end

local Streaks = 0

platform.Touched:Connect(function(id: string)
	local fruit = engine:GetBodyById(id)

	if isAFruit(fruit) then
		fruit:Destroy()
		Streaks = 0
	end

	streak_txt.Text = "Combo: " .. Streaks
end)

local player = engine:Create("RigidBody", {
	Object = Character,
	Collidable = true,
	Anchored = false,
})

player:CanRotate(false)
player:SetMaxForce(20)

player:SetState("Points", 0)

local Points = 0

player.Touched:Connect(function(id: string)
	local fruit = engine:GetBodyById(id)

	if isAFruit(fruit) then
		fruit:Destroy()
		Points += fruit:GetState("Points")
		Streaks += 1
		SoundSystem.PlaySFX("Pop", SoundService)
	end

	score_txt.Text = "Points: " .. Points
	streak_txt.Text = "Combo: " .. Streaks
end)

local isMoving = { Left = false, Jump = false, Right = false }

local function detectPlayerInput()
	UserInputService.InputBegan:Connect(function(input)
		if input.KeyCode == Enum.KeyCode.A then
			isMoving.Left = true
		elseif input.KeyCode == Enum.KeyCode.D then
			isMoving.Right = true
		end
	end)

	UserInputService.InputEnded:Connect(function(input)
		if input.KeyCode == Enum.KeyCode.A then
			isMoving.Left = false
		elseif input.KeyCode == Enum.KeyCode.D then
			isMoving.Right = false
		end
	end)
end
detectPlayerInput()

local MOVEMENT = {
	MOVEFORCE = 5,
}

MOVEMENT.LEFT = Vector2.new(-MOVEMENT.MOVEFORCE, 0)
MOVEMENT.RIGHT = Vector2.new(MOVEMENT.MOVEFORCE, 0)

engine.Updated:Connect(function()
	if isMoving.Left then
		player:ApplyForce(MOVEMENT.LEFT)
	elseif isMoving.Right then
		player:ApplyForce(MOVEMENT.RIGHT)
	end
end)

engine:Start()

task.delay(1, function()
	local rng = Random.new()

	local function spawnFruit(selectedFruit)
		local fruit = selectedFruit:Clone(true)
		local frame = fruit:GetFrame()
		frame.Parent = canvas
		fruit:SetState("Fruit", true)
		fruit:SetPosition(
			rng:NextInteger(frame.AbsoluteSize.X * 2, canvas.AbsoluteSize.X - frame.AbsoluteSize.X * 2, 0),
			frame.AbsoluteSize.Y
		)
		fruit:Unanchor()
	end

	local Fruits = {
		Apple,
		Pear,
		Orange,
		Mango,
	}

	local function spawnRandomFruit()
		local fruit = Fruits[rng:NextInteger(1, #Fruits)]
		spawnFruit(fruit)
	end

	task.spawn(function()
		local startTime = os.time()
		while true do
			timer_txt.Text = "Timer: " .. os.time() - startTime
			task.wait(1)
		end
	end)

	while true do
		spawnRandomFruit()
		task.wait(rng:NextNumber(1, 2))
	end
end)

return screen
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">38d136ec74d9240302cc7f550001a0c8</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX8695c45c06fe4297b31e60d394ed6705">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Character</string>
							<string name="ScriptGuid">{6F473413-C7AC-4DAC-B047-F3D44DBB9510}</string>
							<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local guiUtil = require(Utilities.guiUtil)

local viewport = workspace.CurrentCamera.ViewportSize
workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
	viewport = workspace.CurrentCamera.ViewportSize
end)

local Character = guiUtil.createUI("Frame", {
	Name = "Player",
	Position = UDim2.fromOffset(10, viewport.Y * 0.85),
	Size = UDim2.fromOffset(viewport.X * 0.05, viewport.Y * 0.1),
	BackgroundColor3 = Color3.new(0, 0, 0),
	BorderSizePixel = 0,
})

return Character
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38d136ec74d9240302cc7f55004c2218</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXf87b0fe8fa304fcb880ba3b9e7b0a656">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Platform</string>
							<string name="ScriptGuid">{77582B08-E6CD-4C46-9AED-68A52EEE16E4}</string>
							<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local guiUtil = require(Utilities.guiUtil)

local viewport = workspace.CurrentCamera.ViewportSize
workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
	viewport = workspace.CurrentCamera.ViewportSize
end)

local Platform = guiUtil.createUI("Frame", {
	Name = "Platform",
	Position = UDim2.fromOffset(0, viewport.Y * 0.95),
	Size = UDim2.fromOffset(viewport.X * 1, viewport.Y * 0.05),
	BackgroundColor3 = Color3.new(1, 0, 0),
	BorderSizePixel = 0,
})

return Platform
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38d136ec74d9240302cc7f5500522c41</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXab7698cee1284c3aa54e9f43db750702">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Apple</string>
							<string name="ScriptGuid">{2FD171B0-5BEA-471A-84FD-DD182D18B3D4}</string>
							<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local guiUtil = require(Utilities.guiUtil)

local viewport = workspace.CurrentCamera.ViewportSize
workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
	viewport = workspace.CurrentCamera.ViewportSize
end)

local Apple = guiUtil.createUI("Frame", {
	Name = "Apple",
	Size = UDim2.fromOffset(viewport.X * 0.01, viewport.X * 0.01),
	BackgroundColor3 = Color3.fromRGB(255, 0, 0),
	BorderSizePixel = 0,
})

return Apple
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38d136ec74d9240302cc7f55005a3c54</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX7fc39e475398447e9c949135e180bef3">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Pear</string>
							<string name="ScriptGuid">{91D7A49A-90A8-44B9-A17A-F63248A73949}</string>
							<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local guiUtil = require(Utilities.guiUtil)

local viewport = workspace.CurrentCamera.ViewportSize
workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
	viewport = workspace.CurrentCamera.ViewportSize
end)

local Pear = guiUtil.createUI("Frame", {
	Name = "Pear",
	Size = UDim2.fromOffset(viewport.X * 0.02, viewport.X * 0.02),
	BackgroundColor3 = Color3.fromRGB(132, 255, 0),
	BorderSizePixel = 0,
})

return Pear
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38d136ec74d9240302cc7f5500879d0e</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXab06e59c809e4e3f8d693f297c695eb5">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Orange</string>
							<string name="ScriptGuid">{578C2806-C56C-4B07-9CEC-508EFADDC9A6}</string>
							<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local guiUtil = require(Utilities.guiUtil)

local viewport = workspace.CurrentCamera.ViewportSize
workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
	viewport = workspace.CurrentCamera.ViewportSize
end)

local Orange = guiUtil.createUI("Frame", {
	Name = "Orange",
	Size = UDim2.fromOffset(viewport.X * 0.03, viewport.X * 0.03),
	BackgroundColor3 = Color3.fromRGB(255, 119, 0),
	BorderSizePixel = 0,
})

return Orange
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38d136ec74d9240302cc7f5500879d10</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXe5a74c0cb16f42c2b5a2fa0914bc2d09">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Mango</string>
							<string name="ScriptGuid">{39B7F351-BFE9-4859-A5DE-5255C2F8B7B4}</string>
							<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local guiUtil = require(Utilities.guiUtil)

local viewport = workspace.CurrentCamera.ViewportSize
workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
	viewport = workspace.CurrentCamera.ViewportSize
end)

local Orange = guiUtil.createUI("Frame", {
	Name = "Orange",
	Size = UDim2.fromOffset(viewport.X * 0.04, viewport.X * 0.04),
	BackgroundColor3 = Color3.fromRGB(255, 255, 0),
	BorderSizePixel = 0,
})

return Orange
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">38d136ec74d9240302cc7f55008ca6fb</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX37b654e96a3f429cb959dea399cb4b32">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PlayerScriptsLoader</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{B461E1B6-C835-47AB-B5FC-F9AD4657B199}</string>
					<ProtectedString name="Source"></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270004a2a8</UniqueId>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX81f45e7cbcf24286800198ba4c661caa">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RbxCharacterSounds</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{AB5E05AF-0BDE-4DFF-8462-C0360D9B609E}</string>
					<ProtectedString name="Source"></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270004a2b2</UniqueId>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBXf76b48c6bf1c42cea31bfc13c88cdbe7">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Configurations</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{81B32B9C-3357-47A9-8407-4C66E69DC908}</string>
					<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Bindables = require(ReplicatedStorage.Bindables)
local Reset_Bindable = Bindables.create("Reset_Bindable")

local Configurations = require(ReplicatedStorage.Configurations)
local RoundInProgress = Configurations.COLLECTION_TAGS.RoundInProgress

local Utilities = ReplicatedStorage.Utilities
local playerUtil = require(Utilities.playerUtil)

local function doSetCore() --! Annoying StarterGui
	local StarterGui = game:GetService("StarterGui")

	local function reconfigureResetButton()
		StarterGui:SetCore("ResetButtonCallback", Reset_Bindable.BindableEvent)

		Reset_Bindable.Event:Connect(function()
			if workspace:GetAttribute(RoundInProgress) then
				local playerInfo = playerUtil.getPlayerInfo(localPlayer)
				playerUtil.killHumanoid(playerInfo.Humanoid)
			end
		end)
	end

	while task.wait(1) do
		if xpcall(reconfigureResetButton, reconfigureResetButton) then
			break
		end
	end

	local function setCoreGuiSettings()
		for CoreGuiType, disabled in pairs(Configurations.CORE_GUI_SETTINGS) do
			StarterGui:SetCoreGuiEnabled(CoreGuiType, disabled)
		end
	end
	setCoreGuiSettings()

	StarterGui:SetCore("ChatActive", Configurations.ChatActive)
end
doSetCore()
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">38d136ec74d9240302cc7f550007a9f9</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="StarterCharacterScripts" referent="RBXbef6923b508e40ff9ea822e70a88f31d">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">StarterCharacterScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">20d1792214748cc902cb375400013f4e</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBXbc9ecea2dbb94e0cb070cd975631c8a7">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StarterPack</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d36</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="RBX2e78bea08d9d4e81a6e075c265cfebb1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="RtlTextSupport">0</token>
			<token name="ScreenOrientation">4</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d37</UniqueId>
			<token name="VirtualCursorMode">0</token>
		</Properties>
	</Item>
	<Item class="LocalizationService" referent="RBX179d9f098b654bbaaa3245116ba88237">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LocalizationService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d39</UniqueId>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX3719916b6d5545968adb7c1246d1f74e">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Teleport Service</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d3d</UniqueId>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBXdda252c317d24634b268d77ac97e8141">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CollectionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d3f</UniqueId>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBX4db3cb42428242debcef682b493e77b1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d40</UniqueId>
		</Properties>
	</Item>
	<Item class="Geometry" referent="RBXee77c6d21f2241d3bb72e7aa8275867a">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Geometry</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d42</UniqueId>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBXfeda6e75c59748cf9085334bce6b156c">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">InsertService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d44</UniqueId>
		</Properties>
		<Item class="StringValue" referent="RBXabb0341424bd4dceb10e047fd67f9602">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">InsertionHash</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">20d1792214748cc902cb375400013f50</UniqueId>
				<string name="Value">{0A821A84-6F2D-47E6-BEFF-BBE36D65173A}</string>
			</Properties>
		</Item>
	</Item>
	<Item class="GamePassService" referent="RBXda91afa8b6e8432fa687a71805aad158">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">GamePassService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d45</UniqueId>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBXdcbc9b3c9b8c413d88be4138a6f28a00">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d46</UniqueId>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBX0a2afc2b99ad46c5a33b6b3bc6edc4e1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CookiesService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d47</UniqueId>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBX6daeaebd7d584368aee7f8f484ea3635">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VRService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d51</UniqueId>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBXd81d9f9f377e4aa0a50dba4e1ce29516">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ContextActionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d53</UniqueId>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBXc248b8907ed247b3b784fd9eff13b36a">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d55</UniqueId>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBX94e7df968821453faf7d6172b4deee14">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">AssetService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d56</UniqueId>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBX0e8e6e08a48b484392e723966f79beff">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TouchInputService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d57</UniqueId>
		</Properties>
	</Item>
	<Item class="AnalyticsService" referent="RBX200cc7a9e66b4c93be4fd10b97742f38">
		<Properties>
			<string name="ApiKey"></string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">AnalyticsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d5a</UniqueId>
		</Properties>
		<Item class="ModuleScript" referent="RBX9f967f26bcb54f2083bc2543da73e5d4">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">RobloxLSP_Settings</string>
				<string name="ScriptGuid">{4E92D598-D3E2-427E-9681-5C1B2A83B4D0}</string>
				<ProtectedString name="Source"><![CDATA[return {
	port = 27843,
	startAutomatically = false,
	exclude = {
		-- game:GetService("Workspace")
	}
}]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">20d1792214748cc902cb3754000198be</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="Selection" referent="RBX1e1da24fa5024a54939bfde66ff2a05b">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Selection</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d5d</UniqueId>
		</Properties>
	</Item>
	<Item class="ServerScriptService" referent="RBX489b26e6ec8b4d95b020d8b5e3af3d9b">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d5f</UniqueId>
		</Properties>
		<Item class="Folder" referent="RBX35f2bbafc8ae4284bc7f61de24286624">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">ServerCore</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0de</UniqueId>
			</Properties>
			<Item class="Script" referent="RBXf9a7e9d0c57349bcbe4133413e5db710">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ServerScriptsRunner</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{72485786-6F22-4B74-BB0F-5DD7D360FD52}</string>
					<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local TestService = game:GetService("TestService")

local function runScripts(require)
	for _, modulescript: ModuleScript in ipairs(CollectionService:GetTagged("Auto-Run")) do
		task.spawn(require, modulescript)
	end

	CollectionService:GetInstanceAddedSignal("Auto-Run"):Connect(function(modulescript: ModuleScript)
		task.spawn(require, modulescript)
	end)

	for _, modulescript: ModuleScript in ipairs(CollectionService:GetTagged("Auto-Run [Server]")) do
		task.spawn(require, modulescript)
	end

	CollectionService:GetInstanceAddedSignal("Auto-Run [Server]"):Connect(function(modulescript: ModuleScript)
		task.spawn(require, modulescript)
	end)
end

if RunService:IsStudio() and TestService.ENABLE_BENCHMARKER.Value then
	local timeMap = {}
	local timeList = {}
	local totalTime = 0

	runScripts(function(modulescript: ModuleScript)
		local startTime = os.clock()
		require(modulescript)
		local endTime = os.clock()
		local runTime = endTime - startTime
		totalTime += runTime

		timeMap[runTime] = modulescript
		table.insert(timeList, runTime)
	end)

	local function results()
		table.sort(timeList)
		for _, runTime: number in ipairs(timeList) do
			warn(timeMap[runTime], runTime)
		end
		warn("Total Runtime:", totalTime)
	end
	results()
else
	runScripts(require)
end
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0df</UniqueId>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="ServerStorage" referent="RBXeb35adcd1e5748588d2f3ad52cd7f9d0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ServerStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d60</UniqueId>
		</Properties>
		<Item class="Folder" referent="RBX8d7fce4c6f454a6181486dac3ce3e7ae">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">ServerPackages</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0da</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="ReplicatedStorage" referent="RBX9767f33a4a1a4dd4b2ed46ea6cc74146">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ReplicatedStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d61</UniqueId>
		</Properties>
		<Item class="ModuleScript" referent="RBX4d46134c96aa4f6d949cbf003a9df5a9">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Utilities</string>
				<string name="ScriptGuid">{98FD6F3C-8ED4-4563-9892-85E9E8D20468}</string>
				<ProtectedString name="Source"><![CDATA[local Utilities = {}

local InsertService = game:GetService("InsertService")

local RunService = game:GetService("RunService")
local isServer = RunService:IsServer()

local ERROR_FORMAT = "Found duplicated %s modules: %q, name must be unique"

local function registerUtilityModules()
	for _, child: Instance in ipairs(script:GetChildren()) do
		if child:IsA("ModuleScript") then
			local moduleScript: ModuleScript = child
			if Utilities[moduleScript.Name] == nil then
				Utilities[moduleScript.Name] = moduleScript
			else
				error(string.format(ERROR_FORMAT, "Utilities", moduleScript.Name))
			end
		end
	end
end

registerUtilityModules()

local function registerThirdPartyModules()
	local THIRDPARTY_MODULE_ASSET_ID = 8255468519
	local Model: Model = InsertService:LoadAsset(THIRDPARTY_MODULE_ASSET_ID)
	local thirdpartyModule: ModuleScript = require(Model.MainModule)
	for _, child: Instance in ipairs(thirdpartyModule:GetChildren()) do
		if child:IsA("ModuleScript") then
			local moduleScript: ModuleScript = child
			moduleScript.Parent = script
			if Utilities[moduleScript.Name] == nil then
				Utilities[moduleScript.Name] = moduleScript
			else
				error(string.format(ERROR_FORMAT, "Third-party", moduleScript.Name))
			end
		end
	end
	thirdpartyModule:Destroy()
end

if isServer then
	registerThirdPartyModules()
end

return Utilities
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags">QXV0by1SdW4AV2FsbHk=</BinaryString>
				<UniqueId name="UniqueId">1517939d06f7510002cb45270001a091</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="RBXc6debe9cd6394e6fa596b0c0ce550d3f">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Colors</string>
					<string name="ScriptGuid">{4E7A06DE-7722-42C2-BDCA-883974ED3657}</string>
					<ProtectedString name="Source"><![CDATA[local Color = {
	Alder = Color3.new(0.705882, 0.501961, 1.000000),
	Artichoke = Color3.new(0.541176, 0.670588, 0.521569),
	Beige = Color3.new(0.792157, 0.749020, 0.639216),
	Black = Color3.new(0.105882, 0.164706, 0.207843),
	Bronze = Color3.new(0.494118, 0.407843, 0.247059),
	Brown = Color3.new(0.486275, 0.360784, 0.274510),
	Burgundy = Color3.new(0.533333, 0.243137, 0.243137),
	Burlap = Color3.new(0.780392, 0.674510, 0.470588),
	Buttermilk = Color3.new(0.996078, 0.952941, 0.733333),
	Camo = Color3.new(0.227451, 0.490196, 0.082353),
	Cashmere = Color3.new(0.827451, 0.745098, 0.588235),
	Cocoa = Color3.new(0.337255, 0.141176, 0.141176),
	Copper = Color3.new(0.588235, 0.403922, 0.400000),
	Cork = Color3.new(0.737255, 0.607843, 0.364706),
	Crimson = Color3.new(0.592157, 0.000000, 0.000000),
	Cyan = Color3.new(0.015686, 0.686275, 0.925490),
	Eggplant = Color3.new(0.482353, 0.000000, 0.482353),
	Flint = Color3.new(0.411765, 0.400000, 0.360784),
	Fog = Color3.new(0.780392, 0.831373, 0.894118),
	Fossil = Color3.new(0.623529, 0.631373, 0.674510),
	Gold = Color3.new(0.937255, 0.721569, 0.219608),
	Grime = Color3.new(0.498039, 0.556863, 0.392157),
	Khaki = Color3.new(0.886275, 0.862745, 0.737255),
	Lapis = Color3.new(0.062745, 0.164706, 0.862745),
	Lavender = Color3.new(0.549020, 0.356863, 0.623529),
	Lilac = Color3.new(0.654902, 0.368627, 0.607843),
	Linen = Color3.new(0.686275, 0.580392, 0.513726),
	Magenta = Color3.new(0.666667, 0.000000, 0.666667),
	Maroon = Color3.new(0.458824, 0.000000, 0.000000),
	Mauve = Color3.new(0.878431, 0.698039, 0.815686),
	Mint = Color3.new(0.694118, 0.898039, 0.650980),
	Moss = Color3.new(0.486275, 0.611765, 0.419608),
	Mulberry = Color3.new(0.349020, 0.133333, 0.349020),
	Nougat = Color3.new(0.800000, 0.556863, 0.411765),
	Olive = Color3.new(0.756863, 0.745098, 0.258824),
	Olivine = Color3.new(0.580392, 0.745098, 0.505882),
	Oyster = Color3.new(0.733333, 0.701961, 0.698039),
	Pearl = Color3.new(0.905882, 0.905882, 0.925490),
	Persimmon = Color3.new(1.000000, 0.349020, 0.349020),
	Pink = Color3.new(1.000000, 0.400000, 0.800000),
	Plum = Color3.new(0.482353, 0.184314, 0.482353),
	Rust = Color3.new(0.560784, 0.298039, 0.164706),
	Salmon = Color3.new(1.000000, 0.580392, 0.580392),
	Seashell = Color3.new(0.913726, 0.854902, 0.854902),
	Shamrock = Color3.new(0.356863, 0.603922, 0.298039),
	Sunrise = Color3.new(0.831373, 0.564706, 0.741176),
	Tawny = Color3.new(0.588235, 0.333333, 0.333333),
	Teal = Color3.new(0.070588, 0.933333, 0.831373),
	Toothpaste = Color3.new(0.000000, 1.000000, 1.000000),
	Wheat = Color3.new(0.945098, 0.905882, 0.780392),
	White = Color3.new(0.949020, 0.952941, 0.952941),
	["Baby blue"] = Color3.new(0.596078, 0.760784, 0.858824),
	["Br. yellowish green"] = Color3.new(0.643137, 0.741176, 0.278431),
	["Br. yellowish orange"] = Color3.new(0.886275, 0.607843, 0.250980),
	["Brick yellow"] = Color3.new(0.843137, 0.772549, 0.603922),
	["Bright blue"] = Color3.new(0.050980, 0.411765, 0.674510),
	["Bright bluish green"] = Color3.new(0.000000, 0.560784, 0.611765),
	["Bright green"] = Color3.new(0.294118, 0.592157, 0.294118),
	["Bright orange"] = Color3.new(0.854902, 0.521569, 0.254902),
	["Bright red"] = Color3.new(0.768628, 0.156863, 0.109804),
	["Bright violet"] = Color3.new(0.419608, 0.196078, 0.486275),
	["Bright yellow"] = Color3.new(0.960784, 0.803922, 0.188235),
	["Burnt Sienna"] = Color3.new(0.415686, 0.223529, 0.035294),
	["CGA brown"] = Color3.new(0.666667, 0.333333, 0.000000),
	["Cadet blue"] = Color3.new(0.623529, 0.678431, 0.752941),
	["Carnation pink"] = Color3.new(1.000000, 0.596078, 0.862745),
	["Cloudy grey"] = Color3.new(0.670588, 0.658824, 0.619608),
	["Cool yellow"] = Color3.new(0.992157, 0.917647, 0.552941),
	["Daisy orange"] = Color3.new(0.972549, 0.850980, 0.427451),
	["Dark blue"] = Color3.new(0.000000, 0.062745, 0.690196),
	["Dark green"] = Color3.new(0.156863, 0.498039, 0.278431),
	["Dark indigo"] = Color3.new(0.239216, 0.082353, 0.521569),
	["Dark orange"] = Color3.new(0.627451, 0.372549, 0.207843),
	["Dark stone grey"] = Color3.new(0.388235, 0.372549, 0.384314),
	["Dark taupe"] = Color3.new(0.352941, 0.298039, 0.258824),
	["Deep blue"] = Color3.new(0.129412, 0.329412, 0.725490),
	["Deep orange"] = Color3.new(1.000000, 0.690196, 0.000000),
	["Dirt brown"] = Color3.new(0.337255, 0.258824, 0.211765),
	["Dusty Rose"] = Color3.new(0.639216, 0.294118, 0.294118),
	["Earth green"] = Color3.new(0.152941, 0.274510, 0.176471),
	["Electric blue"] = Color3.new(0.035294, 0.537255, 0.811765),
	["Fawn brown"] = Color3.new(0.627451, 0.517647, 0.309804),
	["Forest green"] = Color3.new(0.121569, 0.501961, 0.113725),
	["Ghost grey"] = Color3.new(0.792157, 0.796079, 0.819608),
	["Hot pink"] = Color3.new(1.000000, 0.000000, 0.749020),
	["Hurricane grey"] = Color3.new(0.584314, 0.537255, 0.533333),
	["Institutional white"] = Color3.new(0.972549, 0.972549, 0.972549),
	["Laurel green"] = Color3.new(0.658824, 0.741176, 0.600000),
	["Light blue"] = Color3.new(0.705882, 0.823529, 0.894118),
	["Light orange"] = Color3.new(0.917647, 0.721569, 0.572549),
	["Light reddish violet"] = Color3.new(0.909804, 0.729412, 0.784314),
	["Light stone grey"] = Color3.new(0.898039, 0.894118, 0.874510),
	["Lily white"] = Color3.new(0.929412, 0.917647, 0.917647),
	["Lime green"] = Color3.new(0.000000, 1.000000, 0.000000),
	["Medium blue"] = Color3.new(0.431373, 0.600000, 0.792157),
	["Medium green"] = Color3.new(0.631373, 0.768628, 0.549020),
	["Medium red"] = Color3.new(0.854902, 0.525490, 0.478431),
	["Medium stone grey"] = Color3.new(0.639216, 0.635294, 0.647059),
	["Mid gray"] = Color3.new(0.803922, 0.803922, 0.803922),
	["Navy blue"] = Color3.new(0.000000, 0.125490, 0.376471),
	["Neon orange"] = Color3.new(0.835294, 0.450980, 0.239216),
	["New Yeller"] = Color3.new(1.000000, 1.000000, 0.000000),
	["Parsley green"] = Color3.new(0.172549, 0.396078, 0.113725),
	["Pastel Blue"] = Color3.new(0.501961, 0.733333, 0.858824),
	["Pastel blue-green"] = Color3.new(0.623529, 0.952941, 0.913726),
	["Pastel brown"] = Color3.new(1.000000, 0.800000, 0.600000),
	["Pastel green"] = Color3.new(0.800000, 1.000000, 0.800000),
	["Pastel light blue"] = Color3.new(0.686275, 0.866667, 1.000000),
	["Pastel orange"] = Color3.new(1.000000, 0.788235, 0.788235),
	["Pastel violet"] = Color3.new(0.694118, 0.654902, 1.000000),
	["Pastel yellow"] = Color3.new(1.000000, 1.000000, 0.800000),
	["Pine Cone"] = Color3.new(0.423529, 0.345098, 0.294118),
	["Quill grey"] = Color3.new(0.874510, 0.874510, 0.870588),
	["Really black"] = Color3.new(0.066667, 0.066667, 0.066667),
	["Really blue"] = Color3.new(0.000000, 0.000000, 1.000000),
	["Really red"] = Color3.new(1.000000, 0.000000, 0.000000),
	["Reddish brown"] = Color3.new(0.411765, 0.250980, 0.156863),
	["Royal purple"] = Color3.new(0.384314, 0.145098, 0.819608),
	["Sage green"] = Color3.new(0.725490, 0.768628, 0.694118),
	["Sand blue"] = Color3.new(0.454902, 0.525490, 0.615686),
	["Sand green"] = Color3.new(0.470588, 0.564706, 0.509804),
	["Sand red"] = Color3.new(0.584314, 0.474510, 0.466667),
	["Sea green"] = Color3.new(0.203922, 0.556863, 0.250980),
	["Slime green"] = Color3.new(0.313726, 0.427451, 0.329412),
	["Smoky grey"] = Color3.new(0.356863, 0.364706, 0.411765),
	["Steel blue"] = Color3.new(0.321569, 0.486275, 0.682353),
	["Storm blue"] = Color3.new(0.200000, 0.345098, 0.509804),
	["Terra Cotta"] = Color3.new(0.745098, 0.407843, 0.384314),
}

Color.white = Color3.new(1, 1, 1)
Color.black = Color3.new(0, 0, 0)

Color.red = Color3.new(1, 0, 0)
Color.green = Color3.new(0, 1, 0)
Color.blue = Color3.new(0, 0, 1)

Color.yellow = Color3.new(1, 1, 0)
Color.orange = Color3.new(1, 0.5, 0)
Color.purple = Color3.new(1, 0, 1)

return Color
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a092</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX3ba8612241854ba2b06d2cd6722d3218">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Cooldown</string>
					<string name="ScriptGuid">{ADEF35C6-9A87-4D6F-A4AE-0C47F2C10B73}</string>
					<ProtectedString name="Source"><![CDATA[export type Cooldown = {
	add: (any) -> void,
	has: (any) -> (boolean),
	remove: (any) -> void,
	removeAfter: (any, number) -> void,
}

local Cooldown: Cooldown = {}

function Cooldown.add(object: any)
	Cooldown[object] = true
end

function Cooldown.has(object: any): boolean
	return Cooldown[object] and true
end

function Cooldown.remove(object: any)
	Cooldown[object] = nil
end

function Cooldown.removeAfter(object: any, duration: number)
	Cooldown.add(object)
	task.delay(duration, Cooldown.remove, object)
end

return Cooldown
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a093</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX7e292a279a4144bc8372755e4bb27bcc">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Debris2</string>
					<string name="ScriptGuid">{82D11869-D5DD-4C8C-8591-9887A3654383}</string>
					<ProtectedString name="Source"><![CDATA[local Debris2 = {
	Instances = {},
}

local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat

local Instances = Debris2.Instances

local Connections = {}

local ValidTypes = {
	["Instance"] = "Destroy",
	["table"] = {},
	["RBXScriptConnection"] = "Disconnect",
}

local METHODS = {
	"Destroy",
	"Disconnect",
}

local function removeItem(typeOf: string, object: Instance)
	if typeOf == "Instance" then
		pcall(object.Destroy, object)
	elseif typeOf == "RBXScriptConnection" then
		pcall(object.Disconnect, object)
	else
		for _, v: string in ipairs(METHODS) do -- _, v: method name
			if object[v] then
				pcall(object[v], v)
				break
			end
		end
	end
end

local function addDebris(object: Instance, lifeTime: number)
	local typeOf = typeof(object)

	assert(ValidTypes[typeof(object)], "not valid type")
	assert(typeof(lifeTime) == "number", "lifeTime must be a number")

	if not Instances[object] then
		table.insert(Instances, object)
	end

	Instances[object] = {
		["lifeTime"] = lifeTime,
		removalTime = tick() + lifeTime,
		Cancel = function()
			Connections[object]:Disconnect()
			table.remove(Instances, table.find(Instances, object))
			Instances[object] = nil
		end,
		["Instance"] = object,
	}

	local debris = Instances[object]

	Connections[object] = Heartbeat:Connect(function()
		if debris and tick() >= debris.removalTime then
			if debris.Destroyed then
				debris.Destroyed()
			end
			debris.Cancel()
			removeItem(typeOf, object)
		end
		debris = Instances[object]
	end)

	return Instances[object]
end

function Debris2:AddItem(item, lifeTime: number)
	return addDebris(item, lifeTime)
end

function Debris2:AddItems(arrayOfItems: Array, lifeTime: number)
	for _, item in ipairs(arrayOfItems) do
		addDebris(item, lifeTime)
	end
end

function Debris2.GetAllDebris(): Instances
	return Instances
end

function Debris2.GetDebris(item)
	return Instances[item]
end

return Debris2
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a094</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX1f8785291f054b7fadd07d87ab8fe97d">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">JSON</string>
					<string name="ScriptGuid">{67B2FDCF-577F-4F22-8D3B-15E971CB0200}</string>
					<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

export type JSON = {
	Decode: (string: string) -> table,
	DeepCopy: (table: table) -> table,
	Encode: (table: table) -> string,
	Filter: (table: table, filterType: string, cache: table?) -> string,
	GenerateGUID: (wrapInCurlyBraces: boolean) -> string,
	Length: (table: table) -> integer,
	-- Repair: (dictionary: table) -> table,
	Valid: (table: table) -> (boolean, string?, string?),
}

local JSON = {}

function JSON.Decode(string: string): table
	return HttpService:JSONDecode(string)
end

function JSON.DeepCopy(table: table): table
	return JSON.Decode(JSON.Encode(table))
end

function JSON.Encode(table: table): string
	return HttpService:JSONEncode(table)
end

local Filters = require(script.Filters)
function JSON.Filter(table: table, filterType: string, cache: table?): table?
	cache = cache or {}
	local new = {}
	local filter = Filters[filterType]

	cache[table] = true

	for k, v in pairs(table) do
		if typeof(v) == "table" then
			if not cache[v] then
				new[k] = JSON.Filter(v, filterType, cache)
			else
				new[k] = "Cyclic Table: " .. tostring(v)
			end
		elseif filter[typeof(k)] and filter[typeof(v)] then
			new[k] = v
		end
	end

	cache[table] = nil

	return new
end

function JSON.GenerateGUID(wrapInCurlyBraces: boolean): string
	return HttpService:GenerateGUID(wrapInCurlyBraces)
end

function JSON.Length(table: table): integer
	return #JSON.Encode(table)
end

-- function JSON.Repair(dictionary: table): table
-- 	local isValid: boolean, path: Array, problem: string = JSON.Valid(dictionary)
-- 	if not isValid then
-- 		warn(problem, path)
-- 		local index = dictionary
-- 		for i: integer = 2, #path do
-- 			local key = path[i]
-- 			if i == #path then
-- 				index[key] = nil
-- 			else
-- 				index = index[key]
-- 			end
-- 		end
-- 		return JSON.Repair(dictionary)
-- 	end

-- 	return dictionary
-- end

local scanValidity = require(script.scanValidity)

function JSON.Valid(table: table): (boolean, Array?, string?)
	return scanValidity(table)
end

return JSON
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a095</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBXc9ebe1ab1c9643a7bf0b71675026941c">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Filters</string>
						<string name="ScriptGuid">{45ACCEA5-8EC0-4507-8842-CAA995564448}</string>
						<ProtectedString name="Source"><![CDATA[local Filters = {}

-- Filters.Type = {
-- 	Attribute = "Attribute",
--	Display = "Display",
-- 	JSON = "JSON",
-- 	-- Network = "Network",
-- }

Filters.Attribute = {
	[typeof(BrickColor.random())] = true,
	[typeof(Color3.new())] = true,
	[typeof(ColorSequence.new(Color3.new()))] = true,
	[typeof(NumberRange.new(0))] = true,
	[typeof(NumberSequence.new(0))] = true,
	[typeof(Rect.new(Vector2.new(), Vector2.new()))] = true,
	[typeof(UDim.new())] = true,
	[typeof(UDim2.new())] = true,
	[typeof(Vector2.new())] = true,
	[typeof(Vector3.new())] = true,

	[typeof(true)] = true,
	[typeof(3.142)] = true,
	[typeof("string")] = "true",
}

Filters.Display = {
	[typeof(BrickColor.random())] = true,
	[typeof(Color3.new())] = true,
	[typeof(ColorSequence.new(Color3.new()))] = true,
	[typeof(NumberRange.new(0))] = true,
	[typeof(NumberSequence.new(0))] = true,
	[typeof(Rect.new(Vector2.new(), Vector2.new()))] = true,
	[typeof(UDim.new())] = true,
	[typeof(UDim2.new())] = true,
	[typeof(Vector2.new())] = true,
	[typeof(Vector3.new())] = true,

	[typeof(true)] = true,
	[typeof(3.142)] = true,
	[typeof("string")] = "true",

	[typeof(CFrame.new())] = true,
	[typeof(Instance.new("Configuration"))] = true,
}

Filters.JSON = {
	[typeof(true)] = true,
	[typeof(3.142)] = true,
	[typeof("string")] = "true",
}

--[[

Filters.Network = { -- INCOMPLETE
	[typeof(BrickColor.random())] = true,
	[typeof(CFrame.new())] = true,
	[typeof(Color3.new())] = true,
	[typeof(ColorSequence.new(Color3.new()))] = true,
	[typeof(ColorSequence.new(Color3.new()))] = true,
	[typeof(Instance.new("Configuration"))] = true,
	[typeof(NumberRange.new(0))] = true,
	[typeof(NumberSequence.new(0))] = true,
	[typeof(Rect.new(Vector2.new(), Vector2.new()))] = true,
	[typeof(UDim.new())] = true,
	[typeof(UDim2.new())] = true,
	[typeof(Vector2.new())] = true,
	[typeof(Vector3.new())] = true,
	[typeof(true)] = true,
	[typeof(3.142)] = true,
	[typeof("string")] = "true",
}

]]

return Filters
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">1517939d06f7510002cb45270001a096</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX59cf825316004e1688f2dbcfe9700957">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">scanValidity</string>
						<string name="ScriptGuid">{97637477-AD93-416A-B8BE-5163AF37EB06}</string>
						<ProtectedString name="Source"><![CDATA[local function scanValidity(table: table, cache: table?, path: Array?): (boolean, Array?, string?)
	if type(table) ~= "table" then
		return scanValidity({ input = table }, {}, {})
	end
	cache, path = cache or {}, path or { "root" }
	cache[table] = true
	local tblType
	do
		local key = next(table)
		if type(key) == "number" then
			tblType = "Array"
		else
			tblType = "Dictionary"
		end
	end
	local last = 0
	for key, value in next, table do
		path[#path + 1] = tostring(key)
		if type(key) == "number" then
			if tblType == "Dictionary" then
				return false, path, "cannot store mixed tables"
			elseif key % 1 ~= 0 then
				return false, path, "cannot store tables with non-integer indices"
			elseif key == math.huge or key == -math.huge then
				return false, path, "cannot store tables with (-)infinity indices"
			end
		elseif type(key) ~= "string" then
			return false, path, "dictionaries cannot have keys of type " .. typeof(key)
		elseif tblType == "Array" then
			return false, path, "cannot store mixed tables"
		end
		if tblType == "Array" then
			if last ~= key - 1 then
				return false, path, "array has non-sequential indices"
			end
			last = key
		end
		if type(value) == "userdata" or type(value) == "function" or type(value) == "thread" then
			return false, path, "cannot store value '" .. tostring(value) .. "' of type " .. typeof(value)
		end
		if type(value) == "table" then
			if cache[value] then
				return false, path, "cannot store cyclic tables"
			end
			local isValid, keyPath, reason = scanValidity(value, cache, path)
			if not isValid then
				return isValid, keyPath, reason
			end
		end
		path[#path] = nil
	end
	cache[table] = nil
	return true
end

return scanValidity
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">1517939d06f7510002cb45270001a097</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXcbff43a42c1748e2bf8b8c89755c0ba7">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">MovementSpeed</string>
					<string name="ScriptGuid">{3550FA81-0C5A-4A2E-B70E-0C3440C41708}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Configurations = require(ReplicatedStorage.Configurations)

local MovementSpeed = {
	MovementBuff = 0,
	MovementDebuff = 0,
}

function MovementSpeed.calculateTotalMovementSpeed(): number
	return math.max(
		(Configurations.MovementSpeed.Hiders * (1 + MovementSpeed.MovementBuff)) * (1 - MovementSpeed.MovementDebuff),
		1
	)
end

return MovementSpeed
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a098</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX4e2ea03b582e481f8c958d810de05921">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TimeInSeconds</string>
					<string name="ScriptGuid">{4673E11E-2D83-4F3A-9EB9-3B45288BD3D8}</string>
					<ProtectedString name="Source"><![CDATA[local TimeInSeconds = {}

TimeInSeconds.Second = 1
TimeInSeconds.Minute = 60 * TimeInSeconds.Second
TimeInSeconds.Hour = 60 * TimeInSeconds.Minute
TimeInSeconds.Day = 24 * TimeInSeconds.Hour
TimeInSeconds.Week = 7 * TimeInSeconds.Day
TimeInSeconds.Month = 30 * TimeInSeconds.Day
TimeInSeconds.Year = 12 * TimeInSeconds.Month

return TimeInSeconds
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a099</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXe8b3dd1ac53d48559d3dc3957d7463c6">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Timer</string>
					<string name="ScriptGuid">{3BB02113-527F-45D6-9A92-2C171D375041}</string>
					<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat

local Timer = { IS_CYCLICAL = true }
Timer.__index = Timer

type timer = {
	Name: string,
	Duration: number,

	_Change: BindableEvent,
	Changed: RBXScriptSignal,

	_Stop: BindableEvent,
	Stopped: RBXScriptSignal,
}

function Timer.create(name: string, duration: number): timer
	local Change = Instance.new("BindableEvent")
	local Stop = Instance.new("BindableEvent")
	local timer = {
		Name = name,
		Duration = duration,

		_Change = Change,
		Changed = Change.Event,

		_Stop = Stop,
		Stopped = Stop.Event,

		USING_METATABLE = true,
		-- Metatable = Timer,
	}
	Timer[name] = timer
	return setmetatable(timer, Timer)
end

function Timer:Start()
	local timer = self
	if not timer.Heartbeat then
		timer.Heartbeat = Heartbeat:Connect(function(dt)
			timer.Duration -= dt
			if timer.Duration < 0 then
				timer:Destroy()
				return
			end
			timer._Change:Fire(timer.Duration)
		end)
	end
end

function Timer:Destroy()
	local timer = self
	if timer.Heartbeat then
		timer.Heartbeat:Disconnect()
		timer._Stop:Fire()
	end
	timer._Stop:Destroy()
	timer._Change:Destroy()
	Timer[timer.Name] = nil
end

return Timer
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a09a</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX1391a686ef0d4ad28db05a463ffd22d2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TypeChecks</string>
					<string name="ScriptGuid">{84DF1AA5-1027-4408-9E19-E35383B0E133}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local t = require(Utilities.t)

local TypeChecks = {
	Optional = {},
	Strict = {},
}

TypeChecks.Strict.String = t.strict(t.string)

TypeChecks.Strict.Number = t.strict(t.number)

--

TypeChecks.Strict.CFrame = t.strict(t.CFrame)

TypeChecks.Strict.Instance = t.strict(t.Instance)

TypeChecks.Strict.Vector3 = t.strict(t.Vector3)

--

TypeChecks.Animator = t.instanceIsA("Animator")
TypeChecks.Strict.Animator = t.strict(t.instanceIsA("Animator"))

TypeChecks.AnimationTrack = t.instanceIsA("AnimationTrack")
TypeChecks.Strict.AnimationTrack = t.strict(t.instanceIsA("AnimationTrack"))

TypeChecks.BasePart = t.instanceIsA("BasePart")
TypeChecks.Strict.BasePart = t.strict(t.instanceIsA("BasePart"))

TypeChecks.Humanoid = t.instanceIsA("Humanoid")
TypeChecks.Strict.Humanoid = t.strict(t.instanceIsA("Humanoid"))

TypeChecks.Player = t.union(t.instanceIsA("Player"), t.instanceIsA("Configuration"))
TypeChecks.Strict.Player = t.strict(t.union(t.instanceIsA("Player"), t.instanceIsA("Configuration")))

TypeChecks.ProximityPrompt = t.instanceIsA("ProximityPrompt")
TypeChecks.Strict.ProximityPrompt = t.strict(t.instanceIsA("ProximityPrompt"))

TypeChecks.Model = t.instanceIsA("Model")
TypeChecks.Strict.Model = t.strict(t.instanceIsA("Model"))

TypeChecks.Motor6D = t.instanceIsA("Motor6D")
TypeChecks.Strict.Motor6D = t.strict(t.instanceIsA("Motor6D"))

TypeChecks.Tool = t.instanceIsA("Tool")
TypeChecks.Strict.Tool = t.strict(t.instanceIsA("Tool"))

TypeChecks.WorldModel = t.instanceIsA("WorldModel")
TypeChecks.Strict.WorldModel = t.strict(t.instanceIsA("WorldModel"))

--

return TypeChecks
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a09b</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX1eae6e5d5fc94e16b22aa4d1e55cd270">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">array</string>
					<string name="ScriptGuid">{1902CE67-E50E-4CF9-96A5-02397C96128C}</string>
					<ProtectedString name="Source"><![CDATA[export type array = {
	combine: (...Array) -> Array,
	deepCopy: (Array) -> Array,
	deepCompare: (Array, Array) -> boolean,
	dequeue: (array: Array) -> (any?),
	enqueue: (array: Array, value: any?) -> void,
	findDuplicates: (array: Array) -> Array,
	findFirstDuliplicate: (Array) -> any?,
	isEmpty: (Array) -> boolean,
	JSONCompare: (Array, Array) -> boolean,
	JSONCopy: (Array) -> Array,
	pop: (array: Array) -> any?,
	push: (array: Array, value: any?) -> void,
	random: (Array) -> any?,
	randoms: (Array, integer) -> any?,
	remove: (Array) -> (any & number)?,
	removeRandom: (Array) -> any?,
	shalowCompare: (Array, Array) -> boolean,
	shalowCopy: (Array) -> Array,
}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local JSON = require(Utilities.JSON)

local Array = {}

function Array.combine(...): Array
	local combinedArray: Array = {}
	local index: integer = 1

	for listIndex = 1, select("#", ...) do
		local list: Array? = select(listIndex, ...)

		if list then
			for _, value: any in ipairs(list) do
				combinedArray[index] = value
				index += 1
			end
		end
	end

	return combinedArray
end

function Array.deepCopy(array: Array): Array
	local deepCopied = {}

	for i, v in ipairs(array) do
		if type(v) == "table" then
			deepCopied[i] = Array.deepCopy(v)
		else
			deepCopied[i] = v
		end
	end

	return deepCopied
end

function Array.enqueue(array: Array, value: any?)
	table.insert(array, 1, value)
end

function Array.dequeue(array: Array): any?
	return table.remove(array, #array)
end

function Array.findFirstDuliplicate(array: Array): any?
	table.sort(array)
	for i: integer, v: any in ipairs(array) do
		if table.find(array, v, i + 1) then
			return v
		end
	end
end

function Array.findDuplicates(array: Array): Array
	local duplicates: Array = {}

	table.sort(array)
	for i: integer, v: any in ipairs(array) do
		if table.find(array, v, i + 1) then
			table.insert(duplicates, v)
		end
	end

	return duplicates
end

function Array.isEmpty(array: Array): boolean
	return #array == 0
end

function Array.JSONCompare(array1: Array, array2: Array): boolean
	return JSON.Encode(array1) == JSON.Encode(array2)
end

function Array.JSONCopy(array: Array): Array
	return JSON.DeepCopy(array)
end

function Array.pop(array: Array): any?
	return table.remove(array, #array)
end

function Array.push(array: Array, value: any?)
	table.insert(array, #array + 1, value)
end

function Array.random(array: Array): any?
	if array and #array > 0 then
		return array[math.random(1, #array)]
	end
end

function Array.randoms(array: Array, entries: integer): any?
	local results = {}
	if array and #array > 0 then
		local deepCopy = Array.deepCopy(array)
		for _ = 1, entries do
			table.insert(results, Array.removeRandom(deepCopy))
		end
		return table.unpack(results)
	end
end

function Array.removeRandom(array: Array): any?
	local value: any = Array.random(array)
	local index: integer = table.find(array, value)
	return table.remove(array, index)
end

function Array.remove(array: Array, value: any?): (any & number)?
	local index: integer? = table.find(array, value)
	if index then
		return table.remove(array, index), index
	end
end

function Array.shallowCompare(array1: Array, array2: Array): boolean
	for i, v in ipairs(array1) do
		if array2[i] ~= v then
			return false
		end
	end
	return true
end

function Array.shalowCopy(array: Array): Array
	return table.pack(table.unpack(array))
end

function Array.clear(array: Array): Array
	for i = #array, 1, -1 do
		table.remove(array, i)
	end
	return array
end

return Array
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a09c</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX696fd2b3c8934fa5bd7cbed4d82def34">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">attributeUtil</string>
					<string name="ScriptGuid">{02F11512-33C3-4B17-9F89-6436623A256F}</string>
					<ProtectedString name="Source"><![CDATA[--| LICENSE: https://gist.github.com/RuizuKun-Dev/768981cc6d68f996a041a4fa1761ea02#file-license-txt

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local instanceUtil = require(Utilities.instanceUtil)
local JSON = require(Utilities.JSON)
local t = require(Utilities.t) -- github.com/osyrisrblx/t

local CollectionService = game:GetService("CollectionService")

export type attributeUtil = {
	ClearAllAttributes: (instance: Instance) -> void,
	FindFirstChildWithAttribute: (parent: Instance, attribute: string, recursive: boolean?) -> Instance?,
	GetAttribute: (instance: Instance, key: string) -> (any),
	GetAttributes: (instance: Instance) -> (Dictionary),
	GetChildrenWithAttribute: (Instance, string) -> Array<Instance>,
	GetDescendantsWithAttribute: (Instance, string) -> Array<Instance>,
	IsSpecialType: (value: any) -> (boolean),
	IsSupportedType: (value: any) -> (boolean),
	SetAttribute: (instance: Instance, key: string, value: any) -> void,
	SetAttributes: (instance: Instance, attributes: { [string]: any }) -> void,
	WaitForChildWithAttribute: (parent: Instance, attribute: string, timeOut: number?) -> Instance?,
}

local attributeUtil = {}

export type SUPPORTED_TYPES = {
	BrickColor: boolean,
	Color: boolean,
	ColorSequence: boolean,
	NumberRange: boolean,
	NumberSequence: boolean,
	Rect: boolean,
	UDim: boolean,
	UDim2: boolean,
	Vector2: boolean,
	Vector3: boolean,
	boolean: boolean,
	number: boolean,
	string: boolean,
}

local SUPPORTED_TYPES: SUPPORTED_TYPES = {
	[typeof(BrickColor.random())] = true,
	[typeof(Color3.new())] = true,
	[typeof(ColorSequence.new(Color3.new()))] = true,
	[typeof(NumberRange.new(0))] = true,
	[typeof(NumberSequence.new(0))] = true,
	[typeof(Rect.new(Vector2.new(), Vector2.new()))] = true,
	[typeof(UDim.new())] = true,
	[typeof(UDim2.new())] = true,
	[typeof(Vector2.new())] = true,
	[typeof(Vector3.new())] = true,
	[typeof(true)] = true,
	[typeof(3.142)] = true,
	[typeof("string")] = "true",
	[typeof(nil)] = true,
}

export type SPECIAL_TYPES = {
	CFrame: CFrame,
	Instance: Instance,
	table: table,
}

local SPECIAL_TYPES: SPECIAL_TYPES = {
	[typeof(CFrame.new())] = true,
	[typeof(Instance.new("Configuration"))] = true,
	[typeof(table)] = true,
}

function attributeUtil.IsSupportedType(value: any): boolean
	return SUPPORTED_TYPES[typeof(value)]
end
local IsSupportedType = attributeUtil.IsSupportedType

function attributeUtil.IsSpecialType(value: any): boolean
	return SPECIAL_TYPES[typeof(value)]
end
local IsSpecialType = attributeUtil.IsSpecialType

local ClearAllAttributes_Check = t.tuple(t.Instance)
function attributeUtil.ClearAllAttributes(instance: Instance)
	assert(ClearAllAttributes_Check(instance))

	for key: string, _ in pairs(instance:GetAttributes()) do
		if key ~= "GUID" then
			instance:SetAttribute(key, nil)
		end
	end
end

local FindFirstChildWithAttribute_Check = t.tuple(t.Instance, t.string, t.optional(t.boolean))
function attributeUtil.FindFirstChildWithAttribute(
	parent: Instance,
	attribute: string,
	recursive: boolean?
): Instance | nil
	assert(FindFirstChildWithAttribute_Check(parent, attribute, recursive))

	if recursive then
		for _, descendant: Instance in ipairs(parent:GetDescendants()) do
			if descendant:GetAttribute(attribute) then
				return descendant
			end
		end
	else
		for _, child: Instance in ipairs(parent:GetChildren()) do
			if child:GetAttribute(attribute) then
				return child
			end
		end
	end

	return nil
end

local Codec = {}

function Codec.Decode(value: string): CFrame | Instance | table
	local success, decoded = pcall(JSON.Decode, value)

	if success then
		if typeof(decoded) == "table" then
			if decoded[1] == "CFrame:" then
				return CFrame.new(table.unpack(decoded[2])) :: CFrame
			elseif decoded[1] == "Instance:" then
				return CollectionService:GetTagged(decoded[2])[1] :: Instance
			elseif (decoded[1]):sub(1, 6) == "Table:" then
				return decoded[2] :: table
			end
		end
	end
end

local GetAttribute_Check = t.tuple(t.Instance, t.string)
function attributeUtil.GetAttribute(instance: Instance, key: string): any
	assert(GetAttribute_Check(instance, key))

	local value = instance:GetAttribute(key)

	return Codec.Decode(value) or value
end
local GetAttribute = attributeUtil.GetAttribute

local GetAttributes_Check = t.tuple(t.Instance)
function attributeUtil.GetAttributes(instance: Instance): Dictionary
	assert(GetAttributes_Check(instance))

	local attributes = instance:GetAttributes()

	for key: string, value: any in pairs(attributes) do
		attributes[key] = Codec.Decode(value) or value
	end

	return attributes
end

function Codec.Encode(value: CFrame | Instance | table): string
	if typeof(value) == "CFrame" then
		local cframe: CFrame = value
		return JSON.Encode({ "CFrame:", { cframe:GetComponents() } })
	elseif typeof(value) == "Instance" then
		local instance = value
		return JSON.Encode({ "Instance:", instance:GetAttribute("GUID") })
	elseif typeof(value) == "table" then
		local table: table = value
		return JSON.Encode({ "Table:" .. string.sub(tostring(table), 7), JSON.Filter(table, "JSON") })
	end
end

local GetChildrenWithAttribute_Check = t.tuple(t.Instance, t.string)
function attributeUtil.GetChildrenWithAttribute(parent: Instance, attribute: string): Array
	assert(GetChildrenWithAttribute_Check(parent, attribute))

	local cache = {}
	for _, child: Instance in ipairs(parent:GetChildren()) do
		if GetAttribute(child, attribute) ~= nil then
			table.insert(cache, child)
		end
	end
	return cache
end

local GetDescendantsWithAttribute_Check = t.tuple(t.Instance, t.string)
function attributeUtil.GetDescendantsWithAttribute(ancestor: Instance, attribute: string): Array
	assert(GetDescendantsWithAttribute_Check(ancestor, attribute))

	local cache = {}
	for _, descendant: Instance in ipairs(ancestor:GetDescendants()) do
		if GetAttribute(descendant, attribute) ~= nil then
			table.insert(cache, descendant)
		end
	end
	return cache
end

local SetAttribute_Check = t.tuple(t.Instance, t.union(t.string, t.integer), t.optional(t.any))
function attributeUtil.SetAttribute(instance: Instance, key: string, value: any)
	assert(SetAttribute_Check(instance, key, value))

	key = string.gsub(tostring(key):gsub("%f[%w]%l", string.upper), "[^%w_]+", "")

	if IsSupportedType(value) then
		instance:SetAttribute(key, value)
	elseif IsSpecialType(value) then
		instance:SetAttribute(key, Codec.Encode(value))
	end
end
local SetAttribute = attributeUtil.SetAttribute

local SetAttributes_Check = t.tuple(t.Instance, t.table)
function attributeUtil.SetAttributes(instance: Instance, attributes: Dictionary)
	assert(SetAttributes_Check(instance, attributes))

	for key: string, value: any in pairs(attributes) do
		SetAttribute(instance, key, value)
	end
end

local WaitForChildWithAttribute_Check = t.tuple(t.Instance, t.string, t.optional(t.number))
function attributeUtil.WaitForChildWithAttribute(parent: Instance, attribute: string, timeOut: number?): Instance | nil
	assert(WaitForChildWithAttribute_Check(parent, attribute, timeOut))

	local START_TIME = os.clock()
	local YIELD_UNTIL = (timeOut and timeOut + START_TIME or math.huge)

	local function yieldTooLongWarning()
		local CURRENT_TIME = os.clock()
		if CURRENT_TIME - START_TIME >= 5 then
			warn("Infinite yield possible on WaitForChildWithAttribute:", parent.Name, attribute)
			yieldTooLongWarning = nil
		end
	end

	local CURRENT_TIME = os.clock()
	while YIELD_UNTIL >= CURRENT_TIME do
		for _, child: Instance in ipairs(parent:GetChildren()) do
			if child:GetAttribute(attribute) then
				return child
			end
		end
		if yieldTooLongWarning then
			yieldTooLongWarning()
		end
		task.wait()
		CURRENT_TIME = os.clock()
	end

	return nil
end

local Display_Check = t.tuple(t.Instance, t.table)
function attributeUtil.Display(instance: Instance, dictionary: Dictionary)
	assert(Display_Check(instance, dictionary))

	for key: string, value: any in pairs(JSON.Filter(dictionary, "Display")) do
		if typeof(key) == "number" or typeof(key) == "string" then
			if typeof(value) == "table" then
				local configuration = instance:FindFirstChild(key) or Instance.new("Folder")
				configuration.Name = key
				configuration.Parent = instance
				attributeUtil.Display(configuration, value)
			else
				SetAttribute(instance, key, value)
			end
		end
	end
end

do
	local cache = {}

	local function isClone(instance: Instance): boolean
		return not cache[instance] and instance:GetAttribute("GUID")
	end

	local function setGUID(instance: Instance)
		local GUID = JSON.GenerateGUID(false)
		if isClone(instance) then
			local guid = instance:GetAttribute("GUID")
			CollectionService:RemoveTag(instance, guid)
		end

		instance:SetAttribute("GUID", GUID)
		CollectionService:AddTag(instance, GUID)
		cache[instance] = GUID
	end

	instanceUtil.doForAllDescendantsOf(game, function(descendant: Instance)
		pcall(setGUID, descendant)
	end)
end

return attributeUtil
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a09d</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXbbaf699d7d8b458eba69fb6c98cc42cf">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">characterUtil</string>
					<string name="ScriptGuid">{B4E649B5-5336-4574-B7DB-7275FCA79BEC}</string>
					<ProtectedString name="Source"><![CDATA[local characterUtil = { script = script }

local Players = game:GetService("Players")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Network = require(ReplicatedStorage.Network)

local Configurations = require(ReplicatedStorage.Configurations)

local Utilities = ReplicatedStorage.Utilities
local Janitor = require(Utilities.Janitor)
local instanceUtil = require(Utilities.instanceUtil)
local playerUtil = require(Utilities.playerUtil)
local t = require(Utilities.t)
local TypeChecks = require(Utilities.TypeChecks)
local waitUntil = require(Utilities.waitUntil)

local connections = Janitor.new()

local RunService = game:GetService("RunService")

local QUICK_CHARACTER_LOADING = false

local function getHumanoidDescriptionFromUserId(player: Player): HumanoidDescription | boolean
	TypeChecks.Strict.Player(player)
	local success: boolean, result = pcall(Players.GetHumanoidDescriptionFromUserId, Players, player.UserId)
	if success then
		return result
	end
	return false
end

local function loadCharacterWithHumanoidDescription(player: Player): boolean
	TypeChecks.Strict.Player(player)
	local humanoidDescription = getHumanoidDescriptionFromUserId(player)
	if humanoidDescription then
		local sucess: boolean = pcall(player.LoadCharacterWithHumanoidDescription, player, humanoidDescription)
		return sucess
	end
	return false
end

local cache = {}
local function getCharacterAppearance(player: Player): Model | boolean
	TypeChecks.Strict.Player(player)
	if cache[player] then
		return cache[player]
	else
		local success, result = pcall(Players.GetCharacterAppearanceAsync, Players, player.UserId)
		if success then
			cache[player] = result
			return result
		end
		return false
	end
end

local function setCharacterAppearance(player: Player, characterAppearance: Model)
	local character: Model = player.Character
	local head: BasePart = character:WaitForChild("Head")
	local humanoid: Humanoid = character:WaitForChild("Humanoid")

	for _, v: Instance in ipairs(characterAppearance:GetChildren()) do
		if v.Name == "R15ArtistIntent" or v.Name == "R15" or v.Name == "R15Fixed" then
			local bodyparts = v
			for _, child: Instance in ipairs(bodyparts:GetChildren()) do
				local bodyPart: BasePart = character:FindFirstChild(child.Name)
				if bodyPart then
					humanoid:ReplaceBodyPartR15(humanoid:GetBodyPartR15(bodyPart), child)
				end
			end
		elseif v.Name == "R15Anim" then
			local animations = v
			for _, child: Instance in ipairs(animations:GetChildren()) do
				local animation: Animation = character.Animate:FindFirstChild(child.Name)
				if animation then
					animation:Destroy()
					child.Parent = character.Animate
				end
			end
		elseif v:IsA("Accessory") then
			humanoid:AddAccessory(v)
		elseif v:IsA("Decal") then
			local face: Decal = head:FindFirstChildOfClass("Decal")
			if face then
				face.Texture = v.Texture
			else
				v.Parent = head
			end
		elseif v:IsA("SpecialMesh") then
			v.Parent = head
		elseif v:IsA("CharacterAppearance") then
			v.Parent = character
		end
	end

	humanoid:BuildRigFromAttachments()
	characterAppearance:Destroy()
end

local function loadCharacterWithAppearance(player: Player)
	TypeChecks.Strict.Player(player)
	local characterAppearance = getCharacterAppearance(player)
	if characterAppearance then
		setCharacterAppearance(player, characterAppearance:Clone())
	end
end

function characterUtil.loadCharacter(player: Player): Model
	TypeChecks.Strict.Player(player)
	if QUICK_CHARACTER_LOADING and RunService:IsStudio() then
		pcall(player.LoadCharacter, player)
		warn("QUICK_CHARACTER_LOADING")
		return player.Character
	end

	if player:IsDescendantOf(Players) then
		if loadCharacterWithHumanoidDescription(player) then
			return player.Character
		elseif pcall(player.LoadCharacter, player) then
			loadCharacterWithAppearance(player)
		end
	end
	return player.Character
end

local MaterialWhitelist = {
	[Enum.Material.Neon] = true,
	[Enum.Material.ForceField] = true,
	[Enum.Material.Glass] = true,
}

local function isWhitelistMaterial(material: EnumItem): boolean
	return MaterialWhitelist[material]
end

local function setMaterial(basepart: BasePart, material: EnumItem)
	if not isWhitelistMaterial(basepart.Material) then
		basepart.Material = material
	end
end

function characterUtil.setCharacterMaterial(character: Model, material: EnumItem)
	for _, descendant: Instance in ipairs(character:GetDescendants()) do
		if descendant:IsA("BasePart") then
			local basePart: BasePart = descendant
			setMaterial(basePart, material)
		end
	end
end

function characterUtil.disableHumanoidStates(humanoid: Humanoid, states: EnumItem)
	if humanoid and humanoid:IsA("Humanoid") then
		for state: EnumItem, enable: boolean in pairs(states or Configurations.HUMANOID_STATES) do
			humanoid:SetStateEnabled(state, enable)
		end
	end
end

function characterUtil.setCharacterMassless(character: Model, bool: boolean)
	for _: ingeter, descendant: Instance in ipairs(character:GetDescendants()) do
		if descendant:IsA("BasePart") then
			local basePart: BasePart = descendant
			basePart.Massless = bool
		end
	end
end

function characterUtil.setCharacterShadow(character: Model, bool: boolean)
	for _, descendant: Instance in ipairs(character:GetDescendants()) do
		if descendant:IsA("BasePart") then
			local basePart: BasePart = descendant
			basePart.CastShadow = bool
		end
	end
end

function characterUtil.setCharacterTransparency(character: Model, transparency: number)
	for _, descendant: Instance in ipairs(character:GetDescendants()) do
		if descendant:IsA("BasePart") then
			local basePart: BasePart = descendant
			basePart.Transparency = transparency
		end
	end
end

function characterUtil.setAccessoryCollisionPhysics(humanoid: Humanoid, bool: boolean)
	for _, accessory: Accessory in ipairs(humanoid:GetAccessories()) do
		accessory.Handle.CanCollide = bool
		accessory.Handle.CanTouch = bool
		accessory.Handle.CanQuery = bool
	end
end

characterUtil.Default_ClassBlacklist = {
	"Beam",
	"Fire",
	"Light",
	"Model",
	"ParticleEmitter",
	"PointLight",
	"Smoke",
	"Sound",
	"Sparkles",
	"SpotLight",
	"Tool",
	"Trail",
}

function characterUtil.cloneCharacterWithFilter(character: Model, classBlacklist: Array<string>?): Model
	local clone: Model = character:Clone()
	instanceUtil.clearAllDescendantsOfClasses(clone, classBlacklist or characterUtil.Default_ClassBlacklist)

	instanceUtil.forEachDescendantsOfClassDo(clone, "BasePart", function(bodypart: BasePart)
		instanceUtil.setProperties(bodypart, {
			--📝 When an Instance is cloned all properties are copied including Velocity, so we must clear it
			Velocity = Vector3.new(0, 0, 0),
			Transparency = 0,
		})
		if bodypart.Name == "HumanoidRootPart" then
			bodypart.Transparency = 1
		end
	end)

	return clone
end

if RunService:IsClient() then
	local characterUtil_Remote = Network.get("characterUtil_Remote")

	function characterUtil.teleportCharacter(character: Model, cframe: CFrame)
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			character:SetAttribute("LastTeleportLocation", cframe.Position)
			character:SetPrimaryPartCFrame(cframe + Vector3.new(0, humanoid.hipHeight, 0))
			character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
		end
	end

	Network.handleClientEvents(characterUtil_Remote, {
		teleportCharacter = t.wrap(characterUtil.teleportCharacter, TypeChecks.Model, t.CFrame),
	})
elseif RunService:IsServer() then
	local characterUtil_Remote = Network.create("characterUtil_Remote")
	function characterUtil.teleportCharacter(character: Model, cframe: CFrame)
		local player = Players:GetPlayerFromCharacter(character)
		if player then
			characterUtil_Remote.FireClient(player, "teleportCharacter", character, cframe)
		end
	end
end

function characterUtil.isPlayerCharacter(player: Player, model: Model): boolean
	return model.Name == player.Name
end

local Characters = {}

local DEAD = Enum.HumanoidStateType.Dead

function characterUtil.handleCharacterAdded(player: Player, callback)
	table.insert(Characters[player].CharacterAdded, callback)

	if player.Character then
		if characterUtil.isPlayerCharacter(player, player.Character) then
			waitUntil(workspace).IsAncestorOf(player.Character)
			player.Character:WaitForChild("Humanoid")
			callback(player.Character)
		end
	end
end

function characterUtil.handleCharacterRemoving(player: Player, callback)
	table.insert(Characters[player].CharacterRemoving, callback)
end

function characterUtil.handleCharacterDied(player: Player, callback)
	table.insert(Characters[player].Died, callback)
end

playerUtil.handlePlayerAdded(function(player: Player)
	Characters[player] = {
		CharacterAdded = {},
		CharacterRemoving = {},
		Died = {},
	}

	local humanoid: Humanoid

	local function characterAdded(character: Model)
		if Characters[player] then
			if characterUtil.isPlayerCharacter(player, character) then
				waitUntil(workspace).IsAncestorOf(character)

				humanoid = character:WaitForChild("Humanoid")

				for _, callback in ipairs(Characters[player].CharacterAdded) do
					task.spawn(callback, character)
				end

				local function died()
					connections:Remove(humanoid)

					if Characters[player] then
						for _, callback in ipairs(Characters[player].Died) do
							task.spawn(callback, humanoid)
						end
					end
				end

				connections:Add(humanoid.Died:Connect(died), "Disconnect", humanoid)
			end
		end
	end

	task.spawn(characterAdded, player.Character or player.CharacterAdded:Wait())

	player.CharacterAdded:Connect(characterAdded)

	local function characterRemoving(character: Model)
		humanoid:SetStateEnabled(DEAD, true)
		humanoid:ChangeState(DEAD)

		if Characters[player] then
			for _, callback in ipairs(Characters[player].CharacterRemoving) do
				task.spawn(callback, character)
			end
		end
	end

	player.CharacterRemoving:Connect(characterRemoving)
end)

playerUtil.handlePlayerRemoving(t.wrap(function(player: Player)
	Characters[player] = nil
end, TypeChecks.Player))

return characterUtil
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a09e</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX6d546bacfa1a48818efb2cb6c6f33da2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">collisiongroupUtil</string>
					<string name="ScriptGuid">{DF615602-329D-4519-B3F2-B92BC2C55141}</string>
					<ProtectedString name="Source"><![CDATA[local collisiongroupUtil = {}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Configurations = require(ReplicatedStorage.Configurations)

local CollectionService = game:GetService("CollectionService")
local PhysicsService = game:GetService("PhysicsService")

local function setupCollisionGroups()
	for collisiongroupName: string, _ in pairs(Configurations.COLLISION_GROUPS) do
		PhysicsService:CreateCollisionGroup(collisiongroupName)
	end

	for collisiongroupName: string, collisiongroupData in pairs(Configurations.COLLISION_GROUPS) do
		for otherCollisiongroup, canCollide in pairs(collisiongroupData) do
			PhysicsService:CollisionGroupSetCollidable(collisiongroupName, otherCollisiongroup, canCollide)
		end
	end
end
setupCollisionGroups()

local function setCollisionGroup(BasePart: BasePart, CollisionGroupName: string)
	if BasePart:IsA("BasePart") then
		local previousCollisionGroup = PhysicsService:GetCollisionGroupName(BasePart.CollisionGroupId)
		CollectionService:RemoveTag(BasePart, previousCollisionGroup)
		PhysicsService:SetPartCollisionGroup(BasePart, CollisionGroupName)
		CollectionService:AddTag(BasePart, CollisionGroupName)
	end
end
collisiongroupUtil.setCollisionGroup = setCollisionGroup

function collisiongroupUtil.setAccessoriesCollisionGroup(humanoid: Humanoid, CollisionGroupName: string)
	for _, accessory: Accessory in ipairs(humanoid:GetAccessories()) do
		setCollisionGroup(accessory.Handle, CollisionGroupName)
	end
end

function collisiongroupUtil.setCharacterCollisionGroup(character: Model, CollisionGroupName: string)
	for _, descendants in ipairs(character:GetDescendants()) do
		setCollisionGroup(descendants, CollisionGroupName)
	end
end

return collisiongroupUtil
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a09f</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXf45a29b7ff1044ca9855bd0c8c7c0314">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">dictionary</string>
					<string name="ScriptGuid">{A97D9A75-F84B-4DB4-A9C9-A897DDC14AB4}</string>
					<ProtectedString name="Source"><![CDATA[export type Dictionary = { random: (Dictionary) -> any?, randoms: (Dictionary, integer) -> any? }

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local Array = require(Utilities.array)

local Dictionary: dictionary = {}

function Dictionary.convertToArrayWithKey(dictionary: Dictionary): Array
	local array = {}
	for k, _ in pairs(dictionary) do
		table.insert(array, k)
	end
	return array
end

function Dictionary.convertToArrayWithValue(dictionary: Dictionary): Array
	local array = {}
	for _, v in pairs(dictionary) do
		table.insert(array, v)
	end
	return array
end

function Dictionary.convertToArrayWithKeyValue(dictionary: Dictionary): Array
	local array = {}
	for k, v in pairs(dictionary) do
		table.insert(array, { k, v })
	end
	return array
end

function Dictionary.isEmpty(dictionary: Dictionary): boolean
	return next(dictionary) == nil
end

function Dictionary.randomValue(dictionary: Dictionary): any?
	local array = Dictionary.convertToArrayWithKey(dictionary)

	return dictionary[Array.random(array)]
end

function Dictionary.randomKeys(dictionary: Dictionary, entries: integer): any?
	local array = Dictionary.convertToArrayWithKey(dictionary)

	return Array.randoms(array, entries)
end

function Dictionary.clear(dictionary: Dictionary): Dictionary
	for k, _ in pairs(dictionary) do
		if typeof(k) ~= "number" then
			dictionary[k] = nil
		end
	end
	return dictionary
end

return Dictionary
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0a0</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX255c6f8a91884891a064c050824a7d45">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">guiUtil</string>
					<string name="ScriptGuid">{28B9EDAA-CF62-4B8F-AE2B-6B67CA438462}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local instanceUtil = require(Utilities.instanceUtil)

local guiUtil = {}

guiUtil.AnchorPoint = require(script.AnchorPoint)

guiUtil.Position = require(script.Position)

guiUtil.Size = require(script.Size)

guiUtil.Transparency = require(script.Transparency)

guiUtil.registerUI = require(script.registerUI)

guiUtil.createUI = instanceUtil.create

function guiUtil.setProperties(instance: Instance, properties)
	for property: string, value: any in pairs(properties) do
		instance[property] = value
	end
end

function guiUtil.updateCanvasSize(scrollingFrame: ScrollingFrame)
	local UIGridStyleLayout: UIGridStyleLayout = scrollingFrame:FindFirstChildWhichIsA("UIGridStyleLayout")
	scrollingFrame.CanvasSize = UDim2.fromOffset(0, UIGridStyleLayout.AbsoluteContentSize.Y)
	UIGridStyleLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
		scrollingFrame.CanvasSize = UDim2.fromOffset(0, UIGridStyleLayout.AbsoluteContentSize.Y)
	end)
end

return guiUtil
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0a1</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX98266ae5c81c424b9a708230255ffa1b">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AnchorPoint</string>
						<string name="ScriptGuid">{E6E1456E-AC32-4C08-ABD1-7D8E7969921C}</string>
						<ProtectedString name="Source"><![CDATA[local AnchorPoint = {
	Top_Left = Vector2.new(0, 0),
	Top = Vector2.new(0.5, 0),
	Top_Right = Vector2.new(1, 0),

	Left = Vector2.new(0, 0.5),

	Center = Vector2.new(0.5, 0.5),

	Right = Vector2.new(1, 0.5),

	Bottom_Left = Vector2.new(0, 1),
	Bottom = Vector2.new(0.5, 1),
	Bottom_Right = Vector2.new(1, 1),
}

return AnchorPoint
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0a2</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8f645c6e647543fbbf1642dfa86ea5cf">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Position</string>
						<string name="ScriptGuid">{9EADA2AF-88C9-4FF0-ACBD-AF96396666BB}</string>
						<ProtectedString name="Source"><![CDATA[local Position = {
	Top_Left = UDim2.fromScale(0, 0),
	Top = UDim2.fromScale(0.5, 0),
	Top_Right = UDim2.fromScale(1, 0),

	Left = UDim2.fromScale(0, 0.5),

	Center = UDim2.fromScale(0.5, 0.5),

	Right = UDim2.fromScale(1, 0.5),

	Bottom_Left = UDim2.fromScale(0, 1),
	Bottom = UDim2.fromScale(0.5, 1),
	Bottom_Right = UDim2.fromScale(1, 1),
}

return Position
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0a3</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3e1e93da0ba543e799a50cede9b3a46a">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Size</string>
						<string name="ScriptGuid">{5A812946-3991-451E-AA27-ADBE92E76A38}</string>
						<ProtectedString name="Source"><![CDATA[local Size = {
	Full = UDim2.fromScale(1, 1),
	Half = UDim2.fromScale(0.5, 0.5),
	Quarter = UDim2.fromScale(0.25, 0.25),

	One_Thrid = UDim2.fromScale(0.33, 0.33),
	One_Forth = UDim2.fromScale(0.25, 0.25),
	One_Fifth = UDim2.fromScale(0.2, 0.2),
	One_Eight = UDim2.fromScale(0.125, 0.125),
}

return Size
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0a4</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX78eed3776179459c98ad593e05fad533">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Transparency</string>
						<string name="ScriptGuid">{1A4FAB1A-1D1A-4B6A-8C45-91C426C3F889}</string>
						<ProtectedString name="Source"><![CDATA[local Transparency = {
	Transparent = 1,
	Semi_Transparent = 0.5,
	Semi_Opaque = 0.5,
	Opaque = 0,
}

return Transparency
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0a5</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXe8eeecbf38514fa0a174e8c1fef8fb21">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">registerUI</string>
						<string name="ScriptGuid">{5C477347-B01E-4B86-8B47-4E6396D66CA5}</string>
						<ProtectedString name="Source"><![CDATA[local SoundService = game:GetService("SoundService")
local SoundSystem = require(SoundService.SoundSystem)

local TweenService = game:GetService("TweenService")

local CustomUIHandler = require(script.CustomUIHandler)

local registerUI = {}

local function setPositionAttribute(ui: GuiObject)
	if not ui:GetAttribute("Position") then
		ui.Visible = true
		ui:SetAttribute("Position", ui.Position)
		ui.Position = UDim2.fromScale(0.5, -1)
	end
end

local currentMenuFrame

function registerUI.showUI(ui: GuiObject)
	setPositionAttribute(ui)
	ui.Visible = true
	ui:TweenPosition(ui:GetAttribute("Position"), "Out", "Back", 0.5, true)
	currentMenuFrame = ui
end

function registerUI.hideUI(ui: GuiObject)
	setPositionAttribute(ui)
	ui:TweenPosition(UDim2.fromScale(0.5, -1), "In", "Quad", 0.25, true)
	currentMenuFrame = nil
end

function registerUI.WithMenuButton(menu: GuiObject, button: GuiButton)
	setPositionAttribute(menu)

	local Events = CustomUIHandler.create(button)

	Events.UIPress:Connect(function()
		if currentMenuFrame ~= menu then
			SoundSystem.PlaySFX("Bubble Click", button)

			registerUI.hideUI(currentMenuFrame or menu)
			registerUI.showUI(menu)
		elseif currentMenuFrame == menu then
			SoundSystem.PlaySFX("Click Swoosh", button)

			registerUI.hideUI(menu)
		end
	end)
end

function registerUI.WithMenuCloseButton(menu: GuiObject, closeButton: GuiButton)
	setPositionAttribute(menu)

	local Events = CustomUIHandler.create(closeButton)

	Events.UIPress:Connect(function()
		SoundSystem.PlaySFX("Button Click", closeButton)
		menu.Visible = false
		registerUI.hideUI(menu)
	end)

	if closeButton:IsA("ImageButton") then
		Events.UIHoverEnter:Connect(function()
			closeButton.ImageTransparency = 0
		end)

		Events.UIHoverLeave:Connect(function()
			closeButton.ImageTransparency = 0.5
		end)
	end
end

local Sine = Enum.EasingStyle.Sine

local In = Enum.EasingDirection.In
local Out = Enum.EasingDirection.Out

local hoverIn = TweenInfo.new(0.1, Sine, Out)
local hoverOut = TweenInfo.new(0.05, Sine, In)

function registerUI.WithUIScale(ui: GuiObject, uiScale: UIScale, Scales: { [string]: number })
	local tweenHoverEnter = TweenService:Create(uiScale, hoverIn, { Scale = Scales.HoverEnter })
	local tweenHoverLeave = TweenService:Create(uiScale, hoverOut, { Scale = Scales.HoverLeave })
	local tweenPress = TweenService:Create(uiScale, hoverOut, { Scale = Scales.HoverLeave * 0.85 })
	local tweenRelease = TweenService:Create(uiScale, hoverIn, { Scale = Scales.HoverEnter * 0.95 })

	local Events = CustomUIHandler.create(ui)

	Events.UIHoverEnter:Connect(function()
		SoundSystem.PlaySFX("Info Click", ui)
		tweenHoverEnter:Play()
	end)

	Events.UIHoverLeave:Connect(function()
		tweenHoverLeave:Play()
	end)

	Events.UIPress:Connect(function()
		tweenPress:Play()
	end)

	Events.UIRelease:Connect(function()
		tweenRelease:Play()
	end)

	uiScale.Scale = Scales.HoverLeave
end

function registerUI.WithHoverEnterUIEvent(ui: GuiObject, callback): Connection
	local Events = CustomUIHandler.create(ui)

	return Events.UIHoverEnter:Connect(callback)
end

function registerUI.WithHoverLeaveUIEvent(ui: GuiObject, callback): Connection
	local Events = CustomUIHandler.create(ui)

	return Events.UIHoverLeave:Connect(callback)
end

function registerUI.WithPressUIEvent(ui: GuiObject, callback): Connection
	local Events = CustomUIHandler.create(ui)

	return Events.UIPress:Connect(callback)
end

function registerUI.WithReleaseUIEvent(ui: GuiObject, callback): Connection
	local Events = CustomUIHandler.create(ui)

	return Events.UIRelease:Connect(callback)
end

return registerUI
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0a6</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBXd1b1b33b0b1e4841844d24c810b954e2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CustomUIHandler</string>
							<string name="ScriptGuid">{41AAD315-EF44-46EF-AA4A-2F555B408221}</string>
							<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local playerGui = localPlayer.PlayerGui
local mouse = localPlayer:GetMouse()

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local array = require(Utilities.array)
local Janitor = require(Utilities.Janitor)
local connections = Janitor.new()
local Signals = require(Utilities.Signals)

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local CustomUIHandler = {
	Enabled = not RunService:IsStudio(),
	_GUIsAtMouse = {},
	IS_CYCLICAL = true,
}
CustomUIHandler.__index = CustomUIHandler

local UIList = {}
local UIMap = {}

export type CustomUIObject = {
	IsPress: boolean,

	IsHovering: boolean,
	WasHovering: boolean,

	Disable: () -> void,
	Enable: () -> void,

	UIHoverEnter: Signal,
	UIHoverLeave: Signal,
	UIPress: Signal,
	UIRelease: Signal,
}

function CustomUIHandler.create(ui: GuiObject): CustomUIObject
	if not UIMap[ui] then
		local customUIObject = setmetatable({
			Instance = ui,

			UIPress = Signals.create(),
			UIRelease = Signals.create(),

			UIHoverEnter = Signals.create(),
			UIHoverLeave = Signals.create(),

			USING_METATABLE = true,
			--Metatable = UIHover,
		}, CustomUIHandler)

		ui.Destroying:Connect(function()
			if UIMap[ui] then
				UIMap[ui] = nil
				array.remove(UIList, customUIObject)
			end
		end)

		UIMap[ui] = customUIObject

		table.insert(UIList, customUIObject)
	end

	return UIMap[ui]
end

function CustomUIHandler.get(ui: GuiObject): CustomUIObject
	return UIMap[ui]
end

function CustomUIHandler:Enable()
	self.Instance.Active = true
end

function CustomUIHandler:Disable()
	self.Instance.Active = false
end

function CustomUIHandler:_IsOnUI(): boolean
	local ui = self.Instance
	if table.find(CustomUIHandler._GUIsAtMouse, ui) then
		return true
	end
	return false
end

function CustomUIHandler:_UpdateUIHoverEnter()
	local customUIObject = self
	if customUIObject.IsHovering and not customUIObject.WasHovering then
		customUIObject.WasHovering = true
		customUIObject.UIHoverEnter:Fire(customUIObject.Instance :: GuiObject)

		-- print("UIHoverEnter", customUIObject.Instance)
	end
end

function CustomUIHandler:_UpdateUIHoverLeave()
	local customUIObject = self
	if not customUIObject.IsHovering and customUIObject.WasHovering then
		customUIObject.WasHovering = false

		customUIObject:_UpdateUIRelease()

		customUIObject.UIHoverLeave:Fire(customUIObject.Instance :: GuiObject)

		-- print("UIHoverLeave", customUIObject.Instance)
	end
end

function CustomUIHandler:_UpdateUIHover()
	local customUIObject = self
	customUIObject.IsHovering = customUIObject:_IsOnUI()

	customUIObject:_UpdateUIHoverLeave()

	-- print("UpdateUIHover", customUIObject.Instance)
end

function CustomUIHandler:_UpdateUIPress()
	local customUIObject = self
	if customUIObject.IsHovering and not customUIObject.IsPress then
		customUIObject.IsPress = true
		customUIObject.UIPress:Fire(customUIObject.Instance :: GuiObject)

		-- print("UIPress", customUIObject.Instance)
	end
end

function CustomUIHandler:_UpdateUIRelease()
	local customUIObject = self
	if customUIObject.IsPress then
		customUIObject.IsPress = false
		customUIObject.UIRelease:Fire(customUIObject.Instance :: GuiObject)

		-- print("UIRelease", customUIObject.Instance)
	end
end

local MOUSEBUTTON1 = Enum.UserInputType.MouseButton1

local function listenForMouse1Down()
	connections:Add(
		UserInputService.InputBegan:Connect(function(input: InputObject, gameProcessed: boolean)
			if gameProcessed then
				if input.UserInputType == MOUSEBUTTON1 then
					for _, ui: GuiObject in ipairs(CustomUIHandler._GUIsAtMouse) do
						local customUIObject: CustomUIObject = CustomUIHandler.get(ui)
						if customUIObject then
							customUIObject:_UpdateUIPress()
							break
						end
					end
				end
			end
		end),
		"Disconnect"
	)
end

local function listenForMouse1Up()
	connections:Add(
		UserInputService.InputEnded:Connect(function(input: InputObject)
			if input.UserInputType == MOUSEBUTTON1 then
				for _, customUIObject: CustomUIObject in ipairs(UIList) do
					customUIObject:_UpdateUIRelease()
				end
			end
		end),
		"Disconnect"
	)
end

local function bindUpdateMouseStateToRenderStep()
	RunService:BindToRenderStep("Update MouseState", Enum.RenderPriority.First.Value, function()
		if CustomUIHandler.Enabled then
			CustomUIHandler._GUIsAtMouse = playerGui:GetGuiObjectsAtPosition(mouse.X, mouse.Y)
			for _, customUIObject: CustomUIObject in ipairs(UIList) do
				customUIObject:_UpdateUIHover()
			end

			for _, ui: GuiObject in ipairs(CustomUIHandler._GUIsAtMouse) do
				local customUIObject: CustomUIObject = CustomUIHandler.get(ui)
				if customUIObject then
					customUIObject:_UpdateUIHoverEnter()
					break
				end
			end
		end
	end)
end

local function listenForMouseInputs()
	if UserInputService.MouseEnabled then
		listenForMouse1Down()

		listenForMouse1Up()

		bindUpdateMouseStateToRenderStep()
	end
end

local TOUCH = Enum.UserInputType.Touch

local function listenForTouchStarted()
	connections:Add(
		UserInputService.TouchStarted:Connect(function(input: InputObject, gameProcessed: boolean)
			if gameProcessed then
				if input.UserInputType == TOUCH then
					CustomUIHandler._GUIsAtMouse = playerGui:GetGuiObjectsAtPosition(input.Position.X, input.Position.Y)
					for _, customUIObject: CustomUIObject in ipairs(UIList) do
						customUIObject:_UpdateUIHover()
					end

					for _, ui: GuiObject in ipairs(CustomUIHandler._GUIsAtMouse) do
						local customUIObject: CustomUIObject = CustomUIHandler.get(ui)
						if customUIObject then
							customUIObject:_UpdateUIHoverEnter()
							customUIObject:_UpdateUIPress()
							break
						end
					end
				end
			end
		end),
		"Disconnect"
	)
end

local function listenForTouchMoved()
	connections:Add(
		UserInputService.TouchMoved:Connect(function(input: InputObject)
			if input.UserInputType == TOUCH then
				CustomUIHandler._GUIsAtMouse = playerGui:GetGuiObjectsAtPosition(input.Position.X, input.Position.Y)
				for _, customUIObject: CustomUIObject in ipairs(UIList) do
					customUIObject:_UpdateUIHover()
				end

				for _, ui: GuiObject in ipairs(CustomUIHandler._GUIsAtMouse) do
					local customUIObject: CustomUIObject = CustomUIHandler.get(ui)
					if customUIObject then
						customUIObject:_UpdateUIHoverEnter()
						break
					end
				end
			end
		end),
		"Disconnect"
	)
end

local function listenForTouchEnded()
	connections:Add(
		UserInputService.TouchEnded:Connect(function(input: InputObject)
			if input.UserInputType == TOUCH then
				CustomUIHandler._GUIsAtMouse = {}
				for _, customUIObject: CustomUIObject in ipairs(UIList) do
					customUIObject:_UpdateUIHover()
				end
			end
		end),
		"Disconnect"
	)
end

local function listenForTouchInputs()
	if UserInputService.TouchEnabled then
		listenForTouchStarted()

		listenForTouchMoved()

		listenForTouchEnded()
	end
end

local function listenforInputs()
	listenForTouchInputs()
	listenForMouseInputs()
end

function CustomUIHandler.DisableInputs()
	CustomUIHandler.Enabled = false
	connections:Destroy()
	connections = Janitor.new()
	RunService:UnbindFromRenderStep("UpdateMouseState")
end

function CustomUIHandler.EnableInputs()
	CustomUIHandler.Enabled = true
	listenforInputs()
end
CustomUIHandler.EnableInputs()

return CustomUIHandler
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0a7</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXa07eb92a082e48cd97f9a5ca919390c4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">instanceUtil</string>
					<string name="ScriptGuid">{BD0C697E-07FA-4339-8881-6D75901E680E}</string>
					<ProtectedString name="Source"><![CDATA[type Properties = { [string]: any }

export type InstanceUtil = {
	create: (className: string, properties: Properties, parent: Instance?) -> (Instance),
	setProperties: (instance: Instance, properties: Properties) -> (Instance),
	clearAllDescendantsOfClass: (ancestor: Instance, className: string) -> void,
	clearAllDescendantsOfClasses: (ancestor: Instance, classNames: Array<string>) -> void,
	doForAllDescendantsOf: (ancestor: Instance, callback: (Instance) -> void) -> void,
	forEachDescendantsOfClassDo: (ancestor: Instance, className: string, callback: (Instance) -> void) -> void,
	getAllDescendantsOfClass: (ancestor: Instance, className: string) -> (Array<Instance>),
}

--[[
	@class instanceUtil

	Utility functions for creating and setting properties on instances.
]]
local instanceUtil = {}

--[=[
    Sets the properties of an instance.

    @within instanceUtil
    @param instance Instance -- The instance you wanna set properties on
    @param properties Properties -- The properties you wanna set on the instance
]=]
function instanceUtil.setProperties(instance: Instance, properties: Properties, parent: Instance?)
	for property: string, value: any in pairs(properties) do
		instance[property] = value
	end

	if parent then
		instance.Parent = parent
	end
end

--[=[
    Creates an instance.

    @within instanceUtil
    @param className: string -- The name of the class you wanna create
    @param properties Properties -- The properties you wanna set on the instance
	@param parent Instance? -- The parent of the instance you wanna create
	@param instance Instance -- The instance you wanna create
]=]
function instanceUtil.create(className: string, properties: Properties, parent: Instance?): Instance
	local instance = Instance.new(className)

	instanceUtil.setProperties(instance, properties)

	instance.Parent = parent

	return instance
end

function instanceUtil.clearAllDescendantsOfClass(ancestor: Instance, className: string)
	for _, descendant: Instance in ipairs(ancestor:GetDescendants()) do
		if descendant:IsA(className) then
			descendant:Destroy()
		end
	end
end

function instanceUtil.clearAllDescendantsOfClasses(ancestor: Instance, classNames: Array<string>)
	for _, className: string in ipairs(classNames) do
		instanceUtil.clearAllDescendantsOfClass(ancestor, className)
	end
end

function instanceUtil.doForAllDescendantsOf(ancestor: Instance, callback: (Instance) -> void)
	for _, descendant: Instance in ipairs(ancestor:GetDescendants()) do
		task.spawn(callback, descendant)
	end

	ancestor.DescendantAdded:Connect(function(descendant: Instance)
		callback(descendant)
	end)
end

function instanceUtil.forEachDescendantsOfClassDo(ancestor: Instance, className: string, callback: (Instance) -> void)
	for _, descendant: Instance in ipairs(ancestor:GetDescendants()) do
		if descendant:IsA(className) then
			task.spawn(callback, descendant)
		end
	end
end

function instanceUtil.getAllDescendantsOfClass(ancestor: Instance, className: string): Array<Instance>
	local descendants = {}
	for _, descendant: Instance in ipairs(ancestor:GetDescendants()) do
		if descendant:IsA(className) then
			table.insert(descendants, descendant)
		end
	end
	return descendants
end

return instanceUtil
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0a8</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXc15ec54b0a5843cc94cce745b852d9c1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">marketplaceUtil</string>
					<string name="ScriptGuid">{CB71D37C-41E7-4838-9526-B21A1FD047B6}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local BackUp = require(ReplicatedStorage.Backup)

local Utilities = ReplicatedStorage.Utilities
local Promise = require(Utilities.Promise)

local MarketplaceService = game:GetService("MarketplaceService")

local marketplaceUtil = {}

marketplaceUtil.getProductInfo = Promise.promisify(function(assetId: number, infoType: EnumItem)
	local productInfo = BackUp.getProductInfo(assetId, infoType)
	if not productInfo then
		return MarketplaceService:GetProductInfo(assetId, infoType)
	end
	return productInfo
end)

return marketplaceUtil
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0a9</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXc23f37a103d94203b17fb8757ffb59cf">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">playerUtil</string>
					<string name="ScriptGuid">{4BE95C06-5633-48F2-9E54-F58471FD3038}</string>
					<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local TypeChecks = require(Utilities.TypeChecks)

local CollectionService = game:GetService("CollectionService")

local playerUtil = { PlayerAdded = {}, PlayerRemoving = {}, TeamChanged = {}, script = script }

function playerUtil.freezeHumanoid(humanoid: Humanoid)
	TypeChecks.Strict.Humanoid(humanoid)

	local walkspeed = humanoid.WalkSpeed
	local jumppower = humanoid.JumpPower
	humanoid.WalkSpeed = 0
	humanoid.JumpPower = 0
	return function()
		humanoid.WalkSpeed = walkspeed
		humanoid.JumpPower = jumppower
	end
end

function playerUtil.getPlayerFromPart(basepart: BasePart): Player?
	TypeChecks.Strict.BasePart(basepart)

	local character: Model = basepart:FindFirstAncestorOfClass("Model")
	local player: Player = character
		and (
			Players:GetPlayerFromCharacter(character)
			or CollectionService:GetTagged(character:GetAttribute("Player") or "")[1]
		)
	return player
end

function playerUtil.getPlayerFromHumanoid(humanoid: Humanoid): Player?
	TypeChecks.Strict.Humanoid(humanoid)
	local player: Player = Players:GetPlayerFromCharacter(humanoid:FindFirstAncestorOfClass("Model"))
	return player
end

local function getCharacterFromPart(basepart: BasePart): Model?
	TypeChecks.Strict.BasePart(basepart)

	local player: Player = playerUtil.getPlayerFromPart(basepart)
	local character: Model = player and player.Character
	return character
end
playerUtil.getCharacterFromPart = getCharacterFromPart

function playerUtil.getHumanoidFromPart(basepart: BasePart): Humanoid?
	TypeChecks.Strict.BasePart(basepart)

	local character: Model = getCharacterFromPart(basepart)
	local humanoid: Humanoid = character and character:FindFirstChildOfClass("Humanoid")
	return humanoid
end

function playerUtil.getPlayerInfoFromPart(basepart: BasePart): PlayerInfo
	TypeChecks.Strict.BasePart(basepart)

	local character: Model = basepart:FindFirstAncestorOfClass("Model")
	local player: Player = character
		and (
			Players:GetPlayerFromCharacter(character)
			or CollectionService:GetTagged(character:GetAttribute("Player") or "")[1]
		)
	local humanoid: Humanoid = character and character:FindFirstChildOfClass("Humanoid")
	local rootpart: BasePart = humanoid and humanoid.RootPart
	return {
		Player = player,
		Character = character,
		Humanoid = humanoid,
		Head = character.Head,
		RootPart = rootpart,
		HumanoidRootPart = rootpart,
	}
end

export type PlayerInfo = {
	Player: Player,
	Character: Model,
	Humanoid: Humanoid,
	Head: BasePart,
	RootPart: BasePart,
	HumanoidRootPart: BasePart,
}

function playerUtil.getPlayerInfo(player: Player): PlayerInfo
	TypeChecks.Strict.Player(player)

	local character: Model = player:IsA("Player") and player.Character
		or CollectionService:GetTagged(player:GetAttribute("Character") or "")[1]
	local humanoid: Humanoid = character and character:FindFirstChildOfClass("Humanoid")
	local rootpart: BasePart = humanoid and humanoid.RootPart
	return {
		Player = player,
		Character = character,
		Humanoid = humanoid,
		Head = character.Head,
		RootPart = rootpart,
		HumanoidRootPart = rootpart,
	}
end

function playerUtil.getHumanoidOfPlayer(player: Player): Humanoid?
	TypeChecks.Strict.Player(player)

	return player.Character and player.Character:FindFirstChildOfClass("Humanoid")
end

function playerUtil.isHumanoidAlive(humanoid: Humanoid): boolean
	TypeChecks.Strict.Humanoid(humanoid)

	return humanoid.Health > 0
end

local DEAD = Enum.HumanoidStateType.Dead

function playerUtil.killHumanoid(humanoid: Humanoid)
	TypeChecks.Strict.Humanoid(humanoid)

	humanoid:SetStateEnabled(DEAD, true)
	humanoid:ChangeState(DEAD)
	humanoid.Health = 0
end

function playerUtil.isValidCharacter(character: Model): boolean
	TypeChecks.Strict.Model(character)

	return character and character:FindFirstChildOfClass("Humanoid") and character.Humanoid.RootPart and true
end

function playerUtil.validateTarget(targetInfo): boolean?
	if targetInfo then
		local player: Player = targetInfo.Player
		local character: Model = targetInfo.Character
		local humanoid: Humanoid = targetInfo.Humanoid

		if player and character and humanoid then
			if player:IsA("Player") and player.Character == character then
				if playerUtil.getHumanoidOfPlayer(player) == humanoid then
					return humanoid.Health > 0
				end
			elseif player:IsA("Configuration") then
				return humanoid.Health > 0
			end
		end
	end
end

function playerUtil.getPlayerFromHumanoid(humanoid: Humanoid): Player
	TypeChecks.Strict.Humanoid(humanoid)
	local character: Model = humanoid:FindFirstAncestorOfClass("Model")
	local player: Player = Players:GetPlayerFromCharacter(character)
	return player
end

function playerUtil.handlePlayerAdded(callback)
	table.insert(playerUtil.PlayerAdded, callback)

	for _, player: Player in ipairs(Players:GetPlayers()) do
		task.spawn(callback, player)
	end
end

Players.PlayerAdded:Connect(function(player: Player)
	for _, callback in ipairs(playerUtil.PlayerAdded) do
		task.spawn(callback, player)
	end
end)

function playerUtil.handlePlayerRemoving(callback)
	table.insert(playerUtil.PlayerRemoving, callback)
end

Players.PlayerRemoving:Connect(function(player: Player)
	for _, callback in ipairs(playerUtil.PlayerRemoving) do
		task.spawn(callback, player)
	end
end)

if localPlayer then
	function playerUtil.isLocalPlayer(player: Player): boolean
		return player == localPlayer
	end

	function playerUtil.handleTeamChanged(callback)
		table.insert(playerUtil.TeamChanged, callback)

		for _, player: Player in ipairs(Players:GetPlayers()) do
			task.spawn(callback, player)
		end
	end

	localPlayer:GetPropertyChangedSignal("Team"):Connect(function()
		for _, callback in ipairs(playerUtil.TeamChanged) do
			task.spawn(callback)
		end
	end)
end

return playerUtil
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0aa</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXfb378c7046194439bc487be1f8f9ef9f">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">playfabUtil</string>
					<string name="ScriptGuid">{7C76969F-78F3-42A3-A2AC-A32B685EDB1C}</string>
					<ProtectedString name="Source"><![CDATA[local AnalyticsService = game:GetService("AnalyticsService")

-- local RunService = game:GetService("RunService")
local DISABLE_ANALYTICS = true
local IsStudio = DISABLE_ANALYTICS --RunService:IsStudio()

local playfabUtil = {}

export type ProgressionInfo = {
	Player: Player,
	Category: string,
	ProgressionStatus: EnumItem,
	Location: Dictionary,
	Statistics: Dictionary?,
	CustomData: (number | string | table)?,
}

-- playfabUtil.ProgressionInfo = {}

function playfabUtil.Progression(progressionInfo)
	if not IsStudio then
		AnalyticsService:FirePlayerProgressionEvent(
			progressionInfo.Player,
			progressionInfo.Category,
			progressionInfo.ProgressionStatus,
			progressionInfo.Location,
			progressionInfo.Statistics,
			progressionInfo.CustomData
		)
	end
end

export type EconomyInfo = {
	Player: Player,
	ItemName: string,
	EconomyAction: EnumItem,
	ItemCategory: string,
	Amount: integer,
	Currency: string,
	Location: Dictionary,
	CustomData: (number | string | table)?,
}

-- playfabUtil.EconomyInfo = {}

function playfabUtil.Economy(economyInfo)
	if not IsStudio then
		AnalyticsService:FireInGameEconomyEvent(
			economyInfo.Player,
			economyInfo.ItemName,
			economyInfo.EconomyAction,
			economyInfo.ItemCategory,
			economyInfo.Amount,
			economyInfo.Currency,
			economyInfo.Location,
			economyInfo.CustomData
		)
	end
end

export type LogInfo = {
	Player: Player?,
	LogLevel: EnumItem,
	Message: string,
	DebugInfo: {
		errorCode: string,
		stackTrace: string,
	}?,
	CustomData: (number | string | table)?,
}

-- playfabUtil.LogInfo = {}

function playfabUtil.Log(logInfo)
	if not IsStudio then
		AnalyticsService:FireLogEvent(
			logInfo.Player,
			logInfo.LogLevel,
			logInfo.Message,
			logInfo.DebugInfo,
			logInfo.CustomData
		)
	end
end

export type CustomInfo = {
	Player: Player?,
	EventCategory: string,
	CustomData: (number | string | table)?,
}

-- playfabUtil.CustomInfo = {}

function playfabUtil.Custom(customInfo)
	if not IsStudio then
		AnalyticsService:FireCustomEvent(customInfo.Player, customInfo.EventCategory, customInfo.CustomData)
	end
end

return playfabUtil
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0ab</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXba97901572f7439b8088acf4d95ed289">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">random</string>
					<string name="ScriptGuid">{FE5ED434-4CCD-4BA3-9821-752528635E15}</string>
					<ProtectedString name="Source"><![CDATA[local RANDOM = {}

local rng = Random.new()

function RANDOM.integer(min: integer, max: integer): integer
	return rng:NextInteger(min, max)
end

function RANDOM.number(min: number?, max: number?): number
	return rng:NextNumber(min or 0, max or 1)
end

function RANDOM.getRandoms(min: number, max: number, amount: integer): any
	local numbers = {}
	for _ = 1, amount do
		table.insert(numbers, RANDOM.number(min, max))
	end
	return table.unpack(numbers)
end

function RANDOM.fromArray(array: Array): any?
	if #array > 0 then
		return array[RANDOM.integer(1, #array)]
	end
end

-- function random.fromDictionary(dictionary: Dictionary): any?

-- end

function RANDOM.CFrameFromPart(basePart: BasePart): CFrame
	local sizeX = basePart.Size.X / 2
	local sizeY = basePart.Size.Y / 2
	local sizeZ = basePart.Size.Z / 2

	local x = RANDOM.integer(-sizeX, sizeX)
	local y = RANDOM.integer(-sizeY, sizeY)
	local z = RANDOM.integer(-sizeZ, sizeZ)
	return basePart.CFrame * CFrame.new(x, y, z)
end

function RANDOM.Vector3FromPart(basePart: BasePart): Vector3
	return RANDOM.CFrameFromPart(basePart).Position
end

function RANDOM.Vector3(min: number, max: number): Vector3
	return Vector3.new(RANDOM.getRandoms(min, max, 3))
end

function RANDOM.NumberRange(min: number, max: number): NumberRange
	return NumberRange.new(RANDOM.number(min, max))
end

function RANDOM.weight(lootTable, random): any
	local totalWeight = 0

	for _, v in ipairs(lootTable) do
		for _: string, vv in pairs(v) do
			totalWeight += vv
		end
	end

	local number = (random:NextNumber() or rng:NextNumber()) * totalWeight

	for _, v in ipairs(lootTable) do
		for name: string, weight in pairs(v) do
			if number < weight then
				return name
			end
			number -= weight
		end
	end
end

return RANDOM
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0ac</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX9d1ae2ef13dd4db2877102a7fd7d1803">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">raycastUtil</string>
					<string name="ScriptGuid">{D5EC21B3-995E-4E04-AC42-B6BE38104B7C}</string>
					<ProtectedString name="Source"><![CDATA[local camera = workspace.CurrentCamera

local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local mouse

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local characterUtil = require(Utilities.characterUtil)

local CollectionService = game:GetService("CollectionService")

local RunService = game:GetService("RunService")

local raycastUtil = {}

local raycastParams = RaycastParams.new()
raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
raycastParams.IgnoreWater = true

local DEFAULT_MAX_DISTANCE = 1000

local WorldRootIgnoreLists = {}

local function _getIgnoredPartsForWorldRoot(worldroot: WorldRoot)
	if not WorldRootIgnoreLists[worldroot] then
		local IgnoredParts = {}
		for _, descendant: Instance in ipairs(worldroot:GetDescendants()) do
			if descendant:IsA("BasePart") then
				local BasePart: BasePart = descendant
				if not BasePart.CanCollide or BasePart.Transparency == 1 then
					if not CollectionService:HasTag(BasePart, "RaycastWhitelist") then
						table.insert(IgnoredParts, BasePart)
					end
				end
			end
		end
		WorldRootIgnoreLists[worldroot] = IgnoredParts
	end
	return WorldRootIgnoreLists[worldroot]
end
raycastUtil.getIgnoredPartsForWorldRoot = _getIgnoredPartsForWorldRoot

local function _handleIgnoredPartsForWorldRoot(worldroot: WorldRoot)
	if not WorldRootIgnoreLists[worldroot] then
		local IgnoredParts = {}

		for _, descendant: Instance in ipairs(worldroot:GetDescendants()) do
			if descendant:IsA("BasePart") then
				local BasePart: BasePart = descendant
				if not BasePart.CanCollide or BasePart.Transparency == 1 then
					if not CollectionService:HasTag(BasePart, "RaycastWhitelist") then
						table.insert(IgnoredParts, BasePart)
					end
				end
			end
		end

		worldroot.DescendantAdded:Connect(function(AddedDescendant: Instance)
			if AddedDescendant:IsA("BasePart") then
				local BasePart: BasePart = AddedDescendant
				if not BasePart.CanCollide or BasePart.Transparency == 1 then
					if not CollectionService:HasTag(BasePart, "RaycastWhitelist") then
						table.insert(IgnoredParts, BasePart)
					end
				end
			end
		end)

		worldroot.DescendantRemoving:Connect(function(RemovedDescendant: Instance)
			if RemovedDescendant:IsA("BasePart") then
				local BasePart: BasePart = RemovedDescendant
				table.remove(IgnoredParts, table.find(IgnoredParts, BasePart))
			end
		end)

		WorldRootIgnoreLists[worldroot] = IgnoredParts
	end
end
raycastUtil.handleIgnoredPartsForWorldRoot = _handleIgnoredPartsForWorldRoot

function raycastUtil.RaycastFromMouse(IgnoredParts: table?, maxDistance: number?): RaycastResult?
	local mouseRay: Ray = camera:ScreenPointToRay(mouse.X, mouse.Y)
	raycastParams.FilterDescendantsInstances = IgnoredParts
	return workspace:Raycast(mouseRay.Origin, mouseRay.Direction * (maxDistance or DEFAULT_MAX_DISTANCE), raycastParams)
end

function raycastUtil.Raycast(worldroot: WorldRoot, Origin: Vector3, Direction: Vector3): RaycastResult?
	raycastParams.FilterDescendantsInstances = _getIgnoredPartsForWorldRoot(worldroot)
	return worldroot:Raycast(Origin, Direction, raycastParams)
end

if RunService:IsClient() then
	mouse = localPlayer:GetMouse()

	_handleIgnoredPartsForWorldRoot(workspace)
	local IgnoredParts = _getIgnoredPartsForWorldRoot(workspace)

	characterUtil.handleCharacterDied(localPlayer, function(character: Model)
		task.wait()
		table.insert(IgnoredParts, character)
	end)

	characterUtil.handleCharacterRemoving(localPlayer, function(character: Model)
		task.wait()
		table.remove(IgnoredParts, table.find(IgnoredParts, character))
	end)
end

return raycastUtil
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0ad</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX566538257f59432590effff5c2677939">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">region3Util</string>
					<string name="ScriptGuid">{F147F01C-444F-4C72-B84C-E7F778945F58}</string>
					<ProtectedString name="Source"><![CDATA[local region3Util = {}

return region3Util
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0ae</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX4b63119833464bd29fabd5704f5e89a8">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">tagUtil</string>
					<string name="ScriptGuid">{0568CF07-9D5D-4C8C-AB97-0697BAC35BF4}</string>
					<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")

local tagUtil = {}

function tagUtil.AddTag(instance: Instance, tag: string)
	CollectionService:AddTag(instance, tag)
end

function tagUtil.ClearAllTags(instance: Instance)
	for _, tag: string in ipairs(CollectionService:GetTags(instance)) do
		tagUtil.Remove(instance, tag)
	end
end

function tagUtil.HasTag(instance: Instance, tag: string): boolean
	return CollectionService:HasTag(instance, tag)
end

function tagUtil.RemoveTag(instance: Instance, tag: string)
	CollectionService:RemoveTag(instance, tag)
end

function tagUtil.doForTagged(tag: (string), callback: (Instance) -> void): RBXScriptConnection
	for _, instance: Instance in ipairs(CollectionService:GetTagged(tag)) do
		task.spawn(callback, instance)
	end

	return CollectionService:GetInstanceAddedSignal(tag):Connect(callback)
end

do
	local function setClassName(instance: Instance)
		if not game:FindService(instance.ClassName) then
			CollectionService:AddTag(instance, instance.ClassName)
		end
	end

	for _, descendant: Instance in ipairs(game:GetDescendants()) do
		task.spawn(pcall, setClassName, descendant)
	end

	game.DescendantAdded:Connect(function(descendant: Instance)
		task.defer(pcall, setClassName, descendant)
	end)
end

return tagUtil
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0af</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX95c8cbd0cc374c36b6b19e9016a0acd2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">tweenUtil</string>
					<string name="ScriptGuid">{DDDFB22D-7262-4889-B67E-B04EEE0D8A2E}</string>
					<ProtectedString name="Source"><![CDATA[local tweenUtil = {}

tweenUtil.EasingStyle = {
	Linear = Enum.EasingStyle.Linear,
	Sine = Enum.EasingStyle.Sine,
	Back = Enum.EasingStyle.Back,
	Quad = Enum.EasingStyle.Quad,
	Quart = Enum.EasingStyle.Quart,
	Quint = Enum.EasingStyle.Quint,
	Bounce = Enum.EasingStyle.Bounce,
	Elastic = Enum.EasingStyle.Elastic,
	Exponential = Enum.EasingStyle.Exponential,
	Circular = Enum.EasingStyle.Circular,
	Cubic = Enum.EasingStyle.Cubic,
}

tweenUtil.EasingDirection = {
	In = Enum.EasingDirection.In,
	Out = Enum.EasingDirection.Out,
	InOut = Enum.EasingDirection.InOut,
}

return tweenUtil
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0b0</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX932592f81bbc4b3aa8e8b07f626273ea">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">waitUntil</string>
					<string name="ScriptGuid">{D7DF772D-FB87-426E-971E-FBAD9073AD50}</string>
					<ProtectedString name="Source"><![CDATA[local function waitUntil(ancestor: Instance)
	return {
		IsAncestorOf = function(descendant: Instance)
			while not ancestor:IsAncestorOf(descendant) do
				descendant.AncestryChanged:Wait()
			end
		end,
		IsDescendantOf = function(descendant: Instance)
			while not descendant:IsDescendantOf(ancestor) do
				descendant.AncestryChanged:Wait()
			end
		end,
	}
end

return waitUntil
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0b1</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX51673dbcec33426dae1a31c8eda57370">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Nature2D</string>
					<string name="ScriptGuid">{B0FAF57F-8E4B-4A0F-AC5E-A5E61D9CC831}</string>
					<ProtectedString name="Source"><![CDATA[return require(game.ReplicatedStorage.Packages.Nature2D)
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags">M3JkUGFydHk=</BinaryString>
					<UniqueId name="UniqueId">354376ce1e53961902cc6be30001a36e</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX5a49daa9e9e74dd9ad11d56d68ff73d4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Promise</string>
					<string name="ScriptGuid">{062F8D43-8FD4-467F-9439-F937A58D34C2}</string>
					<ProtectedString name="Source">return require(game.ReplicatedStorage.Packages.Promise)</ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags">M3JkUGFydHk=</BinaryString>
					<UniqueId name="UniqueId">38d136ec74d9240302cc7f550001a0c1</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX93397a1c63e54c7493b779fedae2c0f2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Signals</string>
					<string name="ScriptGuid">{E8C1FF33-FFFB-486B-A389-45DEA514C247}</string>
					<ProtectedString name="Source"><![CDATA[local freeRunnerThread = nil

local function acquireRunnerThreadAndCallEventHandler(callback, ...: any)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	callback(...)
	freeRunnerThread = acquiredRunnerThread
end

local function runEventHandlerInFreeThread(...: any)
	acquireRunnerThreadAndCallEventHandler(...)
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

export type Connection = {
	Connected: boolean,
	Disconnect: () -> void,
}

local Connections = {}
Connections.IS_CYCLICAL = true
Connections.__index = Connections

function Connections.create(signal: Signal, callback): Connection
	return setmetatable({
		Connected = true,
		_signal = signal,
		_callback = callback,
		_next = false,
		USING_METATABLE = true,
		-- Metatable = Connections
	}, Connections)
end

function Connections:Disconnect()
	if self.Connected then
		self.Connected = false
		if self._signal._handlerListHead == self then
			self._signal._handlerListHead = self._next
		else
			local prev = self._signal._handlerListHead
			while prev and prev._next ~= self do
				prev = prev._next
			end
			if prev then
				prev._next = self._next
			end
		end
	else
		warn("Attepmting to disconnect a connection twice")
	end
end

setmetatable(Connections, {
	__index = function(_, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_, key, _)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})
export type Signal = {
	Connect: () -> (Connection),
	DisconnectAll: () -> void,
	Fire: (...any?) -> void,
	Wait: () -> (...any?),
}

local Signals = {}
Connections.IS_CYCLICAL = true
Signals.__index = Signals

function Signals.create(): Signal
	return setmetatable({
		_handlerListHead = false,
		USING_METATABLE = true,
		-- Metatable = Signals
	}, Signals)
end

function Signals:Connect(callback): Connection
	local connection = Connections.create(self, callback)
	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end
	return connection
end

function Signals:DisconnectAll()
	self._handlerListHead = false
end

function Signals:Destroy()
	self._handlerListHead = false
end

function Signals:Fire(...: any)
	local item = self._handlerListHead
	while item do
		if item.Connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
			end
			task.spawn(freeRunnerThread, item._callback, ...)
		end
		item = item._next
	end
end

function Signals:Wait(): ...any?
	local waitingCoroutine = coroutine.running()
	local connection
	connection = self:Connect(function(...)
		connection:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)
	return coroutine.yield()
end

setmetatable(Signals, {
	__index = function(_, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_, key, _)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

return Signals
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags">M3JkUGFydHk=</BinaryString>
					<UniqueId name="UniqueId">38d136ec74d9240302cc7f550001a0c3</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX0e77ac036fbe4a20b5751c636941c2b2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">t</string>
					<string name="ScriptGuid">{6679F76E-B713-4D02-B991-86377EBC4704}</string>
					<ProtectedString name="Source">return require(game.ReplicatedStorage.Packages.t)</ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags">M3JkUGFydHk=</BinaryString>
					<UniqueId name="UniqueId">38d136ec74d9240302cc7f550001a0dc</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXc4c37ae4aa5442168a2c4617174225e2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Janitor</string>
					<string name="ScriptGuid">{67690D36-AAD9-41B2-9107-D957C08224BD}</string>
					<ProtectedString name="Source">return require(game.ReplicatedStorage.Packages.Janitor)</ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags">M3JkUGFydHk=</BinaryString>
					<UniqueId name="UniqueId">38d136ec74d9240302cc7f550001a0e5</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX68584d158b304c0e9a04e291bc42ddaf">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Packages</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0e2</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="RBX1d0b1b6d962a4f46a6366b5201f7fcf0">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Nature2D</string>
					<string name="ScriptGuid">{2ED69C1E-AB44-4DFA-B425-8D180296B325}</string>
					<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["ruizukun-dev_nature2d@0.7.3"]["nature2d"])
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">354376ce1e53961902cc6be30001a36c</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXf4f6ec1e439f42309546be461f9f16d6">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Promise</string>
					<string name="ScriptGuid">{D62BB1D7-823F-4385-8333-02C8EC1FA76C}</string>
					<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["ruizukun-dev_promise@4.0.3"]["promise"])
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">38d136ec74d9240302cc7f550001a0da</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXc485f94a384a413bb0d836015db3ce20">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">t</string>
					<string name="ScriptGuid">{456A45D8-06C6-49A3-B981-1BB953EA03F0}</string>
					<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["ruizukun-dev_t@3.0.6"]["t"])
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">38d136ec74d9240302cc7f550001a0e1</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXcce6904303b14e31b6431f6b8e62cd27">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Janitor</string>
					<string name="ScriptGuid">{76279C63-F1D6-4432-91F0-5BB08AF528B2}</string>
					<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["ruizukun-dev_janitor@1.14.7"]["janitor"])
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">38d136ec74d9240302cc7f550001a0e3</UniqueId>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXc410e4c7066c482c8bb866348d6a7a3a">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">_Index</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">118b823fbc6f4004040d84d90000331c</UniqueId>
				</Properties>
				<Item class="Folder" referent="RBX64c7f1cd8bce4070a1c564688792e9b5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">ruizukun-dev_janitor@1.14.7</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">118b823fbc6f4004040d84d90000331d</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBXd29e3a7a438c4a82a0c8e53f4a49a4d2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">janitor</string>
							<string name="ScriptGuid">{83bfe964-e73e-401f-b41f-4ae802aa80de}</string>
							<ProtectedString name="Source"><![CDATA[local GetPromiseLibrary = require(script.GetPromiseLibrary)
local RbxScriptConnection = require(script.RbxScriptConnection)
local Symbol = require(script.Symbol)
local FoundPromiseLibrary, Promise = GetPromiseLibrary()
local IndicesReference = Symbol("IndicesReference")
local LinkToInstanceIndex = Symbol("LinkToInstanceIndex")
local INVALID_METHOD_NAME =
	[[Object is a %s and as such expected `true?` for the method name and instead got %s. Traceback: %s]]
local METHOD_NOT_FOUND_ERROR = [[Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s]]
local NOT_A_PROMISE = [[Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s)) Traceback: %s]]
local Janitor = {}

Janitor.ClassName = "Janitor"
Janitor.CurrentlyCleaning = true
Janitor[IndicesReference] = nil
Janitor.__index = Janitor

local TypeDefaults = {
	["function"] = true,
	thread = true,
	RBXScriptConnection = "Disconnect",
}

function Janitor.new()
	return setmetatable({
		CurrentlyCleaning = false,
		[IndicesReference] = nil,
	}, Janitor)
end
function Janitor.Is(Object)
	return type(Object) == "table" and getmetatable(Object) == Janitor
end
function Janitor:Add(Object, MethodName, Index)
	if Index then
		self:Remove(Index)

		local This = self[IndicesReference]

		if not This then
			This = {}
			self[IndicesReference] = This
		end

		This[Index] = Object
	end

	local TypeOf = typeof(Object)
	local NewMethodName = MethodName or TypeDefaults[TypeOf] or "Destroy"

	if TypeOf == "function" or TypeOf == "thread" then
		if NewMethodName ~= true then
			warn(string.format(INVALID_METHOD_NAME, TypeOf, tostring(NewMethodName), debug.traceback(nil, 2)))
		end
	else
		if not (Object)[NewMethodName] then
			warn(
				string.format(
					METHOD_NOT_FOUND_ERROR,
					tostring(Object),
					tostring(NewMethodName),
					debug.traceback(nil, 2)
				)
			)
		end
	end

	self[Object] = NewMethodName

	return Object
end
function Janitor:AddPromise(PromiseObject)
	if FoundPromiseLibrary then
		if not Promise.is(PromiseObject) then
			error(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject), debug.traceback(nil, 2)))
		end
		if PromiseObject:getStatus() == Promise.Status.Started then
			local Id = newproxy(false)
			local NewPromise = self:Add(
				Promise.new(function(Resolve, _, OnCancel)
					if OnCancel(function()
						PromiseObject:cancel()
					end) then
						return
					end

					Resolve(PromiseObject)
				end),
				"cancel",
				Id
			)

			NewPromise:finallyCall(self.Remove, self, Id)

			return NewPromise
		else
			return PromiseObject
		end
	else
		return PromiseObject
	end
end
function Janitor:Remove(Index)
	local This = self[IndicesReference]

	if This then
		local Object = This[Index]

		if Object then
			local MethodName = self[Object]

			if MethodName then
				if MethodName == true then
					if type(Object) == "function" then
						Object()
					else
						task.cancel(Object)
					end
				else
					local ObjectMethod = Object[MethodName]

					if ObjectMethod then
						ObjectMethod(Object)
					end
				end

				self[Object] = nil
			end

			This[Index] = nil
		end
	end

	return self
end
function Janitor:RemoveList(...)
	local This = self[IndicesReference]

	if This then
		local Length = select("#", ...)

		if Length == 1 then
			return self:Remove(...)
		else
			for Index = 1, Length do
				local Object = This[select(Index, ...)]

				if Object then
					local MethodName = self[Object]

					if MethodName then
						if MethodName == true then
							if type(Object) == "function" then
								Object()
							else
								task.cancel(Object)
							end
						else
							local ObjectMethod = Object[MethodName]

							if ObjectMethod then
								ObjectMethod(Object)
							end
						end

						self[Object] = nil
					end

					This[Index] = nil
				end
			end
		end
	end

	return self
end

function Janitor:Get(Index: any): any?
	local This = self[IndicesReference]
	return if This then This[Index] else nil
end

local function GetFenv(self)
	return function()
		for Object, MethodName in next, self do
			if Object ~= IndicesReference then
				return Object, MethodName
			end
		end
	end
end

function Janitor:Cleanup()
	if not self.CurrentlyCleaning then
		self.CurrentlyCleaning = nil

		local Get = GetFenv(self)
		local Object, MethodName = Get()

		while Object and MethodName do
			if MethodName == true then
				if type(Object) == "function" then
					Object()
				else
					task.cancel(Object)
				end
			else
				local ObjectMethod = Object[MethodName]

				if ObjectMethod then
					ObjectMethod(Object)
				end
			end

			self[Object] = nil
			Object, MethodName = Get()
		end

		local This = self[IndicesReference]

		if This then
			table.clear(This)

			self[IndicesReference] = {}
		end

		self.CurrentlyCleaning = false
	end
end
function Janitor:Destroy()
	self:Cleanup()
	table.clear(self)
	setmetatable(self, nil)
end

Janitor.__call = Janitor.Cleanup

function Janitor:LinkToInstance(Object, AllowMultiple)
	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex

	return self:Add(
		Object.Destroying:Connect(function()
			self:Cleanup()
		end),
		"Disconnect",
		IndexToUse
	)
end
function Janitor:LegacyLinkToInstance(Object, AllowMultiple)
	local Connection
	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex
	local IsNilParented = Object.Parent == nil
	local ManualDisconnect = setmetatable({}, RbxScriptConnection)

	local function ChangedFunction(_DoNotUse, NewParent)
		if ManualDisconnect.Connected then
			_DoNotUse = nil
			IsNilParented = NewParent == nil

			if IsNilParented then
				task.defer(function()
					if not ManualDisconnect.Connected then
						return
					elseif not Connection.Connected then
						self:Cleanup()
					else
						while IsNilParented and Connection.Connected and ManualDisconnect.Connected do
							task.wait()
						end

						if ManualDisconnect.Connected and IsNilParented then
							self:Cleanup()
						end
					end
				end)
			end
		end
	end

	Connection = Object.AncestryChanged:Connect(ChangedFunction)
	ManualDisconnect.Connection = Connection

	if IsNilParented then
		ChangedFunction(nil, Object.Parent)
	end

	Object = nil

	return self:Add(ManualDisconnect, "Disconnect", IndexToUse)
end
function Janitor:LinkToInstances(...)
	local ManualCleanup = Janitor.new()

	for _, Object in ipairs({ ... }) do
		ManualCleanup:Add(self:LinkToInstance(Object, true), "Disconnect")
	end

	return ManualCleanup
end
function Janitor:__tostring()
	return "Janitor"
end

table.freeze(Janitor)

return Janitor
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags">V2FsbHk=</BinaryString>
							<UniqueId name="UniqueId">118b823fbc6f4004040d84d90000331e</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXe6e3f33afaf143c48b9bd6f633cfe785">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">GetPromiseLibrary</string>
								<string name="ScriptGuid">{32ad2503-f565-4d3c-9806-7edec8203139}</string>
								<ProtectedString name="Source"><![CDATA[local ReplicatedFirst = game:GetService("ReplicatedFirst")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local ServerStorage = game:GetService("ServerStorage")
local LOCATIONS_TO_SEARCH = {
	script.Parent.Parent,
	ReplicatedFirst,
	ReplicatedStorage,
	ServerScriptService,
	ServerStorage,
}

local function FindFirstDescendantWithNameAndClassName(Parent, Name, ClassName)
	for _, Descendant in ipairs(Parent:GetDescendants()) do
		if Descendant:IsA(ClassName) and Descendant.Name == Name then
			return Descendant
		end
	end

	return nil
end
local function GetPromiseLibrary()
	local Plugin = script:FindFirstAncestorOfClass("Plugin")

	if Plugin then
		local Promise = FindFirstDescendantWithNameAndClassName(Plugin, "Promise", "ModuleScript")

		if Promise then
			return true, require(Promise)
		else
			return false
		end
	end

	local Promise

	for _, Location in ipairs(LOCATIONS_TO_SEARCH) do
		Promise = FindFirstDescendantWithNameAndClassName(Location, "Promise", "ModuleScript")

		if Promise then
			break
		end
	end

	if Promise then
		return true, require(Promise)
	else
		return false
	end
end

return GetPromiseLibrary
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d90000331f</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX7fd926f0fc53439ab357c374e95a3c09">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">RbxScriptConnection</string>
								<string name="ScriptGuid">{81441b36-6f90-4353-8795-36c8dfa2992a}</string>
								<ProtectedString name="Source"><![CDATA[local RbxScriptConnection = {}

RbxScriptConnection.Connected = true
RbxScriptConnection.__index = RbxScriptConnection

function RbxScriptConnection:Disconnect()
	if self.Connected then
		self.Connected = false

		self.Connection:Disconnect()
	end
end
function RbxScriptConnection._new(RBXScriptConnection)
	return setmetatable({ Connection = RBXScriptConnection }, RbxScriptConnection)
end
function RbxScriptConnection:__tostring()
	return "RbxScriptConnection<" .. tostring(self.Connected) .. ">"
end

return RbxScriptConnection
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003320</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXdcf135679aa34b4ebaa6b6ac89aabc5b">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Symbol</string>
								<string name="ScriptGuid">{224c308b-331a-4a61-b072-77c54f1d445f}</string>
								<ProtectedString name="Source"><![CDATA[local function Symbol(Name)
	local self = newproxy(true)
	local Metatable = getmetatable(self)

	function Metatable.__tostring()
		return Name
	end

	return self
end

return Symbol
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003321</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXa953ca3f876348d4aa9adf1f0d416d14">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">ruizukun-dev_nature2d@0.7.3</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003322</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX320fd1951a734ed0975385f8959f04d9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">nature2d</string>
							<string name="ScriptGuid">{a851abcd-5afa-4bc4-aa1a-23d26a5ca624}</string>
							<ProtectedString name="Source"><![CDATA[return require(script.Engine)
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003323</UniqueId>
						</Properties>
						<Item class="Folder" referent="RBX3a7e0b08114a4f7686c2641775430dc7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">Debugging</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003324</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXe86c18ccb6c24bdc91cef59676b81b1e">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Exceptions</string>
									<string name="ScriptGuid">{ceccd7e4-9fa7-4c4e-8fe7-ef9e98efcb1b}</string>
									<ProtectedString name="Source"><![CDATA[local TYPES = {
	NO_CANVAS_FOUND = "No canvas found, initialize the engine's canvas using Engine:CreateCanvas().",
	NO_RIGIDBODIES_FOUND = "No rigid bodies found on start.",
	PROPERTY_NOT_FOUND = "Invalid Argument #1. Property not found.",
	INVALID_CONSTRAINT_TYPE = "Received Invalid Constraint Type.",
	INVALID_CONSTRAINT_LENGTH = "Received Invalid Constraint Length.",
	INVALID_CONSTRAINT_THICKNESS = "Received Invalid Constraint Thickness.",
	SAME_ID = "Cannot ignore collisions for the same RigidBodies.",
	INVALID_RIGIDBODY = "Received Invalid RigidBody.",
	INVALID_OBJECT = "Received an Invalid Object. Valid objects - RigidBody, Point and Constraint.",
	INVALID_PROPERTY = "Received an Invalid Object Property.",
	MUST_HAVE_PROPERTY = "Missing must-have properties.",
	CANVAS_FRAME_NOT_FOUND = "No canvas frame found, initialize the canvas's frame to render custom Points and Constraints!",
	INVALID_TIME = "Received invalid time to apply force for.",
	ALREADY_STARTED = "Engine is already running.",
	CANNOT_SET_COLLISION_ITERATIONS = "Cannot set collision iterations! You must turn on quadtree usage using Engine:UseQuadtrees(true).",
}

return function(TASK: string, TYPE: string, details: string?)
	if TYPES[TYPE] then
		local exception = string.format("[Nature2D]: %s%s", TYPES[TYPE], if details then " " .. details else "")

		if TASK == "warn" then
			warn(exception)
		elseif TASK == "error" then
			error(exception, 2)
		end
	end
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003325</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX34801e4bfa074918b5a6aa779634407f">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Restrict</string>
									<string name="ScriptGuid">{7e80ff55-775d-4cb5-894b-439346e0f1ec}</string>
									<ProtectedString name="Source"><![CDATA[return function(custom)
	if custom then
		error([[[Nature2D]: This method cannot be used with custom RigidBodies]], 2)
	end
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003326</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXa2b92e0326214ebea08a252008083a46">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">TypeErrors</string>
									<string name="ScriptGuid">{5bac874c-0525-417c-a96f-e685a1949f2b}</string>
									<ProtectedString name="Source"><![CDATA[return function(arg, param, pos, expected)
	if typeof(param) ~= expected then
		error(
			string.format(
				[[[Nature2D]: Invalid Argument #%s. Expected type %q for %s, got %q]],
				tostring(pos),
				expected,
				arg,
				typeof(param)
			),
			2
		)
	end
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003327</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX92537e55e6154cfb9d177b3f9f1f9489">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Engine</string>
								<string name="ScriptGuid">{739eb22e-29e9-45ea-bfe6-ecf61f7d929c}</string>
								<ProtectedString name="Source"><![CDATA[-- #selene: allow(unused_variable)

local RigidBody = require(script.Parent.Physics.RigidBody)
local Point = require(script.Parent.Physics.Point)
local Constraint = require(script.Parent.Physics.Constraint)
local PhysicsRunner = require(script.Parent.Physics.Runner)
local Globals = require(script.Parent.Constants.Globals)
local Signal = require(script.Parent.Utilities.Signal)
local Quadtree = require(script.Parent.Utilities.Quadtree)
local Janitor = require(script.Parent.Utilities.Janitor)
local Types = require(script.Parent.Types)
local throwException = require(script.Parent.Debugging.Exceptions)
local throwTypeError = require(script.Parent.Debugging.TypeErrors)
local RunService = game:GetService("RunService")

local function SearchTable(t, a, lambda)
	for _, v in ipairs(t) do
		if lambda(a, v) then
			return v
		end
	end

	return nil
end

local Engine = {}

Engine.__index = Engine

function Engine.init(screengui)
	if not typeof(screengui) == "Instance" or not screengui:IsA("Instance") then
		error("Invalid Argument #1. 'screengui' must be a ScreenGui.", 2)
	end

	local self = setmetatable({
		bodies = {},
		constraints = {},
		points = {},
		connection = nil,
		_janitor = nil,
		gravity = Globals.engineInit.gravity,
		friction = Globals.engineInit.friction,
		airfriction = Globals.engineInit.airfriction,
		bounce = Globals.engineInit.bounce,
		timeSteps = Globals.engineInit.timeSteps,
		mass = Globals.universalMass,
		path = screengui,
		speed = Globals.speed,
		quadtrees = false,
		independent = true,
		canvas = {
			frame = nil,
			topLeft = Globals.engineInit.canvas.topLeft,
			size = Globals.engineInit.canvas.size,
		},
		iterations = {
			constraint = 1,
			collision = 1,
		},
		Started = Signal.new(),
		Stopped = Signal.new(),
		ObjectAdded = Signal.new(),
		ObjectRemoved = Signal.new(),
		Updated = Signal.new(),
	}, Engine)
	local janitor = Janitor.new()

	janitor:Add(self.Started, "Destroy")
	janitor:Add(self.Stopped, "Destroy")
	janitor:Add(self.ObjectAdded, "Destroy")
	janitor:Add(self.ObjectRemoved, "Destroy")
	janitor:Add(self.Updated, "Destroy")

	self._janitor = janitor

	return self
end
function Engine:Start()
	if not self.canvas then
		throwException("error", "NO_CANVAS_FOUND")
	end
	if #self.bodies == 0 then
		throwException("warn", "NO_RIGIDBODIES_FOUND")
	end
	if self.connection then
		throwException("warn", "ALREADY_STARTED")

		return
	end

	self.Started:Fire()

	local fixedDeltaTime = 1.6666666666666665E-2
	local epsilon = 1E-3
	local accumulator = 0
	local connection

	connection = RunService.RenderStepped:Connect(function(deltaTime)
		if self.independent then
			accumulator += deltaTime

			while accumulator > 0 do
				accumulator -= fixedDeltaTime

				PhysicsRunner.Update(self, deltaTime)
				PhysicsRunner.Render(self)
			end

			if accumulator >= -epsilon then
				accumulator = 0
			end
		else
			accumulator = 0

			PhysicsRunner.Update(self, deltaTime)
			PhysicsRunner.Render(self)
		end
	end)
	self.connection = connection

	self._janitor:Add(self.connection, "Disconnect", "MainConnection")
end
function Engine:Stop()
	if self.connection then
		self.Stopped:Fire()
		self._janitor:Remove("MainConnection")

		self.connection = nil
	end
end
function Engine:Create(object, properties)
	throwTypeError("object", object, 1, "string")
	throwTypeError("properties", properties, 2, "table")

	if object ~= "Constraint" and object ~= "Point" and object ~= "RigidBody" then
		throwException("error", "INVALID_OBJECT")
	end

	for prop, value in pairs(properties) do
		if not table.find(Globals.VALID_OBJECT_PROPS, prop) then
			throwException("error", "INVALID_PROPERTY", string.format("%q is not a valid property!", prop))

			return
		end
		if not table.find(Globals[string.lower(object)].props, prop) then
			throwException(
				"error",
				"INVALID_PROPERTY",
				string.format("%q is not a valid property for a %s!", prop, object)
			)

			return
		end
		if Globals.OBJECT_PROPS_TYPES[prop] and typeof(value) ~= Globals.OBJECT_PROPS_TYPES[prop] then
			error(
				string.format(
					[[[Nature2D]: Invalid Property type for %q. Expected %q got %q.]],
					prop,
					Globals.OBJECT_PROPS_TYPES[prop],
					typeof(value)
				),
				2
			)
		end
	end
	for _, prop in ipairs(Globals[string.lower(object)].must_have) do
		if not properties[prop] then
			local throw = true

			if prop == "Object" and properties.Structure then
				throw = false
			end
			if throw then
				throwException(
					"error",
					"MUST_HAVE_PROPERTY",
					string.format("You must specify the %q property for a %s!", prop, object)
				)

				return
			end
		end
	end

	local newObject

	if object == "Point" then
		local newPoint = Point.new(properties.Position or Vector2.new(), self.canvas, self, {
			snap = properties.Snap,
			selectable = false,
			render = properties.Visible,
			keepInCanvas = properties.KeepInCanvas or true,
		}, nil)

		if properties.Radius then
			newPoint:SetRadius(properties.Radius)
		end
		if properties.Color then
			newPoint:Stroke(properties.Color)
		end

		table.insert(self.points, newPoint)

		newObject = newPoint
	elseif object == "Constraint" then
		if not table.find(Globals.constraint.types, string.lower(properties.Type or "")) then
			throwException("error", "INVALID_CONSTRAINT_TYPE")
		end
		if properties.RestLength and properties.RestLength <= 0 then
			throwException("error", "INVALID_CONSTRAINT_LENGTH")
		end
		if properties.Thickness and properties.Thickness <= 0 then
			throwException("error", "INVALID_CONSTRAINT_THICKNESS")
		end
		if properties.Point1 and properties.Point2 and properties.Type then
			local dist = (properties.Point1.pos - properties.Point2.pos).Magnitude
			local newConstraint = Constraint.new(properties.Point1, properties.Point2, self.canvas, {
				restLength = properties.RestLength or dist,
				render = properties.Visible,
				thickness = properties.Thickness,
				support = false,
				TYPE = string.upper(properties.Type),
			}, self)

			if properties.SpringConstant then
				newConstraint:SetSpringConstant(properties.SpringConstant)
			end
			if properties.Color then
				newConstraint:Stroke(properties.Color)
			end

			table.insert(self.constraints, newConstraint)

			newObject = newConstraint
		end
	elseif object == "RigidBody" then
		if properties.Object and not properties.Object:IsA("GuiObject") and not properties.Structure then
			error("'Object' must be a GuiObject", 2)
		end

		local obj = nil

		if not properties.Structure then
			obj = properties.Object
		end

		local custom = {
			Vertices = {},
			Edges = {},
		}

		if properties.Structure then
			if not self.canvas.frame then
				throwException("error", "CANVAS_FRAME_NOT_FOUND")
			end

			for _, c in ipairs(properties.Structure) do
				local a = c[1]
				local b = c[2]
				local support = c[3]

				if typeof(a) ~= "Vector2" or typeof(b) ~= "Vector2" then
					error([[[Nature2D]: Invalid point positions for custom RigidBody structure.]], 2)
				end
				if support and typeof(support) ~= "boolean" then
					error("[Nature2D]: 'support' must be a boolean or nil")
				end
				if a == b then
					error("[Nature2D]: A constraint cannot have the same points.", 2)
				end

				local PointA = SearchTable(custom.Vertices, a, function(i, v)
					return i == v.pos
				end)
				local PointB = SearchTable(custom.Vertices, b, function(i, v)
					return i == v.pos
				end)

				if not PointA then
					PointA = Point.new(a, self.canvas, self, {
						snap = properties.Anchored,
						selectable = false,
						render = false,
						keepInCanvas = properties.KeepInCanvas or true,
					})

					table.insert(custom.Vertices, PointA)
				end
				if not PointB then
					PointB = Point.new(b, self.canvas, self, {
						snap = properties.Anchored,
						selectable = false,
						render = false,
						keepInCanvas = properties.KeepInCanvas or true,
					})

					table.insert(custom.Vertices, PointB)
				end

				local edge = Constraint.new(PointA, PointB, self.canvas, {
					render = support and false or true,
					thickness = 2,
					support = support,
					TYPE = "ROD",
				}, self)

				table.insert(custom.Edges, edge)
			end
		end

		local newBody = RigidBody.new(
			obj,
			properties.Mass or self.mass,
			properties.Collidable,
			properties.Anchored,
			self,
			properties.Structure and custom or nil,
			properties.Structure
		)

		if properties.LifeSpan then
			newBody:SetLifeSpan(properties.LifeSpan)
		end
		if typeof(properties.KeepInCanvas) == "boolean" then
			newBody:KeepInCanvas(properties.KeepInCanvas)
		end
		if properties.Gravity then
			newBody:SetGravity(properties.Gravity)
		end
		if properties.Friction then
			newBody:SetFriction(properties.Friction)
		end
		if properties.AirFriction then
			newBody:SetAirFriction(properties.AirFriction)
		end
		if typeof(properties.CanRotate) == "boolean" and not properties.Structure then
			newBody:CanRotate(properties.CanRotate)
		end

		table.insert(self.bodies, newBody)

		newObject = newBody
	end

	self._janitor:Add(newObject, "Destroy")
	self.ObjectAdded:Fire(newObject)

	return newObject
end
function Engine:GetBodies()
	return self.bodies
end
function Engine:GetConstraints()
	return self.constraints
end
function Engine:GetPoints()
	return self.points
end
function Engine:CreateCanvas(topLeft, size, frame)
	throwTypeError("topLeft", topLeft, 1, "Vector2")
	throwTypeError("size", size, 2, "Vector2")

	self.canvas.topLeft = topLeft
	self.canvas.size = size

	if frame and frame:IsA("Frame") then
		self.canvas.frame = frame
	end
end
function Engine:SetSimulationSpeed(speed)
	throwTypeError("speed", speed, 1, "number")

	self.speed = speed
end
function Engine:SetPhysicalProperty(property, value)
	throwTypeError("property", property, 1, "string")

	local properties = Globals.properties

	local function Update(object)
		if string.lower(property) == "collisionmultiplier" then
			throwTypeError("value", value, 2, "number")

			object.bounce = value
		elseif string.lower(property) == "gravity" then
			throwTypeError("value", value, 2, "Vector2")

			object.gravity = value
		elseif string.lower(property) == "friction" then
			throwTypeError("value", value, 2, "number")

			object.friction = math.clamp(1 - value, 0, 1)
		elseif string.lower(property) == "airfriction" then
			throwTypeError("value", value, 2, "number")

			object.airfriction = math.clamp(1 - value, 0, 1)
		elseif string.lower(property) == "universalmass" then
			throwTypeError("value", value, 2, "number")

			object.mass = math.max(0, value)
		end
	end

	if table.find(properties, string.lower(property)) then
		if #self.bodies < 1 then
			Update(self)
		else
			Update(self)

			for _, b in ipairs(self.bodies) do
				for _, v in ipairs(b:GetVertices()) do
					Update(v)
				end
			end
		end
	else
		throwException("error", "PROPERTY_NOT_FOUND")
	end
end
function Engine:GetBodyById(id)
	throwTypeError("id", id, 1, "string")

	for _, b in ipairs(self.bodies) do
		if b.id == id then
			return b
		end
	end

	return
end
function Engine:GetConstraintById(id)
	throwTypeError("id", id, 1, "string")

	for _, c in ipairs(self.constraints) do
		if c.id == id then
			return c
		end
	end

	return
end
function Engine:GetDebugInfo()
	return {
		Objects = {
			RigidBodies = #self.bodies,
			Constraints = #self.constraints,
			Points = #self.points,
		},
		Running = not not self.connection,
		Physics = {
			Gravity = self.gravity,
			Friction = 1 - self.friction,
			AirFriction = 1 - self.airfriction,
			CollisionMultiplier = self.bounce,
			TimeSteps = self.timeSteps,
			SimulationSpeed = self.speed,
			UsingQuadtrees = self.quadtrees,
			FramerateIndependent = self.independent,
		},
		Path = self.path,
		Canvas = {
			Frame = self.canvas.frame,
			TopLeft = self.canvas.topLeft,
			Size = self.canvas.size,
		},
	}
end
function Engine:UseQuadtrees(use)
	throwTypeError("useQuadtrees", use, 1, "boolean")

	self.quadtrees = use
end
function Engine:FrameRateIndependent(independent)
	throwTypeError("independent", independent, 1, "boolean")

	self.independent = independent
end
function Engine:SetConstraintIterations(iterations)
	throwTypeError("iterations", iterations, 1, "number")

	self.iterations.constraint = math.floor(math.clamp(iterations, 1, 10))
end
function Engine:SetCollisionIterations(iterations)
	throwTypeError("iterations", iterations, 1, "number")

	if self.quadtrees then
		self.iterations.collision = math.floor(math.clamp(iterations, 1, 10))
	else
		throwException("warn", "CANNOT_SET_COLLISION_ITERATIONS")
	end
end
function Engine:Destroy()
	self._janitor:Destroy()
	setmetatable(self, nil)
end

return Engine
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003328</UniqueId>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX1963b3dc014d41349f5d466a47180e7c">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">Physics</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003329</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX4ebbe27059394b2fbe08874b33499a1d">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Constraint</string>
									<string name="ScriptGuid">{e04c8828-b090-4e73-8279-f7ba5ca1968f}</string>
									<ProtectedString name="Source"><![CDATA[-- #selene: allow(unused_variable)

local line = require(script.Parent.Parent.Utilities.Line)
local Globals = require(script.Parent.Parent.Constants.Globals)
local throwTypeError = require(script.Parent.Parent.Debugging.TypeErrors)
local throwException = require(script.Parent.Parent.Debugging.Exceptions)
local Janitor = require(script.Parent.Parent.Utilities.Janitor)
local Types = require(script.Parent.Parent.Types)
local https = game:GetService("HttpService")
local Constraint = {}

Constraint.__index = Constraint

function Constraint.new(p1, p2, canvas, config, engine, parent)
	local self = setmetatable({
		id = https:GenerateGUID(false),
		_janitor = nil,
		engine = engine,
		Parent = parent,
		frame = nil,
		canvas = canvas,
		point1 = p1,
		point2 = p2,
		restLength = config.restLength or (p2.pos - p1.pos).Magnitude,
		render = config.render,
		thickness = config.thickness or Globals.constraint.thickness,
		support = config.support,
		_TYPE = config.TYPE,
		k = 0.1,
		color = nil,
	}, Constraint)
	local janitor = Janitor.new()

	janitor:Add(self, "Destroy")
	janitor:Add(self.point1, "Destroy")
	janitor:Add(self.point2, "Destroy")

	if self.Parent then
		janitor:Add(self.Parent, "Destroy")
	end

	self._janitor = janitor
	self.point1.Parent = self
	self.point2.Parent = self

	self.point1._janitor:Add(self.point1.Parent, "Destroy")
	self.point2._janitor:Add(self.point2.Parent, "Destroy")

	return self
end
function Constraint:Constrain()
	local cur = (self.point2.pos - self.point1.pos).Magnitude
	local force

	if self._TYPE == "ROPE" then
		local restLength = self.restLength

		if cur < self.thickness then
			restLength = self.thickness
		end
		if cur > self.restLength or self.restLength < self.thickness then
			local offset = ((restLength - cur) / restLength) / 2

			force = self.point2.pos - self.point1.pos

			force *= offset
		end
	elseif self._TYPE == "ROD" then
		local offset = self.restLength - cur
		local dif = self.point2.pos - self.point1.pos

		dif = dif.Unit
		force = (dif * offset) / 2
	elseif self._TYPE == "SPRING" then
		force = self.point2.pos - self.point1.pos

		local mag = force.Magnitude - self.restLength

		force = force.Unit

		force *= -1 * self.k * mag
	else
		return
	end
	if force then
		if not self.point1.snap then
			self.point1.pos -= force
		end
		if not self.point2.snap then
			self.point2.pos += force
		end
	end
end
function Constraint:Render()
	if self.render and not self.support then
		if not self.canvas.frame then
			throwException("error", "CANVAS_FRAME_NOT_FOUND")
		end

		local thickness = self.thickness or Globals.constraint.thickness
		local color = self.color or Globals.constraint.color
		local image = self._TYPE == "SPRING" and "rbxassetid://8404350124" or nil

		if not self.frame then
			self.frame = line(self.point1.pos, self.point2.pos, self.canvas.frame, thickness, color, nil, image)

			self._janitor:Add(self.frame, "Destroy")
		end

		line(self.point1.pos, self.point2.pos, self.canvas.frame, thickness, color, self.frame, image)
	end
end
function Constraint:SetLength(newLength)
	throwTypeError("length", newLength, 1, "number")

	if newLength <= 0 then
		throwException("error", "INVALID_CONSTRAINT_LENGTH")
	end

	self.restLength = newLength
end
function Constraint:GetLength()
	return (self.point2.pos - self.point1.pos).Magnitude
end
function Constraint:Stroke(color)
	throwTypeError("color", color, 1, "Color3")

	self.color = color
end
function Constraint:Destroy()
	self._janitor:Cleanup()

	if not self.Parent then
		for i, c in ipairs(self.engine.constraints) do
			if c.id == self.id then
				table.remove(self.engine.constraints, i)
				self.engine.ObjectRemoved:Fire(self)

				break
			end
		end
	end

	self.point1 = nil
	self.point2 = nil
end
function Constraint:GetPoints()
	return self.point1, self.point2
end
function Constraint:GetFrame()
	return self.frame
end
function Constraint:SetSpringConstant(k)
	throwTypeError("springConstant", k, 1, "number")

	self.k = k
end
function Constraint:GetId()
	return self.id
end
function Constraint:GetParent()
	return self.Parent
end

return Constraint
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">118b823fbc6f4004040d84d90000332a</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXbd5001c83148400892bd3456f71c3869">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Point</string>
									<string name="ScriptGuid">{dcec2e17-1abb-4df7-afee-411d89fba8b6}</string>
									<ProtectedString name="Source"><![CDATA[-- #selene: allow(unused_variable)

local Globals = require(script.Parent.Parent.Constants.Globals)
local Types = require(script.Parent.Parent.Types)
local throwTypeError = require(script.Parent.Parent.Debugging.TypeErrors)
local throwException = require(script.Parent.Parent.Debugging.Exceptions)
local Janitor = require(script.Parent.Parent.Utilities.Janitor)
local HttpService = game:GetService("HttpService")
local Point = {}

Point.__index = Point

function Point.new(pos, canvas, engine, config, parent)
	local self = setmetatable({
		id = HttpService:GenerateGUID(false),
		Parent = parent,
		frame = nil,
		_janitor = nil,
		engine = engine,
		canvas = canvas,
		oldPos = pos,
		pos = pos,
		oldForces = Vector2.new(),
		forces = Vector2.new(),
		maxForce = nil,
		gravity = engine.gravity,
		friction = engine.friction,
		airfriction = engine.airfriction,
		bounce = engine.bounce,
		snap = config.snap,
		selectable = config.selectable,
		render = config.render,
		keepInCanvas = config.keepInCanvas,
		color = nil,
		radius = Globals.point.radius,
		timed = {
			start = nil,
			t = nil,
			force = Vector2.new(),
		},
	}, Point)
	local janitor = Janitor.new()

	janitor:Add(self, "Destroy")

	if self.Parent then
		janitor:Add(self.Parent, "Destroy")
	end

	self._janitor = janitor

	return self
end
function Point:ApplyForce(force, t)
	throwTypeError("force", force, 1, "Vector2")

	self.forces += force

	if t then
		throwTypeError("time", t, 2, "number")

		if t <= 0 then
			throwException("error", "INVALID_TIME")
		end

		self.timed.start = os.clock()
		self.timed.t = t
		self.timed.force = force
	end
end
function Point:Update(dt)
	if not self.snap then
		self:ApplyForce(self.gravity)

		if self.timed.start then
			if os.clock() - self.timed.start < self.timed.t then
				self:ApplyForce(self.timed.force)
			else
				self.timed.start = nil
				self.timed.t = nil
				self.timed.force = Vector2.new()
			end
		end

		local velocity = self.pos

		velocity -= self.oldPos
		velocity += self.forces

		local body = self.Parent

		if body and body.Parent then
			local mass = body.Parent.mass

			if mass then
				self.forces /= mass
			end
			if body.Parent.Collisions.CanvasEdge or body.Parent.Collisions.Body then
				velocity *= self.friction
			else
				velocity *= self.airfriction
			end
		else
			velocity *= self.friction
		end
		if self.maxForce then
			velocity = velocity.Unit * math.min(velocity.Magnitude, self.maxForce)
		end

		self.oldPos = self.pos

		self.pos += velocity

		self.oldForces = self.forces

		self.forces *= 0
	end
end
function Point:KeepInCanvas()
	local vx = self.pos.X - self.oldPos.X
	local vy = self.pos.Y - self.oldPos.Y
	local boundX = self.canvas.topLeft.X + self.canvas.size.X
	local boundY = self.canvas.topLeft.Y + self.canvas.size.Y
	local collision = false
	local edge

	if self.pos.Y > boundY then
		self.pos = Vector2.new(self.pos.X, boundY)
		self.oldPos = Vector2.new(self.oldPos.X, self.pos.Y + vy * self.bounce)
		collision = true
		edge = "Bottom"
	elseif self.pos.Y < self.canvas.topLeft.Y then
		self.pos = Vector2.new(self.pos.X, self.canvas.topLeft.Y)
		self.oldPos = Vector2.new(self.oldPos.X, self.pos.Y - vy * self.bounce)
		collision = true
		edge = "Top"
	end
	if self.pos.X < self.canvas.topLeft.X then
		self.pos = Vector2.new(self.canvas.topLeft.X, self.pos.Y)
		self.oldPos = Vector2.new(self.pos.X + vx * self.bounce, self.oldPos.Y)
		collision = true
		edge = "Left"
	elseif self.pos.X > boundX then
		self.pos = Vector2.new(boundX, self.pos.Y)
		self.oldPos = Vector2.new(self.pos.X - vx * self.bounce, self.oldPos.Y)
		collision = true
		edge = "Right"
	end

	local body = self.Parent

	if body and body.Parent then
		if collision then
			local prev = body.Parent.Collisions.CanvasEdge

			body.Parent.Collisions.CanvasEdge = true

			if prev == false then
				body.Parent.CanvasEdgeTouched:Fire(edge)
			end
		else
			body.Parent.Collisions.CanvasEdge = false
		end
	end
end
function Point:Render()
	if self.render then
		if not self.canvas.frame then
			throwException("error", "CANVAS_FRAME_NOT_FOUND")
		end
		if not self.frame then
			local p = Instance.new("Frame")
			local border = Instance.new("UICorner")
			local r = self.radius or Globals.point.radius

			p.AnchorPoint = Vector2.new(0.5, 0.5)
			p.BackgroundColor3 = self.color or Globals.point.color
			p.Size = UDim2.new(0, r * 2, 0, r * 2)
			p.Parent = self.canvas.frame
			border.CornerRadius = Globals.point.uicRadius
			border.Parent = p
			self.frame = p

			self._janitor:Add(self.frame, "Destroy")
		end

		self.frame.Position = UDim2.new(0, self.pos.x, 0, self.pos.y)
	end
	if self.keepInCanvas then
		self:KeepInCanvas()
	end
end
function Point:Destroy()
	self._janitor:Cleanup()

	if not self.Parent then
		for i, c in ipairs(self.engine.points) do
			if c.id == self.id then
				table.remove(self.engine.points, i)
				self.engine.ObjectRemoved:Fire(self)

				break
			end
		end
	end
end
function Point:SetRadius(radius)
	throwTypeError("radius", radius, 1, "number")

	self.radius = radius
end
function Point:Stroke(color)
	throwTypeError("color", color, 1, "Color3")

	self.color = color
end
function Point:Snap(snap)
	throwTypeError("snap", snap, 1, "boolean")

	self.snap = snap
end
function Point:Velocity()
	return self.pos - self.oldPos
end
function Point:GetNetForce()
	return self.oldForces
end
function Point:GetParent()
	return self.Parent
end
function Point:SetPosition(x, y)
	throwTypeError("x", x, 1, "number")
	throwTypeError("y", y, 2, "number")

	local newPosition = Vector2.new(x, y)

	self.oldPos = newPosition
	self.pos = newPosition
end
function Point:SetMaxForce(maxForce)
	throwTypeError("maxForce", maxForce, 1, "number")

	self.maxForce = math.abs(maxForce)
end

return Point
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">118b823fbc6f4004040d84d90000332b</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXb18c73c500354137b99ee146732379b1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">RigidBody</string>
									<string name="ScriptGuid">{8a4d8c0b-c1fa-403f-8482-d92a7b1ca99f}</string>
									<ProtectedString name="Source"><![CDATA[-- #selene: allow(unused_variable)

local Point = require(script.Parent.Point)
local Constraint = require(script.Parent.Constraint)
local Globals = require(script.Parent.Parent.Constants.Globals)
local Signal = require(script.Parent.Parent.Utilities.Signal)
local Types = require(script.Parent.Parent.Types)
local Janitor = require(script.Parent.Parent.Utilities.Janitor)
local throwTypeError = require(script.Parent.Parent.Debugging.TypeErrors)
local throwException = require(script.Parent.Parent.Debugging.Exceptions)
local restrict = require(script.Parent.Parent.Debugging.Restrict)
local HttpService = game:GetService("HttpService")
local RigidBody = {}

RigidBody.__index = RigidBody

local function GetCorners(frame, engine)
	local pos, size = frame.AbsolutePosition, frame.AbsoluteSize
	local rotation = math.rad(frame.Rotation)
	local center = pos + size / 2
	local temp = math.sqrt((size.X / 2) ^ 2 + (size.Y / 2) ^ 2)
	local offset = (engine.path and engine.path.IgnoreGuiInset) and Globals.offset or Vector2.new(0, 0)
	local t = math.atan2(size.Y, size.X)
	local a = rotation + t
	local b = rotation - t

	return {
		center - temp * Vector2.new(math.cos(a), math.sin(a)) + offset,
		center + temp * Vector2.new(math.cos(b), math.sin(b)) + offset,
		center - temp * Vector2.new(math.cos(b), math.sin(b)) + offset,
		center + temp * Vector2.new(math.cos(a), math.sin(a)) + offset,
	}
end
local function CalculatePenetration(minA, maxA, minB, maxB)
	if minA < minB then
		return minB - maxA
	else
		return minA - maxB
	end
end
local function CalculateOffset(pos, anchorPoint, size)
	return (Vector2.new(0.5, 0.5) - anchorPoint) * size
end
local function CalculateCenter(vertices)
	local center = Vector2.new(0, 0)
	local minX = math.huge
	local minY = math.huge
	local maxX = -math.huge
	local maxY = -math.huge

	for _, v in ipairs(vertices) do
		center += v.pos

		minX = math.min(minX, v.pos.x)
		minY = math.min(minY, v.pos.y)
		maxX = math.max(maxX, v.pos.x)
		maxY = math.max(maxY, v.pos.y)
	end

	center /= #vertices

	return center
end
local function CalculateSize(vertices)
	local minX = math.huge
	local minY = math.huge
	local maxX = -math.huge
	local maxY = -math.huge

	for _, v in ipairs(vertices) do
		minX = math.min(minX, v.pos.x)
		minY = math.min(minY, v.pos.y)
		maxX = math.max(maxX, v.pos.x)
		maxY = math.max(maxY, v.pos.y)
	end

	return Vector2.new(maxX - minX, maxY - minY)
end
local function CreateRotationCache(cache, center, vertices)
	table.clear(cache)

	for _, p in ipairs(vertices) do
		local r = (p.pos - center).Magnitude
		local theta = math.atan2(p.pos.Y - center.Y, p.pos.X - center.X)

		table.insert(cache, { r, theta })
	end
end
local function UpdateVertices(frame, vertices, engine)
	local corners = GetCorners(frame, engine)

	for i, vertex in ipairs(vertices) do
		vertex:SetPosition(corners[i].X, corners[i].Y)
	end
end

function RigidBody.new(frame, m, collidable, anchored, engine, custom, structure)
	local isCustom = false

	if custom then
		isCustom = true
	end

	local vertices = isCustom and custom.Vertices or {}
	local edges = isCustom and custom.Edges or {}
	local pointConfig = {
		snap = anchored,
		selectable = false,
		render = false,
		keepInCanvas = true,
	}
	local constraintConfig = {
		restLength = nil,
		render = false,
		thickness = 4,
		support = false,
		TYPE = "ROD",
	}

	local function addPoint(pos)
		local newPoint = Point.new(pos, engine.canvas, engine, pointConfig)

		vertices[#vertices + 1] = newPoint

		return newPoint
	end
	local function addConstraint(p1, p2, support)
		constraintConfig.support = support

		local newConstraint = Constraint.new(p1, p2, engine.canvas, constraintConfig)

		edges[#edges + 1] = newConstraint

		return newConstraint
	end

	if not isCustom then
		local corners = GetCorners(frame, engine)
		local topleft = addPoint(corners[1])
		local topright = addPoint(corners[2])
		local bottomleft = addPoint(corners[3])
		local bottomright = addPoint(corners[4])

		addConstraint(topleft, topright, false)
		addConstraint(topleft, bottomleft, false)
		addConstraint(topright, bottomright, false)
		addConstraint(bottomleft, bottomright, false)
		addConstraint(topleft, bottomright, true)
		addConstraint(topright, bottomleft, true)
	end

	local self = setmetatable({
		id = HttpService:GenerateGUID(false),
		custom = isCustom,
		_janitor = Janitor.new(),
		structure = structure,
		vertices = vertices,
		edges = edges,
		frame = isCustom and nil or frame,
		size = isCustom and CalculateSize(vertices) or nil,
		anchored = anchored,
		mass = m,
		collidable = collidable,
		canRotate = true,
		rotationCache = {},
		center = isCustom and CalculateCenter(vertices) or frame.AbsolutePosition + frame.AbsoluteSize / 2,
		engine = engine,
		spawnedAt = os.clock(),
		lifeSpan = nil,
		anchorRotation = (anchored and not isCustom) and frame.Rotation or nil,
		anchorPos = (anchored and not isCustom) and frame.AbsolutePosition + frame.AbsoluteSize / 2 or nil,
		Touched = nil,
		TouchEnded = nil,
		CanvasEdgeTouched = nil,
		Collisions = {
			Body = false,
			CanvasEdge = false,
			Other = {},
		},
		States = {},
		filtered = {},
	}, RigidBody)

	if engine.path and engine.path.IgnoreGuiInset then
		self.anchorPos = self.anchorPos and self.anchorPos + Globals.offset or nil

		if not self.custom then
			self.center += Globals.offset
		end
	end

	self.Touched = Signal.new()
	self.TouchEnded = Signal.new()
	self.CanvasEdgeTouched = Signal.new()

	for _, edge in ipairs(edges) do
		edge.Parent = self

		edge._janitor:Add(edge.Parent, "Destroy")
		self._janitor:Add(edge, "Destroy")
	end

	self._janitor:Add(self.Touched, "Destroy")
	self._janitor:Add(self.TouchEnded, "Destroy")
	self._janitor:Add(self.CanvasEdgeTouched, "Destroy")

	if not self.custom then
		self._janitor:Add(self.frame, "Destroy")
		self._janitor:LinkToInstance(self.frame)
	end
	if #self.rotationCache < 1 then
		CreateRotationCache(self.rotationCache, self.center, self.vertices)
	end

	return self
end
function RigidBody:CreateProjection(Axis, Min, Max)
	local DotP = Axis:Dot(self.vertices[1].pos)

	Min, Max = DotP, DotP

	for _, v in ipairs(self.vertices) do
		DotP = Axis:Dot(v.pos)
		Min = math.min(DotP, Min)
		Max = math.max(DotP, Max)
	end

	return Min, Max
end
function RigidBody:DetectCollision(other)
	if not self.custom and (not self.frame and not other.frame) then
		return { false, {} }
	end

	self.center = CalculateCenter(self.vertices)

	local minDist = math.huge
	local collision = {
		axis = nil,
		depth = nil,
		edge = nil,
		vertex = nil,
	}

	for i = 1, #self.edges + #other.edges, 1 do
		local edge = i <= #self.edges and self.edges[i] or other.edges[i - #self.edges]

		if not edge.support then
			local axis = Vector2.new(edge.point1.pos.Y - edge.point2.pos.Y, edge.point2.pos.X - edge.point1.pos.X).Unit
			local MinA, MinB, MaxA, MaxB

			MinA, MaxA = self:CreateProjection(axis, MinA, MaxA)
			MinB, MaxB = other:CreateProjection(axis, MinB, MaxB)

			local dist = CalculatePenetration(MinA, MaxA, MinB, MaxB)

			if dist > 0 then
				return { false, {} }
			elseif math.abs(dist) < minDist then
				minDist = math.abs(dist)
				collision.axis = axis
				collision.edge = edge
			end
		end
	end

	collision.depth = minDist

	if collision.edge and collision.edge.Parent ~= other then
		local Temp = other

		other = self
		self = Temp
	end

	local centerDif = self.center - other.center
	local dot = collision.axis:Dot(centerDif)

	if dot < 0 then
		collision.axis *= -1
	end

	local minMag = math.huge

	for i = 1, #self.vertices, 1 do
		local dif = self.vertices[i].pos - other.center
		local dist = collision.axis:Dot(dif)

		if dist < minMag then
			minMag = dist
			collision.vertex = self.vertices[i]
		end
	end

	return { true, collision }
end
function RigidBody:ApplyForce(force, t)
	throwTypeError("force", force, 1, "Vector2")

	if t then
		throwTypeError("time", t, 2, "number")

		if t <= 0 then
			throwException("error", "INVALID_TIME")
		end
	end

	for _, v in ipairs(self.vertices) do
		v:ApplyForce(force, t)
	end
end
function RigidBody:Update(dt)
	self.center = CalculateCenter(self.vertices)

	for i, vertex in ipairs(self.vertices) do
		if not self.canRotate then
			local info = self.rotationCache[i]
			local r = info[1]
			local t = info[2]

			vertex:ApplyForce((self.center + Vector2.new(math.cos(t), math.sin(t)) * r) - vertex.pos)
		end

		vertex:Update(dt)
		vertex:Render()
	end
	for _, edge in ipairs(self.edges) do
		for i = 1, self.engine.iterations.constraint do
			edge:Constrain()
		end

		edge:Render()
	end
end
function RigidBody:Render()
	if self.lifeSpan and os.clock() - self.spawnedAt >= self.lifeSpan then
		self:Destroy()
	end
	if self.custom then
		return
	end
	if self.anchored then
		local anchorPos = self.anchorPos
			- CalculateOffset(self.anchorPos, self.frame.AnchorPoint, self.frame.AbsoluteSize)

		self.frame.Position = UDim2.fromOffset(anchorPos.X, anchorPos.Y)

		if self.canRotate then
			self:Rotate(self.anchorRotation)
		end
	else
		local center = self.center - CalculateOffset(self.center, self.frame.AnchorPoint, self.frame.AbsoluteSize)
		local dif = self.vertices[2].pos - self.vertices[1].pos

		self.frame.Position = UDim2.new(0, center.X, 0, center.Y)

		if self.canRotate then
			self.frame.Rotation = math.deg(math.atan2(dif.Y, dif.X))
		end
	end
end
function RigidBody:Clone(deepCopy)
	if not self.custom and not self.frame then
		return
	end
	if not self.engine then
		return
	end

	local frame

	if not self.custom then
		frame = self.frame:Clone()
		frame.Parent = self.frame.Parent
	end

	local copy = self.engine:Create("RigidBody", {
		Mass = self.mass,
		Object = frame,
		Structure = self.custom and self.structure or nil,
		Anchored = self.anchored,
		Collidable = self.collidable,
	})

	if deepCopy == true then
		copy.States = self.States

		if self.lifeSpan then
			copy:SetLifeSpan(self.lifeSpan)
		end

		for _, body in ipairs(self.filtered) do
			copy:FilterCollisionsWith(body)
		end
	end

	return copy
end
function RigidBody:Destroy(keepFrame)
	self._janitor:Cleanup()

	for i, body in ipairs(self.engine.bodies) do
		if self.id == body.id then
			table.clear(self.Collisions.Other)
			table.remove(self.engine.bodies, i)
			self.engine.ObjectRemoved:Fire(self)

			break
		end
	end

	table.clear(self.vertices)
	table.clear(self.edges)
end
function RigidBody:Rotate(newRotation)
	throwTypeError("newRotation", newRotation, 1, "number")

	if self.anchored and self.anchorRotation then
		self.anchorRotation = newRotation
	end

	local oldRotation

	if self.custom then
		local dif = self.vertices[2].pos - self.vertices[1].pos

		oldRotation = math.deg(math.atan2(dif.Y, dif.X))

		local tempRotationCache = {}

		CreateRotationCache(tempRotationCache, self.center, self.vertices)

		for i, info in ipairs(tempRotationCache) do
			local r = info[1]
			local t = info[2] + math.rad(newRotation)
			local v = self.vertices[i]

			v.pos = self.center + Vector2.new(math.cos(t), math.sin(t)) * r
			v.oldPos = v.pos
		end
	else
		oldRotation = self.frame.Rotation

		local offset = CalculateOffset(self.anchorPos, self.frame.AnchorPoint, self.frame.AbsoluteSize)
		local position = self.anchorPos - offset

		self.frame.Position = self.anchored and UDim2.fromOffset(position.X, position.Y)
			or UDim2.fromOffset(self.center.x, self.center.y)
		self.frame.Rotation = newRotation

		UpdateVertices(self.frame, self.vertices, self.engine)
	end

	return oldRotation, newRotation
end
function RigidBody:SetPosition(PositionX, PositionY)
	throwTypeError("PositionX", PositionX, 1, "number")
	throwTypeError("PositionY", PositionY, 2, "number")

	if self.anchored and self.anchorPos then
		self.anchorPos = Vector2.new(PositionX, PositionY)
	end

	local oldPosition

	if self.custom then
		oldPosition = UDim2.fromOffset(self.center.X, self.center.Y)

		local tempRotationCache = {}

		CreateRotationCache(tempRotationCache, self.center, self.vertices)

		self.center = Vector2.new(PositionX, PositionY)

		for i, info in ipairs(tempRotationCache) do
			local r = info[1]
			local t = info[2]
			local v = self.vertices[i]

			v.pos = self.center + Vector2.new(math.cos(t), math.sin(t)) * r
			v.oldPos = v.pos
		end
	else
		oldPosition = self.frame.Position
		self.frame.Position = UDim2.fromOffset(PositionX, PositionY)

		UpdateVertices(self.frame, self.vertices, self.engine)
	end

	return oldPosition, UDim2.fromOffset(PositionX, PositionY)
end
function RigidBody:SetSize(SizeX, SizeY)
	restrict(self.custom)
	throwTypeError("SizeX", SizeX, 1, "number")
	throwTypeError("SizeY", SizeY, 2, "number")

	local oldSize = self.frame.Size

	self.frame.Size = UDim2.fromOffset(SizeX, SizeY)

	UpdateVertices(self.frame, self.vertices, self.engine)

	for _, edge in ipairs(self.edges) do
		edge.restLength = (edge.point2.pos - edge.point1.pos).Magnitude
	end

	return oldSize, UDim2.fromOffset(SizeX, SizeY)
end
function RigidBody:SetScale(scale)
	if not self.custom then
		return
	end

	throwTypeError("scale", scale, 1, "number")

	scale = math.max(0.00001, scale)

	for i, info in ipairs(self.rotationCache) do
		local r = info[1] * scale
		local t = info[2]
		local v = self.vertices[i]

		v.pos = self.center + Vector2.new(math.cos(t), math.sin(t)) * r
		v.oldPos = v.pos
	end
	for _, edge in ipairs(self.edges) do
		edge.restLength = (edge.point2.pos - edge.point1.pos).Magnitude
	end
end
function RigidBody:Anchor()
	self.anchored = true
	self.anchorRotation = self.frame and self.frame.Rotation or nil
	self.anchorPos = self.center

	for _, vertex in ipairs(self.vertices) do
		if not vertex.selectable then
			vertex.snap = self.anchored
		end
	end
end
function RigidBody:Unanchor()
	self.anchored = false
	self.anchorRotation = nil
	self.anchorPos = nil

	for _, vertex in ipairs(self.vertices) do
		if not vertex.selectable then
			vertex.snap = self.anchored
		end
	end
end
function RigidBody:CanCollide(collidable)
	throwTypeError("collidable", collidable, 1, "boolean")

	self.collidable = collidable
end
function RigidBody:CanRotate(canRotate)
	restrict(self.custom)
	throwTypeError("canRotate", canRotate, 1, "boolean")

	self.canRotate = canRotate

	CreateRotationCache(self.rotationCache, self.center, self.vertices)
end
function RigidBody:GetFrame()
	return self.frame
end
function RigidBody:GetId()
	return self.id
end
function RigidBody:GetVertices()
	return self.vertices
end
function RigidBody:GetConstraints()
	return self.edges
end
function RigidBody:SetLifeSpan(seconds)
	throwTypeError("seconds", seconds, 1, "number")

	self.lifeSpan = seconds
end
function RigidBody:KeepInCanvas(keepInCanvas)
	throwTypeError("keepInCanvas", keepInCanvas, 1, "boolean")

	for _, p in ipairs(self.vertices) do
		p.keepInCanvas = keepInCanvas
	end
end
function RigidBody:SetFriction(friction)
	throwTypeError("friction", friction, 1, "number")

	for _, p in ipairs(self.vertices) do
		p.friction = math.clamp(1 - friction, 0, 1)
	end
end
function RigidBody:SetAirFriction(friction)
	throwTypeError("friction", friction, 1, "number")

	for _, p in ipairs(self.vertices) do
		p.airfriction = math.clamp(1 - friction, 0, 1)
	end
end
function RigidBody:SetGravity(force)
	throwTypeError("force", force, 1, "Vector2")

	for _, p in ipairs(self.vertices) do
		p.gravity = force
	end
end
function RigidBody:SetMass(mass)
	if self.mass ~= mass and mass >= 1 then
		self.mass = mass
	end
end
function RigidBody:IsInBounds()
	local canvas = self.engine.canvas

	if not canvas then
		return false
	end

	for _, v in ipairs(self.vertices) do
		local pos = v.pos

		if
			not (
				(pos.X >= canvas.topLeft.X and pos.X <= canvas.topLeft.X + canvas.size.X)
				and (pos.Y >= canvas.topLeft.Y and pos.Y <= canvas.topLeft.Y + canvas.size.Y)
			)
		then
			return false
		end
	end

	return true
end
function RigidBody:AverageVelocity()
	local sum = Vector2.new(0, 0)

	for _, v in ipairs(self.vertices) do
		sum += v:Velocity()
	end

	return sum / #self.vertices
end
function RigidBody:SetState(state, value)
	throwTypeError("state", state, 1, "string")

	if self.States[state] == value then
		return
	end

	self.States[state] = value
end
function RigidBody:GetState(state)
	throwTypeError("state", state, 1, "string")

	return self.States[state]
end
function RigidBody:GetCenter()
	return self.center
end
function RigidBody:FilterCollisionsWith(otherBody)
	if not otherBody.id or not typeof(otherBody.id) == "string" or not otherBody.filtered then
		throwException("error", "INVALID_RIGIDBODY")
	end
	if otherBody.id == self.id then
		throwException("error", "SAME_ID")
	end
	if not table.find(self.filtered, otherBody.id) then
		table.insert(self.filtered, otherBody.id)
		table.insert(otherBody.filtered, self.id)
	end
end
function RigidBody:UnfilterCollisionsWith(otherBody)
	if not otherBody.id or not typeof(otherBody.id) == "string" or not otherBody.filtered then
		throwException("error", "INVALID_RIGIDBODY")
	end
	if otherBody.id == self.id then
		throwException("error", "SAME_ID")
	end

	local i1 = table.find(self.filtered, otherBody.id)
	local i2 = table.find(otherBody.filtered, self.id)

	if i1 and i2 then
		table.remove(self.filtered, i1)
		table.remove(otherBody.filtered, i2)
	end
end
function RigidBody:GetFilteredRigidBodies()
	return self.filtered
end
function RigidBody:GetTouchingRigidBodies()
	return self.Collisions.Other
end
function RigidBody:SetMaxForce(maxForce)
	throwTypeError("maxForce", maxForce, 1, "number")

	for _, p in ipairs(self.vertices) do
		p:SetMaxForce(maxForce)
	end
end

return RigidBody
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">118b823fbc6f4004040d84d90000332c</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX82ebe20fa73443d19c70305e3f9a0048">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Runner</string>
									<string name="ScriptGuid">{d379a6f9-d961-49f5-8f71-2dde9468ea69}</string>
									<ProtectedString name="Source"><![CDATA[-- #selene: allow(unused_variable)

local Types = require(script.Parent.Parent.Types)
local Quadtree = require(script.Parent.Parent.Utilities.Quadtree)

local function SearchTable(t, a, lambda)
	for _, v in ipairs(t) do
		if lambda(a, v) then
			return v
		end
	end

	return nil
end

local Runner = {}

function Runner.CollisionResponse(body, other, isColliding, Collision, dt, oldCollidingWith, iteration)
	if not isColliding then
		return
	end
	if iteration == 1 and body.Touched._handlerListHead and body.Touched._handlerListHead.Connected then
		if not SearchTable(oldCollidingWith, other, function(a, b)
			return a.id == b.id
		end) then
			body.Touched:Fire(other.id, Collision)
		end
	end

	local penetration = Collision.axis * Collision.depth
	local p1 = Collision.edge.point1
	local p2 = Collision.edge.point2
	local t

	if not p1 or not p2 then
		return
	end

	if math.abs(p1.pos.X - p2.pos.X) > math.abs(p1.pos.Y - p2.pos.Y) then
		t = (Collision.vertex.pos.X - penetration.X - p1.pos.X) / (p2.pos.X - p1.pos.X)
	else
		t = (Collision.vertex.pos.Y - penetration.Y - p1.pos.Y) / (p2.pos.Y - p1.pos.Y)
	end

	local factor = 1 / (t ^ 2 + (1 - t) ^ 2)
	local bodyMass = Collision.edge.Parent.mass
	local m = t * bodyMass + (1 - t) * bodyMass
	local cMass = 1 / (m + Collision.vertex.Parent.Parent.mass)
	local r1 = Collision.vertex.Parent.Parent.mass * cMass
	local r2 = m * cMass

	if not Collision.edge.Parent.anchored then
		p1.pos -= penetration * ((1 - t) * factor * r1)
		p2.pos -= penetration * (t * factor * r1)
	end
	if not Collision.vertex.Parent.Parent.anchored then
		Collision.vertex.pos += penetration * r2
	end
end
function Runner.Update(self, dt)
	local tree

	if self.quadtrees then
		tree = Quadtree.new(self.canvas.topLeft, self.canvas.size, 4)

		for _, body in ipairs(self.bodies) do
			if body.collidable then
				tree:Insert(body)
			end
		end
	else
		if self.iterations.collision ~= 1 then
			self.iterations.collision = 1
		end
	end

	for _, body in ipairs(self.bodies) do
		body:Update(dt)

		local OldCollidingWith = body.Collisions.Other
		local CollidingWith = {}

		if body.collidable then
			local filtered = self.bodies

			if self.quadtrees then
				local abs = body.custom and body.size or body.frame.AbsoluteSize
				local side = abs.X > abs.Y and abs.X or abs.Y
				local range = {
					position = body.center - Vector2.new(side * 1.5, side * 1.5),
					size = Vector2.new(side * 3, side * 3),
				}

				filtered = tree:Search(range, {})
			end

			for _, other in ipairs(filtered) do
				if body.id ~= other.id and other.collidable and not table.find(body.filtered, other.id) then
					local result, isColliding, Collision, didCollide

					for i = 1, self.iterations.collision do
						result = body:DetectCollision(other)
						isColliding = result[1]
						Collision = result[2]

						if i == 1 and not isColliding then
							break
						end

						didCollide = true

						Runner.CollisionResponse(body, other, isColliding, Collision, dt, OldCollidingWith, i)
					end

					if didCollide then
						body.Collisions.Body = true
						other.Collisions.Body = true

						table.insert(CollidingWith, other)
					else
						body.Collisions.Body = false
						other.Collisions.Body = false

						if body.TouchEnded._handlerListHead and body.TouchEnded._handlerListHead.Connected then
							if
								SearchTable(OldCollidingWith, other, function(a, b)
									return a.id == b.id
								end)
							then
								body.TouchEnded:Fire(other.id)
							end
						end
					end
				end
			end
		end

		body.Collisions.Other = CollidingWith
	end

	if #self.points > 0 then
		for _, point in ipairs(self.points) do
			point:Update(dt)
		end
	end
	if #self.constraints > 0 then
		for _, constraint in ipairs(self.constraints) do
			if constraint._TYPE ~= "SPRING" then
				for i = 1, self.iterations.constraint do
					constraint:Constrain()
				end
			else
				constraint:Constrain()
			end
		end
	end

	self.Updated:Fire()
end
function Runner.Render(self)
	for _, body in ipairs(self.bodies) do
		body:Render()
	end
	for _, point in ipairs(self.points) do
		point:Render()
	end
	for _, constraint in ipairs(self.constraints) do
		constraint:Render()
	end
end

return Runner
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">118b823fbc6f4004040d84d90000332d</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX07c21e7ba9aa4c92a9f83968ce540aa6">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Plugins</string>
								<string name="ScriptGuid">{c0115f22-82e8-4426-8b1b-71f4585bd4ba}</string>
								<ProtectedString name="Source"><![CDATA[return {
	MouseConstraint = require(script.MouseConstraint),
	Quad = require(script.Quad),
	Triangle = require(script.Triangle),
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d90000332e</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXa113bbcfb1c542cea61f93f37495c72b">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">MouseConstraint</string>
									<string name="ScriptGuid">{e6305d23-c6e6-46de-bef4-9acb454158a5}</string>
									<ProtectedString name="Source"><![CDATA[local UserInputService = game:GetService("UserInputService")

return function(engine, range)
	local held = nil
	local connections = {}

	connections.InputBegan = UserInputService.InputBegan:Connect(function(input, processedEvent)
		if processedEvent then
			return
		end
		if input.UserInputType == Enum.UserInputType.MouseButton1 and not held then
			for _, b in ipairs(engine.bodies) do
				for _, p in ipairs(b.vertices) do
					if (p.pos - UserInputService:GetMouseLocation()).Magnitude <= range then
						p.selectable = true
						p.snap = true
						held = p

						break
					end
				end

				if held then
					break
				end
			end
		end
	end)
	connections.InputEnded = UserInputService.InputEnded:Connect(function(input, processedEvent)
		if processedEvent then
			return
		end
		if input.UserInputType == Enum.UserInputType.MouseButton1 and held then
			held.selectable = false
			held.snap = false
			held = nil
		end
	end)
	connections.InputChanged = UserInputService.InputChanged:Connect(function(input, processedEvent)
		if processedEvent then
			return
		end
		if input.UserInputType == Enum.UserInputType.MouseMovement and held then
			local mouse = UserInputService:GetMouseLocation()

			held:SetPosition(mouse.X, mouse.Y)
		end
	end)

	return function()
		held.snap = false
		held = nil

		connections.InputBegan:Disconnect()
		connections.InputEnded:Disconnect()
		connections.InputChanged:Disconnect()
	end
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">118b823fbc6f4004040d84d90000332f</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX62c335b9a0834eb6a7a78a6ce4a4571b">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Quad</string>
									<string name="ScriptGuid">{38e0bab7-ba0b-48f1-bd72-081efe2b47d0}</string>
									<ProtectedString name="Source"><![CDATA[return function(a, b, c, d)
	return {
		{ a, b, false },
		{ b, c, false },
		{ c, d, false },
		{ d, a, false },
		{ a, c, true },
		{ b, d, true },
	}
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003330</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6c6787425e1f428f80aa58a8284ed3f2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Triangle</string>
									<string name="ScriptGuid">{9c185bc3-af61-4564-8458-3d551eded501}</string>
									<ProtectedString name="Source"><![CDATA[return function(a, b, c)
	return {
		{ a, b, false },
		{ a, c, false },
		{ b, c, false },
	}
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003331</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXa59428c3be62415081d577caa3f064cf">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Types</string>
								<string name="ScriptGuid">{224f254e-03c6-4a63-8f26-5b47afe6b3cb}</string>
								<ProtectedString name="Source"><![CDATA[return nil
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003332</UniqueId>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX6992e30bfc6c4f3aad1fa0e2f0d0934b">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">Utilities</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003333</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX8ccc56adbfc549b391a93ade88a133df">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Janitor</string>
									<string name="ScriptGuid">{f805b2ec-5646-42bb-ac01-743ab086f445}</string>
									<ProtectedString name="Source"><![CDATA[local GetPromiseLibrary = require(script.GetPromiseLibrary)
local Symbol = require(script.Symbol)
local FoundPromiseLibrary, Promise = GetPromiseLibrary()
local IndicesReference = Symbol("IndicesReference")
local LinkToInstanceIndex = Symbol("LinkToInstanceIndex")
local METHOD_NOT_FOUND_ERROR = [[Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s]]
local NOT_A_PROMISE = [[Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s))]]
local Janitor = {}

Janitor.ClassName = "Janitor"
Janitor.CurrentlyCleaning = true
Janitor[IndicesReference] = nil
Janitor.__index = Janitor

local TypeDefaults = {
	["function"] = true,
	RBXScriptConnection = "Disconnect",
}

function Janitor.Is(Object)
	return type(Object) == "table" and getmetatable(Object) == Janitor
end
function Janitor:Add(Object, MethodName, Index)
	if Index then
		self:Remove(Index)

		local This = self[IndicesReference]

		if not This then
			This = {}
			self[IndicesReference] = This
		end

		This[Index] = Object
	end

	MethodName = MethodName or TypeDefaults[typeof(Object)] or "Destroy"

	if type(Object) ~= "function" and not Object[MethodName] then
		warn(string.format(METHOD_NOT_FOUND_ERROR, tostring(Object), tostring(MethodName), debug.traceback(nil, 2)))
	end

	self[Object] = MethodName

	return Object
end
function Janitor:AddPromise(PromiseObject)
	if FoundPromiseLibrary then
		if not Promise.is(PromiseObject) then
			error(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject)))
		end
		if PromiseObject:getStatus() == Promise.Status.Started then
			local Id = newproxy(false)
			local NewPromise = self:Add(
				Promise.new(function(Resolve, _, OnCancel)
					if OnCancel(function()
						PromiseObject:cancel()
					end) then
						return
					end

					Resolve(PromiseObject)
				end),
				"cancel",
				Id
			)

			NewPromise:finallyCall(self.Remove, self, Id)

			return NewPromise
		else
			return PromiseObject
		end
	else
		return PromiseObject
	end
end
function Janitor:Remove(Index)
	local This = self[IndicesReference]

	if This then
		local Object = This[Index]

		if Object then
			local MethodName = self[Object]

			if MethodName then
				if MethodName == true then
					Object()
				else
					local ObjectMethod = Object[MethodName]

					if ObjectMethod then
						ObjectMethod(Object)
					end
				end

				self[Object] = nil
			end

			This[Index] = nil
		end
	end

	return self
end
function Janitor:Get(Index)
	local This = self[IndicesReference]

	if This then
		return This[Index]
	else
		return nil
	end
end

local function GetFenv(self)
	return function()
		for Object, MethodName in pairs(self) do
			if Object ~= IndicesReference then
				return Object, MethodName
			end
		end
	end
end

function Janitor:Cleanup()
	if not self.CurrentlyCleaning then
		self.CurrentlyCleaning = nil

		local Get = GetFenv(self)
		local Object, MethodName = Get()

		while Object and MethodName do
			if MethodName == true then
				Object()
			else
				local ObjectMethod = Object[MethodName]

				if ObjectMethod then
					ObjectMethod(Object)
				end
			end

			self[Object] = nil
			Object, MethodName = Get()
		end

		local This = self[IndicesReference]

		if This then
			table.clear(This)

			self[IndicesReference] = {}
		end

		self.CurrentlyCleaning = false
	end
end
function Janitor:Destroy()
	self:Cleanup()
	table.clear(self)
	setmetatable(self, nil)
end

Janitor.__call = Janitor.Cleanup

local RbxScriptConnection = {}

RbxScriptConnection.Connected = true
RbxScriptConnection.__index = RbxScriptConnection

function RbxScriptConnection:Disconnect()
	if self.Connected then
		self.Connected = false

		self.Connection:Disconnect()
	end
end
function RbxScriptConnection._new(RBXScriptConnection)
	return setmetatable({ Connection = RBXScriptConnection }, RbxScriptConnection)
end
function RbxScriptConnection:__tostring()
	return "RbxScriptConnection<" .. tostring(self.Connected) .. ">"
end
function Janitor:LinkToInstance(Object, AllowMultiple)
	local Connection
	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex
	local IsNilParented = Object.Parent == nil
	local ManualDisconnect = setmetatable({}, RbxScriptConnection)

	local function ChangedFunction(_DoNotUse, NewParent)
		if ManualDisconnect.Connected then
			_DoNotUse = nil
			IsNilParented = NewParent == nil

			if IsNilParented then
				task.defer(function()
					if not ManualDisconnect.Connected then
						return
					elseif not Connection.Connected then
						self:Cleanup()
					else
						while IsNilParented and Connection.Connected and ManualDisconnect.Connected do
							task.wait()
						end

						if ManualDisconnect.Connected and IsNilParented then
							self:Cleanup()
						end
					end
				end)
			end
		end
	end

	Connection = Object.AncestryChanged:Connect(ChangedFunction)
	ManualDisconnect.Connection = Connection

	if IsNilParented then
		ChangedFunction(nil, Object.Parent)
	end

	Object = nil

	return self:Add(ManualDisconnect, "Disconnect", IndexToUse)
end
function Janitor:LinkToInstances(...)
	local ManualCleanup = Janitor.new()

	for _, Object in ipairs({ ... }) do
		ManualCleanup:Add(self:LinkToInstance(Object, true), "Disconnect")
	end

	return ManualCleanup
end
function Janitor.new()
	return setmetatable({
		CurrentlyCleaning = false,
		[IndicesReference] = nil,
	}, Janitor)
end

return Janitor
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003334</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBXca2d6783c8134a2daeb0893856ce00c6">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">GetPromiseLibrary</string>
										<string name="ScriptGuid">{0f2a7cad-657f-4cce-81e8-22705faf8a75}</string>
										<ProtectedString name="Source"><![CDATA[local ReplicatedFirst = game:GetService("ReplicatedFirst")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local ServerStorage = game:GetService("ServerStorage")
local LOCATIONS_TO_SEARCH = {
	script.Parent.Parent,
	ReplicatedFirst,
	ReplicatedStorage,
	ServerScriptService,
	ServerStorage,
}

local function FindFirstDescendantWithNameAndClassName(Parent, Name, ClassName)
	for _, Descendant in ipairs(Parent:GetDescendants()) do
		if Descendant:IsA(ClassName) and Descendant.Name == Name then
			return Descendant
		end
	end

	return nil
end
local function GetPromiseLibrary()
	local Plugin = script:FindFirstAncestorOfClass("Plugin")

	if Plugin then
		local Promise = FindFirstDescendantWithNameAndClassName(Plugin, "Promise", "ModuleScript")

		if Promise then
			return true, require(Promise)
		else
			return false
		end
	end

	local Promise

	for _, Location in ipairs(LOCATIONS_TO_SEARCH) do
		Promise = FindFirstDescendantWithNameAndClassName(Location, "Promise", "ModuleScript")

		if Promise then
			break
		end
	end

	if Promise then
		return true, require(Promise)
	else
		return false
	end
end

return GetPromiseLibrary
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003335</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX9de5efb37a7441bea092c4f90ce22c83">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Symbol</string>
										<string name="ScriptGuid">{972b9285-3b00-49ff-890e-7b562766ab48}</string>
										<ProtectedString name="Source"><![CDATA[local function Symbol(Name)
	local self = newproxy(true)
	local Metatable = getmetatable(self)

	function Metatable.__tostring()
		return Name
	end

	return self
end

return Symbol
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003336</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBXb3e71120ea874dc3922cd145d24ff748">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Line</string>
									<string name="ScriptGuid">{1c7e451d-38ae-449f-8968-70ae62223f5c}</string>
									<ProtectedString name="Source"><![CDATA[local Globals = require(script.Parent.Parent.Constants.Globals)

local function draw(hyp, origin, thickness, parent, color, l, image)
	local line = l or (image and Instance.new("ImageLabel") or Instance.new("Frame"))

	line.Name = "Constraint"
	line.AnchorPoint = Vector2.new(0.5, 0.5)
	line.Size = UDim2.new(0, hyp, 0, (thickness or Globals.constraint.thickness) + (image and 15 or 0))
	line.BackgroundTransparency = image and 1 or 0
	line.BorderSizePixel = 0
	line.Position = UDim2.fromOffset(origin.X, origin.Y)
	line.ZIndex = 1

	if image then
		line.Image = image
		line.ImageColor3 = color or Globals.constraint.color
	else
		line.BackgroundColor3 = color or Globals.constraint.color
	end

	line.Parent = parent

	return line
end

return function(origin, endpoint, parent, thickness, color, l, image)
	local hyp = (endpoint - origin).Magnitude
	local line = draw(hyp, origin, thickness, parent, color, l, image)
	local mid = (origin + endpoint) / 2
	local theta = math.atan2((origin - endpoint).Y, (origin - endpoint).X)

	line.Position = UDim2.fromOffset(mid.x, mid.y)
	line.Rotation = math.deg(theta)

	return line
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003337</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX80cb6ab20f1246028c8c26d85b8acf66">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Quadtree</string>
									<string name="ScriptGuid">{e4e89ca4-951b-4265-9872-be8a819410c0}</string>
									<ProtectedString name="Source"><![CDATA[-- #selene: allow(unused_variable)

local Types = require(script.Parent.Parent.Types)
local Quadtree = {}

Quadtree.__index = Quadtree

local function GetDivisions(position, size)
	return {
		position,
		position + Vector2.new(size.X / 2, 0),
		position + Vector2.new(0, size.Y / 2),
		position + Vector2.new(size.X / 2, size.Y / 2),
	}
end
local function RangeOverlapsNode(node, range)
	local ap1 = range.position
	local as1 = range.size
	local sum = ap1 + as1
	local ap2 = node.position
	local as2 = node.size
	local sum2 = ap2 + as2

	return (ap1.x < sum2.x and sum.x > ap2.x) and (ap1.y < sum2.y and sum.y > ap2.y)
end
local function RangeHasPoint(range, obj)
	local p = obj.center

	return (
		(p.X > range.position.X)
		and (p.X < (range.position.X + range.size.X))
		and (p.Y > range.position.Y)
		and (p.Y < (range.position.Y + range.size.Y))
	)
end
local function merge(array1, array2)
	if #array2 > 0 then
		for _, v in ipairs(array2) do
			table.insert(array1, v)
		end
	end

	return array1
end

function Quadtree.new(_position, _size, _capacity)
	return setmetatable({
		position = _position,
		size = _size,
		capacity = _capacity,
		objects = {},
		divided = false,
	}, Quadtree)
end
function Quadtree:Insert(body)
	if not self:HasObject(body.center) then
		return
	end
	if #self.objects < self.capacity then
		self.objects[#self.objects + 1] = body
	else
		if not self.divided then
			self:SubDivide()

			self.divided = true
		end

		self.topLeft:Insert(body)
		self.topRight:Insert(body)
		self.bottomLeft:Insert(body)
		self.bottomRight:Insert(body)
	end
end
function Quadtree:HasObject(p)
	return (
		(p.X > self.position.X)
		and (p.X < (self.position.X + self.size.X))
		and (p.Y > self.position.Y)
		and (p.Y < (self.position.Y + self.size.Y))
	)
end
function Quadtree:SubDivide()
	local divisions = GetDivisions(self.position, self.size)

	self.topLeft = Quadtree.new(divisions[1], self.size / 2, self.capacity)
	self.topRight = Quadtree.new(divisions[2], self.size / 2, self.capacity)
	self.bottomLeft = Quadtree.new(divisions[3], self.size / 2, self.capacity)
	self.bottomRight = Quadtree.new(divisions[4], self.size / 2, self.capacity)
end
function Quadtree:Search(range, objects)
	if not objects then
		objects = {}
	end
	if not RangeOverlapsNode(self, range) then
		return objects
	end

	for _, obj in ipairs(self.objects) do
		if RangeHasPoint(range, obj) then
			objects[#objects + 1] = obj
		end
	end

	if self.divided then
		self.topLeft:Search(range, objects)
		self.topRight:Search(range, objects)
		self.bottomLeft:Search(range, objects)
		self.bottomRight:Search(range, objects)
	end

	return objects
end

return Quadtree
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003338</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXee000fb8b8124637b40692a4e6bea5ce">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Signal</string>
									<string name="ScriptGuid">{a3986d9e-5d0c-4d6c-aa4a-5951a1f277c3}</string>
									<ProtectedString name="Source"><![CDATA[local freeRunnerThread = nil

local function acquireRunnerThreadAndCallEventHandler(fn, ...)
    local acquiredRunnerThread = freeRunnerThread

    freeRunnerThread = nil

    fn(...)

    freeRunnerThread = acquiredRunnerThread
end
local function runEventHandlerInFreeThread(...)
    acquireRunnerThreadAndCallEventHandler(...)

    while true do
        acquireRunnerThreadAndCallEventHandler(coroutine.yield())
    end
end

local Connection = {}

Connection.__index = Connection

function Connection.new(signal, fn)
    return setmetatable({
        Connected = true,
        _signal = signal,
        _fn = fn,
        _next = false,
    }, Connection)
end
function Connection:Disconnect()
    if not self.Connected then
        return
    end

    self.Connected = false

    if self._signal._handlerListHead == self then
        self._signal._handlerListHead = self._next
    else
        local prev = self._signal._handlerListHead

        while prev and prev._next ~= self do
            prev = prev._next
        end

        if prev then
            prev._next = self._next
        end
    end
end

Connection.Destroy = Connection.Disconnect

setmetatable(Connection, {
    __index = function(_tb, key)
        if key ~= '_handlerListHead' then
            error(('Attempt to get Connection::%s (not a valid member)'):format(tostring(key)), 2)
        end
    end,
    __newindex = function(_tb, key, _value)
        error(('Attempt to set Connection::%s (not a valid member)'):format(tostring(key)), 2)
    end,
})

local Signal = {}

Signal.__index = Signal

function Signal.new()
    local self = setmetatable({
        _handlerListHead = false,
        _proxyHandler = nil,
    }, Signal)

    return self
end
function Signal.Wrap(rbxScriptSignal)
    assert(typeof(rbxScriptSignal) == 'RBXScriptSignal', 'Argument #1 to Signal.Wrap must be a RBXScriptSignal; got ' .. typeof(rbxScriptSignal))

    local signal = Signal.new()

    signal._proxyHandler = rbxScriptSignal:Connect(function(...)
        signal:Fire(...)
    end)

    return signal
end
function Signal.Is(obj)
    return type(obj) == 'table' and getmetatable(obj) == Signal
end
function Signal:Connect(fn)
    local connection = Connection.new(self, fn)

    if self._handlerListHead then
        connection._next = self._handlerListHead
        self._handlerListHead = connection
    else
        self._handlerListHead = connection
    end

    return connection
end
function Signal:GetConnections()
    local items = {}
    local item = self._handlerListHead

    while item do
        table.insert(items, item)

        item = item._next
    end

    return items
end
function Signal:DisconnectAll()
    local item = self._handlerListHead

    while item do
        item.Connected = false
        item = item._next
    end

    self._handlerListHead = false
end
function Signal:Fire(...)
    local item = self._handlerListHead

    while item do
        if item.Connected then
            if not freeRunnerThread then
                freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
            end

            task.spawn(freeRunnerThread, item._fn, ...)
        end

        item = item._next
    end
end
function Signal:FireDeferred(...)
    local item = self._handlerListHead

    while item do
        task.defer(item._fn, ...)

        item = item._next
    end
end
function Signal:Wait()
    local waitingCoroutine = coroutine.running()
    local cn

    cn = self:Connect(function(...)
        cn:Disconnect()
        task.spawn(waitingCoroutine, ...)
    end)

    return coroutine.yield()
end
function Signal:Destroy()
    self:DisconnectAll()

    local proxyHandler = rawget(self, '_proxyHandler')

    if proxyHandler then
        proxyHandler:Disconnect()
    end
end

setmetatable(Signal, {
    __index = function(_tb, key)
        if key ~= 'Connected' then
            error(('Attempt to get Signal::%s (not a valid member)'):format(tostring(key)), 2)
        end
    end,
    __newindex = function(_tb, key, _value)
        error(('Attempt to set Signal::%s (not a valid member)'):format(tostring(key)), 2)
    end,
})

return Signal
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003339</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXe2bce897761b4778aba69868bc247571">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">Constants</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003390</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXcc63c587fa1146078e337b9eb64eee6f">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Globals</string>
									<string name="ScriptGuid">{ee971bb0-6931-4d74-b9fa-823b4b33d7a1}</string>
									<ProtectedString name="Source"><![CDATA[return {
	engineInit = {
		gravity = Vector2.new(0, 0.3),
		friction = 0.9,
		airfriction = 0.98,
		bounce = 0.8,
		timeSteps = 1,
		canvas = {
			topLeft = Vector2.new(0, 0),
			size = workspace.CurrentCamera.ViewportSize,
		},
	},
	universalMass = 1,
	speed = 55,
	properties = {
		"gravity",
		"friction",
		"collisionmultiplier",
		"airfriction",
		"universalmass",
	},
	rigidbody = {
		props = {
			"Object",
			"Collidable",
			"Anchored",
			"LifeSpan",
			"KeepInCanvas",
			"Gravity",
			"Friction",
			"AirFriction",
			"Structure",
			"Mass",
			"CanRotate",
		},
		must_have = {
			"Object",
		},
	},
	constraint = {
		color = Color3.new(1, 1, 1),
		thickness = 4,
		types = {
			"rope",
			"spring",
			"rod",
		},
		props = {
			"Type",
			"Point1",
			"Point2",
			"Visible",
			"Thickness",
			"RestLength",
			"SpringConstant",
			"Color",
		},
		must_have = {
			"Type",
			"Point1",
			"Point2",
		},
	},
	point = {
		radius = 2.5,
		color = Color3.new(1),
		uicRadius = UDim.new(1, 0),
		props = {
			"Position",
			"Visible",
			"Snap",
			"KeepInCanvas",
			"Radius",
			"Color",
		},
		must_have = {
			"Position",
		},
	},
	offset = Vector2.new(0, 36),
	VALID_OBJECT_PROPS = {
		"Position",
		"Visible",
		"Snap",
		"KeepInCanvas",
		"Radius",
		"Color",
		"Type",
		"Point1",
		"Point2",
		"Thickness",
		"RestLength",
		"SpringConstant",
		"Object",
		"Collidable",
		"Anchored",
		"LifeSpan",
		"Gravity",
		"Friction",
		"AirFriction",
		"Structure",
		"Mass",
		"CanRotate",
	},
	OBJECT_PROPS_TYPES = {
		Position = "Vector2",
		Visible = "boolean",
		Snap = "boolean",
		KeepInCanvas = "boolean",
		Radius = "number",
		Color = "Color3",
		Type = "string",
		Thickness = "number",
		RestLength = "number",
		SpringConstant = "number",
		Object = "Instance",
		Collidable = "boolean",
		Anchored = "boolean",
		LifeSpan = "number",
		Gravity = "Vector2",
		Friction = "number",
		AirFriction = "number",
		Structure = "table",
		Mass = "number",
		CanRotate = "boolean",
	},
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003391</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX38b2781b73f448f0bc7475c26364de28">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">ruizukun-dev_promise@4.0.3</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">118b823fbc6f4004040d84d90000333c</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX4d402a3a97194f2c93f7d1744638a37e">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">promise</string>
							<string name="ScriptGuid">{68c468db-a7a4-41ca-ac85-2027401eee23}</string>
							<ProtectedString name="Source"><![CDATA[local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = {
	__mode = "k",
}

local function isCallable(value)
	if type(value) == "function" then
		return true
	end
	if type(value) == "table" then
		local metatable = getmetatable(value)

		if metatable and type(rawget(metatable, "__call")) == "function" then
			return true
		end
	end

	return false
end
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

local Error

do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}

		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end
	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end
	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end
	function Error:extend(options)
		options = options or {}
		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end
	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end
	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(
				errorStrings,
				table.concat({
					runtimeError.trace or runtimeError.error,
					runtimeError.context,
				}, "\n")
			)
		end

		return table.concat(errorStrings, "\n")
	end
end

local function pack(...)
	return select("#", ...), { ... }
end
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end
local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "traceback is nil")

	return function(err)
		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end
local function isEmpty(t)
	return next(t) == nil
end

local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", {
		"Started",
		"Resolved",
		"Rejected",
		"Cancelled",
	}),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
	_unhandledRejectionCallbacks = {},
}

Promise.prototype = {}
Promise.__index = Promise.prototype

function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		_thread = nil,
		_source = traceback,
		_status = Promise.Status.Started,
		_values = nil,
		_valuesLength = -1,
		_unhandledRejection = true,
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},
		_cancellationHook = nil,
		_parent = parent,
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end
	local function reject(...)
		self:_reject(...)
	end
	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	self._thread = coroutine.create(function()
		local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)

		if not ok then
			reject(result[1])
		end
	end)

	task.spawn(self._thread)

	return self
end
function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end
function Promise:__tostring()
	return string.format("Promise(%s)", self._status)
end
function Promise.defer(executor)
	local traceback = debug.traceback(nil, 2)
	local promise

	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection

		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()

			local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

Promise.async = Promise.defer

function Promise.resolve(...)
	local length, values = pack(...)

	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end
function Promise.reject(...)
	local length, values = pack(...)

	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end
function Promise.try(callback, ...)
	return Promise._try(debug.traceback(nil, 2), callback, ...)
end
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		local resolvedValues = {}
		local newPromises = {}
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end
			if resolvedCount >= (amount or #promises) then
				done = true

				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(function(...)
				resolveOne(i, ...)
			end, function(...)
				rejectedCount = rejectedCount + 1

				if amount == nil or #promises - rejectedCount < amount then
					cancel()

					done = true

					reject(...)
				end
			end)
		end

		if done then
			cancel()
		end
	end)
end
function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end
function Promise.fold(list, reducer, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(isCallable(reducer), "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)

	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return reducer(previousValueResolved, resolvedElement, i)
		end)
	end):andThen(function()
		return accumulator
	end)
end
function Promise.some(promises, count)
	assert(type(count) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, count)
end
function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end
function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		local fates = {}
		local newPromises = {}
		local finishedCount = 0

		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1
			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(function(...)
				resolveOne(i, ...)
			end)
		end
	end)
end
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end
		local function finalize(callback)
			return function(...)
				cancel()

				finished = true

				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}
		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()

					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							[[The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.

That Promise was created at:

%s]],
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()

					return reject(select(2, value:await()))
				end

				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)

				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end
		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success

				success, value = value:await()

				if not success then
					cancel()

					return reject(value)
				end
			end
			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()

				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		return true
	elseif objectMetatable == nil then
		return isCallable(object.andThen)
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and isCallable(rawget(rawget(objectMetatable, "__index"), "andThen"))
	then
		return true
	end

	return false
end
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

do
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")

		if not (seconds >= 1.6666666666666665E-2) or seconds == math.huge then
			seconds = 1.6666666666666665E-2
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds
			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first

						first = current.next

						if first == nil then
							connection:Disconnect()

							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else
				if first.endTime < endTime then
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				local next = node.next

				if first == node then
					if next == nil then
						connection:Disconnect()

						connection = nil
					else
						next.previous = nil
					end

					first = next
				else
					local previous = node.previous

					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end
function Promise.prototype:getStatus()
	return self._status
end
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	if self._status == Promise.Status.Cancelled then
		local promise = Promise.new(function() end)

		promise:cancel()

		return promise
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		local successCallback = resolve

		if successHandler then
			successCallback = createAdvancer(traceback, successHandler, resolve, reject)
		end

		local failureCallback = reject

		if failureHandler then
			failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)
		end
		if self._status == Promise.Status.Started then
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
			onCancel(function()
				if self._status == Promise.Status.Started then
					table.remove(self._queuedResolve, table.find(self._queuedResolve, successCallback))
					table.remove(self._queuedReject, table.find(self._queuedReject, failureCallback))
				end
			end)
		elseif self._status == Promise.Status.Resolved then
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			failureCallback(unpack(self._values, 1, self._valuesLength))
		end
	end, self)
end
function Promise.prototype:andThen(successHandler, failureHandler)
	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end
function Promise.prototype:catch(failureHandler)
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:catch"))

	return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)
end
function Promise.prototype:tap(tapHandler)
	assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, "Promise:tap"))

	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapHandler(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)

			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end
function Promise.prototype:andThenCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))

	local length, values = pack(...)

	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)

	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	coroutine.close(self._thread)

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end
function Promise.prototype:_finally(traceback, finallyHandler)
	self._unhandledRejection = false

	local promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local handlerPromise

		onCancel(function()
			self:_consumerCancelled(self)

			if handlerPromise then
				handlerPromise:cancel()
			end
		end)

		local finallyCallback = resolve

		if finallyHandler then
			finallyCallback = function(...)
				local callbackReturn = finallyHandler(...)

				if Promise.is(callbackReturn) then
					handlerPromise = callbackReturn

					callbackReturn
						:finally(function(status)
							if status ~= Promise.Status.Rejected then
								resolve(self)
							end
						end)
						:catch(function(...)
							reject(...)
						end)
				else
					resolve(self)
				end
			end
		end
		if self._status == Promise.Status.Started then
			table.insert(self._queuedFinally, finallyCallback)
		else
			finallyCallback(self._status)
		end
	end)

	return promise
end
function Promise.prototype:finally(finallyHandler)
	assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, "Promise:finally"))

	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end
function Promise.prototype:finallyCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))

	local length, values = pack(...)

	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)

	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local thread = coroutine.running()

		self
			:finally(function()
				task.spawn(thread)
			end)
			:catch(function() end)
		coroutine.yield()
	end
	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

Promise.prototype.awaitValue = Promise.prototype.expect

function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end
function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end

		return
	end
	if Promise.is((...)) then
		if select("#", ...) > 1 then
			local message = string.format(
				[[When returning a Promise from andThen, extra arguments are discarded! See:

%s]],
				self._source
			)

			warn(message)
		end

		local chainedPromise = ...
		local promise = chainedPromise:andThen(function(...)
			self:_resolve(...)
		end, function(...)
			local maybeRuntimeError = chainedPromise._values[1]

			if chainedPromise._error then
				maybeRuntimeError = Error.new({
					error = chainedPromise._error,
					kind = Error.Kind.ExecutionError,
					context = [=[[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]]=],
				})
			end
			if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
				return self:_reject(maybeRuntimeError:extend({
					error = "This Promise was chained to a Promise that errored.",
					trace = "",
					context = string.format(
						[[The Promise at:

%s
...Rejected because it was chained to the following Promise, which encountered an error:
]],
						self._source
					),
				}))
			end

			self:_reject(...)
		end)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end
function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	if not isEmpty(self._queuedReject) then
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			if not self._unhandledRejection then
				return
			end

			local message = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", err, self._source)

			for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do
				task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))
			end

			if Promise.TEST then
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end

	task.defer(coroutine.close, self._thread)
end
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)

	if self._status == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end
function Promise.retry(callback, times, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end
function Promise.retryWithDelay(callback, times, seconds, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 (times) to Promise.retry must be a number")
	assert(type(seconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			Promise.delay(seconds):await()

			return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()

			connection = nil
		end

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(disconnect)
	end)
end
function Promise.onUnhandledRejection(callback)
	table.insert(Promise._unhandledRejectionCallbacks, callback)

	return function()
		local index = table.find(Promise._unhandledRejectionCallbacks, callback)

		if index then
			table.remove(Promise._unhandledRejectionCallbacks, index)
		end
	end
end

return Promise
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags">V2FsbHk=</BinaryString>
							<UniqueId name="UniqueId">118b823fbc6f4004040d84d90000333d</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX852e9f9296d747f7b1a39b1fe653f3be">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">ruizukun-dev_t@3.0.6</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">118b823fbc6f4004040d84d90000333e</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBXcbd407cd400d453c80157be4ff4f99bf">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">t</string>
							<string name="ScriptGuid">{b3e070ea-502f-4a1e-b8e2-0ea1495a0b12}</string>
							<ProtectedString name="Source"><![CDATA[local t = {}

function t.type(typeName)
	return function(value)
		local valueType = type(value)

		if valueType == typeName then
			return true
		else
			return false, string.format("%s expected, got %s", typeName, valueType)
		end
	end
end
function t.typeof(typeName)
	return function(value)
		local valueType = typeof(value)

		if valueType == typeName then
			return true
		else
			return false, string.format("%s expected, got %s", typeName, valueType)
		end
	end
end
function t.any(value)
	if value ~= nil then
		return true
	else
		return false, "any expected, got nil"
	end
end

t.boolean = t.typeof("boolean")
t.thread = t.typeof("thread")
t.callback = t.typeof("function")
t["function"] = t.callback
t.none = t.typeof("nil")
t["nil"] = t.none
t.string = t.typeof("string")
t.table = t.typeof("table")
t.userdata = t.type("userdata")

function t.number(value)
	local valueType = typeof(value)

	if valueType == "number" then
		if value == value then
			return true
		else
			return false, "unexpected NaN value"
		end
	else
		return false, string.format("number expected, got %s", valueType)
	end
end
function t.nan(value)
	local valueType = typeof(value)

	if valueType == "number" then
		if value ~= value then
			return true
		else
			return false, "unexpected non-NaN value"
		end
	else
		return false, string.format("number expected, got %s", valueType)
	end
end

t.Axes = t.typeof("Axes")
t.BrickColor = t.typeof("BrickColor")
t.CatalogSearchParams = t.typeof("CatalogSearchParams")
t.CFrame = t.typeof("CFrame")
t.Color3 = t.typeof("Color3")
t.ColorSequence = t.typeof("ColorSequence")
t.ColorSequenceKeypoint = t.typeof("ColorSequenceKeypoint")
t.DateTime = t.typeof("DateTime")
t.DockWidgetPluginGuiInfo = t.typeof("DockWidgetPluginGuiInfo")
t.Enum = t.typeof("Enum")
t.EnumItem = t.typeof("EnumItem")
t.Enums = t.typeof("Enums")
t.Faces = t.typeof("Faces")
t.Instance = t.typeof("Instance")
t.NumberRange = t.typeof("NumberRange")
t.NumberSequence = t.typeof("NumberSequence")
t.NumberSequenceKeypoint = t.typeof("NumberSequenceKeypoint")
t.PathWaypoint = t.typeof("PathWaypoint")
t.PhysicalProperties = t.typeof("PhysicalProperties")
t.Random = t.typeof("Random")
t.Ray = t.typeof("Ray")
t.RaycastParams = t.typeof("RaycastParams")
t.RaycastResult = t.typeof("RaycastResult")
t.RBXScriptConnection = t.typeof("RBXScriptConnection")
t.RBXScriptSignal = t.typeof("RBXScriptSignal")
t.Rect = t.typeof("Rect")
t.Region3 = t.typeof("Region3")
t.Region3int16 = t.typeof("Region3int16")
t.TweenInfo = t.typeof("TweenInfo")
t.UDim = t.typeof("UDim")
t.UDim2 = t.typeof("UDim2")
t.Vector2 = t.typeof("Vector2")
t.Vector2int16 = t.typeof("Vector2int16")
t.Vector3 = t.typeof("Vector3")
t.Vector3int16 = t.typeof("Vector3int16")

function t.literal(...)
	local size = select("#", ...)

	if size == 1 then
		local literal = ...

		return function(value)
			if value ~= literal then
				return false, string.format("expected %s, got %s", tostring(literal), tostring(value))
			end

			return true
		end
	else
		local literals = {}

		for i = 1, size do
			local value = select(i, ...)

			literals[i] = t.literal(value)
		end

		return t.union(table.unpack(literals, 1, size))
	end
end

t.exactly = t.literal

function t.keyOf(keyTable)
	local keys = {}
	local length = 0

	for key in pairs(keyTable) do
		length = length + 1
		keys[length] = key
	end

	return t.literal(table.unpack(keys, 1, length))
end
function t.valueOf(valueTable)
	local values = {}
	local length = 0

	for _, value in pairs(valueTable) do
		length = length + 1
		values[length] = value
	end

	return t.literal(table.unpack(values, 1, length))
end
function t.integer(value)
	local success, errMsg = t.number(value)

	if not success then
		return false, errMsg or ""
	end
	if value % 1 == 0 then
		return true
	else
		return false, string.format("integer expected, got %s", value)
	end
end
function t.numberMin(min)
	return function(value)
		local success, errMsg = t.number(value)

		if not success then
			return false, errMsg or ""
		end
		if value >= min then
			return true
		else
			return false, string.format("number >= %s expected, got %s", min, value)
		end
	end
end
function t.numberMax(max)
	return function(value)
		local success, errMsg = t.number(value)

		if not success then
			return false, errMsg
		end
		if value <= max then
			return true
		else
			return false, string.format("number <= %s expected, got %s", max, value)
		end
	end
end
function t.numberMinExclusive(min)
	return function(value)
		local success, errMsg = t.number(value)

		if not success then
			return false, errMsg or ""
		end
		if min < value then
			return true
		else
			return false, string.format("number > %s expected, got %s", min, value)
		end
	end
end
function t.numberMaxExclusive(max)
	return function(value)
		local success, errMsg = t.number(value)

		if not success then
			return false, errMsg or ""
		end
		if value < max then
			return true
		else
			return false, string.format("number < %s expected, got %s", max, value)
		end
	end
end

t.numberPositive = t.numberMin(0)
t.numberNegative = t.numberMax(0)

function t.numberConstrained(min, max)
	assert(t.number(min))
	assert(t.number(max))

	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)

	return function(value)
		local minSuccess, minErrMsg = minCheck(value)

		if not minSuccess then
			return false, minErrMsg or ""
		end

		local maxSuccess, maxErrMsg = maxCheck(value)

		if not maxSuccess then
			return false, maxErrMsg or ""
		end

		return true
	end
end
function t.numberConstrainedExclusive(min, max)
	assert(t.number(min))
	assert(t.number(max))

	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)

	return function(value)
		local minSuccess, minErrMsg = minCheck(value)

		if not minSuccess then
			return false, minErrMsg or ""
		end

		local maxSuccess, maxErrMsg = maxCheck(value)

		if not maxSuccess then
			return false, maxErrMsg or ""
		end

		return true
	end
end
function t.match(pattern)
	assert(t.string(pattern))

	return function(value)
		local stringSuccess, stringErrMsg = t.string(value)

		if not stringSuccess then
			return false, stringErrMsg
		end
		if string.match(value, pattern) == nil then
			return false, string.format("%q failed to match pattern %q", value, pattern)
		end

		return true
	end
end
function t.optional(check)
	assert(t.callback(check))

	return function(value)
		if value == nil then
			return true
		end

		local success, errMsg = check(value)

		if success then
			return true
		else
			return false, string.format("(optional) %s", errMsg or "")
		end
	end
end
function t.tuple(...)
	local checks = { ... }

	return function(...)
		local args = { ... }

		for i, check in ipairs(checks) do
			local success, errMsg = check(args[i])

			if success == false then
				return false, string.format("Bad tuple index #%s:\n\t%s", i, errMsg or "")
			end
		end

		return true
	end
end
function t.keys(check)
	assert(t.callback(check))

	return function(value)
		local tableSuccess, tableErrMsg = t.table(value)

		if tableSuccess == false then
			return false, tableErrMsg or ""
		end

		for key in pairs(value) do
			local success, errMsg = check(key)

			if success == false then
				return false, string.format("bad key %s:\n\t%s", tostring(key), errMsg or "")
			end
		end

		return true
	end
end
function t.values(check)
	assert(t.callback(check))

	return function(value)
		local tableSuccess, tableErrMsg = t.table(value)

		if tableSuccess == false then
			return false, tableErrMsg or ""
		end

		for key, val in pairs(value) do
			local success, errMsg = check(val)

			if success == false then
				return false, string.format("bad value for key %s:\n\t%s", tostring(key), errMsg or "")
			end
		end

		return true
	end
end
function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck))
	assert(t.callback(valueCheck))

	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)

	return function(value)
		local keySuccess, keyErr = keyChecker(value)

		if not keySuccess then
			return false, keyErr or ""
		end

		local valueSuccess, valueErr = valueChecker(value)

		if not valueSuccess then
			return false, valueErr or ""
		end

		return true
	end
end
function t.set(valueCheck)
	return t.map(valueCheck, t.literal(true))
end

do
	local arrayKeysCheck = t.keys(t.integer)

	function t.array(check)
		assert(t.callback(check))

		local valuesCheck = t.values(check)

		return function(value)
			local keySuccess, keyErrMsg = arrayKeysCheck(value)

			if keySuccess == false then
				return false, string.format("[array] %s", keyErrMsg or "")
			end

			local arraySize = 0

			for _ in ipairs(value) do
				arraySize = arraySize + 1
			end
			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false, string.format("[array] key %s must be sequential", tostring(key))
				end
			end

			local valueSuccess, valueErrMsg = valuesCheck(value)

			if not valueSuccess then
				return false, string.format("[array] %s", valueErrMsg or "")
			end

			return true
		end
	end
	function t.strictArray(...)
		local valueTypes = { ... }

		assert(t.array(t.callback)(valueTypes))

		return function(value)
			local keySuccess, keyErrMsg = arrayKeysCheck(value)

			if keySuccess == false then
				return false, string.format("[strictArray] %s", keyErrMsg or "")
			end
			if #valueTypes < #value then
				return false, string.format("[strictArray] Array size exceeds limit of %d", #valueTypes)
			end

			for idx, typeFn in pairs(valueTypes) do
				local typeSuccess, typeErrMsg = typeFn(value[idx])

				if not typeSuccess then
					return false, string.format("[strictArray] Array index #%d - %s", idx, typeErrMsg)
				end
			end

			return true
		end
	end
end
do
	local callbackArray = t.array(t.callback)

	function t.union(...)
		local checks = { ... }

		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				if check(value) then
					return true
				end
			end

			return false, "bad type for union"
		end
	end

	t.some = t.union

	function t.intersection(...)
		local checks = { ... }

		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				local success, errMsg = check(value)

				if not success then
					return false, errMsg or ""
				end
			end

			return true
		end
	end

	t.every = t.intersection
end
do
	local checkInterface = t.map(t.any, t.callback)

	function t.interface(checkTable)
		assert(checkInterface(checkTable))

		return function(value)
			local tableSuccess, tableErrMsg = t.table(value)

			if tableSuccess == false then
				return false, tableErrMsg or ""
			end

			for key, check in pairs(checkTable) do
				local success, errMsg = check(value[key])

				if success == false then
					return false, string.format("[interface] bad value for %s:\n\t%s", tostring(key), errMsg or "")
				end
			end

			return true
		end
	end
	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))

		return function(value)
			local tableSuccess, tableErrMsg = t.table(value)

			if tableSuccess == false then
				return false, tableErrMsg or ""
			end

			for key, check in pairs(checkTable) do
				local success, errMsg = check(value[key])

				if success == false then
					return false, string.format("[interface] bad value for %s:\n\t%s", tostring(key), errMsg or "")
				end
			end
			for key in pairs(value) do
				if not checkTable[key] then
					return false, string.format("[interface] unexpected field %q", tostring(key))
				end
			end

			return true
		end
	end
end

function t.instanceOf(className, childTable)
	assert(t.string(className))

	local childrenCheck

	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess, instanceErrMsg = t.Instance(value)

		if not instanceSuccess then
			return false, instanceErrMsg or ""
		end
		if value.ClassName ~= className then
			return false, string.format("%s expected, got %s", className, value.ClassName)
		end
		if childrenCheck then
			local childrenSuccess, childrenErrMsg = childrenCheck(value)

			if not childrenSuccess then
				return false, childrenErrMsg
			end
		end

		return true
	end
end

t.instance = t.instanceOf

function t.instanceIsA(className, childTable)
	assert(t.string(className))

	local childrenCheck

	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess, instanceErrMsg = t.Instance(value)

		if not instanceSuccess then
			return false, instanceErrMsg or ""
		end
		if not value:IsA(className) then
			return false, string.format("%s expected, got %s", className, value.ClassName)
		end
		if childrenCheck then
			local childrenSuccess, childrenErrMsg = childrenCheck(value)

			if not childrenSuccess then
				return false, childrenErrMsg
			end
		end

		return true
	end
end
function t.enum(enum)
	assert(t.Enum(enum))

	return function(value)
		local enumItemSuccess, enumItemErrMsg = t.EnumItem(value)

		if not enumItemSuccess then
			return false, enumItemErrMsg
		end
		if value.EnumType == enum then
			return true
		else
			return false, string.format("enum of %s expected, got enum of %s", tostring(enum), tostring(value.EnumType))
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))

		return function(...)
			assert(checkArgs(...))

			return callback(...)
		end
	end
end

function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

do
	local checkChildren = t.map(t.string, t.callback)

	function t.children(checkTable)
		assert(checkChildren(checkTable))

		return function(value)
			local instanceSuccess, instanceErrMsg = t.Instance(value)

			if not instanceSuccess then
				return false, instanceErrMsg or ""
			end

			local childrenByName = {}

			for _, child in ipairs(value:GetChildren()) do
				local name = child.Name

				if checkTable[name] then
					if childrenByName[name] then
						return false, string.format("Cannot process multiple children with the same name %q", name)
					end

					childrenByName[name] = child
				end
			end
			for name, check in pairs(checkTable) do
				local success, errMsg = check(childrenByName[name])

				if not success then
					return false, string.format("[%s.%s] %s", value:GetFullName(), name, errMsg or "")
				end
			end

			return true
		end
	end
end

return t
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags">V2FsbHk=</BinaryString>
							<UniqueId name="UniqueId">118b823fbc6f4004040d84d90000333f</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBX0c595ea5038946cdb073dcfea2eeaa77">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Backup</string>
				<string name="ScriptGuid">{C1A828D6-0E66-4B26-A7F0-D726D2A7F060}</string>
				<ProtectedString name="Source"><![CDATA[local Backup = {}

local ProductInfo = require(script.ProductInfo)

function Backup.getProductInfo(assetId: number, infoType: EnumItem)
	return ProductInfo[infoType][tostring(assetId)]
end

return Backup
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags">QXV0by1SdW4=</BinaryString>
				<UniqueId name="UniqueId">38d136ec74d9240302cc7f550001a0cc</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="RBXadf895316f034bcf80e01c0370b558a8">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ProductInfo</string>
					<string name="ScriptGuid">{35D2385F-5119-4898-9666-0ED513908998}</string>
					<ProtectedString name="Source"><![CDATA[local Asset = Enum.InfoType.Asset
local GamePass = Enum.InfoType.GamePass
local Product = Enum.InfoType.Product

local ProductInfo = {
	[Asset] = require(script.Asset),
	[GamePass] = require(script.GamePass),
	[Product] = require(script.Product),
}

return ProductInfo
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">38d136ec74d9240302cc7f550001a0cd</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBXe760d2f94d124317a49d4d1783f158ca">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Asset</string>
						<string name="ScriptGuid">{80D365C5-6629-4B95-BF45-A3E35FC2C219}</string>
						<ProtectedString name="Source"><![CDATA[return {
	["8264226808"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:19:45.833Z",
		AssetId = 8264226808,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:19:45.807Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Chest Open",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["6833149824"] = {
		AssetTypeId = 3,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-05-18T16:42:51.83Z",
		AssetId = 6833149824,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-05-18T16:42:51.82Z",
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Heavy Breathing",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["9235726381"] = {
		AssetTypeId = 3,
		TargetId = 9235726381,
		IsNew = false,
		Updated = "2022-03-30T15:54:06.583Z",
		AssetId = 9235726381,
		ProductId = 1253210633,
		MinimumMembershipLevel = 0,
		Created = "2022-03-30T14:13:24.143Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Dark Magic Spell SFX Pack 1",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimitedUnique = false,
	},
	["9166479682"] = {
		AssetTypeId = 3,
		TargetId = 9166479682,
		IsNew = false,
		Updated = "2022-03-30T15:51:44.513Z",
		AssetId = 9166479682,
		ProductId = 1253210160,
		MinimumMembershipLevel = 0,
		Created = "2022-03-22T02:15:08.77Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "User Interface UI Sound Effects",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimitedUnique = false,
	},
	["5448292687"] = {
		AssetTypeId = 3,
		TargetId = 5448292687,
		IsNew = false,
		Updated = "2021-02-02T06:44:34.6Z",
		AssetId = 5448292687,
		ProductId = 1147705326,
		MinimumMembershipLevel = 0,
		Created = "2020-07-28T10:05:55.483Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Male Taunts03",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimitedUnique = false,
	},
	["1837072182"] = {
		AssetTypeId = 3,
		TargetId = 1837072182,
		IsNew = false,
		Updated = "2018-05-25T22:07:38.333Z",
		AssetId = 1837072182,
		ProductId = 253907433,
		MinimumMembershipLevel = 0,
		Created = "2018-05-25T22:07:38.333Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = true,
		Name = "Moonlight Sonata",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 1,
			CreatorType = "User",
			Name = "Roblox",
			CreatorTargetId = 1,
		},
		IsLimitedUnique = false,
	},
	["6810255608"] = {
		AssetTypeId = 3,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-05-13T14:01:53.797Z",
		AssetId = 6810255608,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-05-13T14:01:53.793Z",
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Evil Laugh",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["6780632962"] = {
		AssetTypeId = 3,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-05-07T13:20:24.23Z",
		AssetId = 6780632962,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-05-07T13:20:24.217Z",
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Thunderstruck",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["6779986386"] = {
		AssetTypeId = 3,
		TargetId = 6779986386,
		IsNew = false,
		Updated = "2021-05-07T09:36:01.89Z",
		AssetId = 6779986386,
		ProductId = 1170937260,
		MinimumMembershipLevel = 0,
		Created = "2021-05-07T09:35:09.577Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Weapon SFX",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimitedUnique = false,
	},
	["9252427502"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2022-04-01T17:39:21.987Z",
		AssetId = 9252427502,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2022-04-01T17:25:25.6Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Levitation Idle",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["8264216035"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:17:21.33Z",
		AssetId = 8264216035,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:17:21.3Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Slash Right",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["5492737782"] = {
		AssetTypeId = 3,
		TargetId = 0,
		IsNew = false,
		Updated = "2020-08-03T22:16:27.487Z",
		AssetId = 5492737782,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2020-08-03T22:16:27.437Z",
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Chest Open",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["1848185643"] = {
		AssetTypeId = 3,
		TargetId = 1848185643,
		IsNew = false,
		Updated = "2018-05-28T00:00:56.96Z",
		AssetId = 1848185643,
		ProductId = 257021294,
		MinimumMembershipLevel = 0,
		Created = "2018-05-28T00:00:56.96Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = true,
		Name = "Gates Of Hell A",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 1,
			CreatorType = "User",
			Name = "Roblox",
			CreatorTargetId = 1,
		},
		IsLimitedUnique = false,
	},
	["1836635034"] = {
		AssetTypeId = 3,
		TargetId = 1836635034,
		IsNew = false,
		Updated = "2018-05-25T19:45:13.337Z",
		AssetId = 1836635034,
		ProductId = 253810267,
		MinimumMembershipLevel = 0,
		Created = "2018-05-25T19:45:13.32Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = true,
		Name = "Gothic Castle",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 1,
			CreatorType = "User",
			Name = "Roblox",
			CreatorTargetId = 1,
		},
		IsLimitedUnique = false,
	},
	["6833036014"] = {
		AssetTypeId = 3,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-05-18T16:11:50.083Z",
		AssetId = 6833036014,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-05-18T16:11:50.08Z",
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Trap",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["441202925"] = {
		AssetTypeId = 3,
		TargetId = 441202925,
		IsNew = false,
		Updated = "2016-06-25T17:25:45.987Z",
		AssetId = 441202925,
		ProductId = 35562998,
		MinimumMembershipLevel = 0,
		Created = "2016-06-25T17:25:19.377Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = true,
		Name = "DBZ Punch Sound",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 22418765,
			CreatorType = "User",
			Name = "SoulSensei",
			CreatorTargetId = 22418765,
		},
		IsLimitedUnique = false,
	},
	["231107923"] = {
		AssetTypeId = 3,
		TargetId = 231107923,
		IsNew = false,
		Updated = "2020-05-02T11:58:02.583Z",
		AssetId = 231107923,
		ProductId = 23244993,
		MinimumMembershipLevel = 0,
		Created = "2015-03-28T15:28:22.837Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Power Down Sound Effect",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 31253214,
			CreatorType = "User",
			Name = "andrewbyte",
			CreatorTargetId = 31253214,
		},
		IsLimitedUnique = false,
	},
	["139642705"] = {
		AssetTypeId = 3,
		TargetId = 139642705,
		IsNew = false,
		Updated = "2013-12-24T07:21:36.74Z",
		AssetId = 139642705,
		ProductId = 18788204,
		MinimumMembershipLevel = 0,
		Created = "2013-12-24T07:21:36.74Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = true,
		Name = "Force Field Contact Sound",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 25240799,
			CreatorType = "User",
			Name = "BearKranz",
			CreatorTargetId = 25240799,
		},
		IsLimitedUnique = false,
	},
	["8264222281"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:18:45.36Z",
		AssetId = 8264222281,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:18:45.347Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Play Piano",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["1080610583"] = {
		AssetTypeId = 3,
		TargetId = 1080610583,
		IsNew = false,
		Updated = "2017-10-01T14:19:25.953Z",
		AssetId = 1080610583,
		ProductId = 103150449,
		MinimumMembershipLevel = 0,
		Created = "2017-10-01T14:14:29.3Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = true,
		Name = "TF2 - Soldier Death",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 51634064,
			CreatorType = "User",
			Name = "Mr_Ali",
			CreatorTargetId = 51634064,
		},
		IsLimitedUnique = false,
	},
	["5227828057"] = {
		AssetTypeId = 3,
		TargetId = 5227828057,
		IsNew = false,
		Updated = "2021-03-02T23:03:19.61Z",
		AssetId = 5227828057,
		ProductId = 1041512137,
		MinimumMembershipLevel = 0,
		Created = "2020-06-24T10:53:02.647Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Female - Round End",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimitedUnique = false,
	},
	["8264205647"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:14:43.147Z",
		AssetId = 8264205647,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:14:43.133Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Petrifying",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["8264227993"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:20:01.993Z",
		AssetId = 8264227993,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:20:01.98Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Chest Shake",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["1836635015"] = {
		AssetTypeId = 3,
		TargetId = 1836635015,
		IsNew = false,
		Updated = "2018-05-25T19:45:13.04Z",
		AssetId = 1836635015,
		ProductId = 253810264,
		MinimumMembershipLevel = 0,
		Created = "2018-05-25T19:45:13.023Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = true,
		Name = "Dracula Plays!",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 1,
			CreatorType = "User",
			Name = "Roblox",
			CreatorTargetId = 1,
		},
		IsLimitedUnique = false,
	},
	["8264227482"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:19:53.83Z",
		AssetId = 8264227482,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:19:53.787Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Chest Opening",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["320412149"] = {
		AssetTypeId = 3,
		TargetId = 320412149,
		IsNew = false,
		Updated = "2015-11-15T19:54:03.4Z",
		AssetId = 320412149,
		ProductId = 30003727,
		MinimumMembershipLevel = 0,
		Created = "2015-11-15T19:54:03.4Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = true,
		Name = "Squeaky Toy Sound Effect",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 43405177,
			CreatorType = "User",
			Name = "NICCO890",
			CreatorTargetId = 43405177,
		},
		IsLimitedUnique = false,
	},
	["397572702"] = {
		AssetTypeId = 3,
		TargetId = 0,
		IsNew = false,
		Updated = "2016-04-12T03:19:52.987Z",
		AssetId = 397572702,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2016-04-12T03:19:52.987Z",
		Creator = {
			Id = 212423,
			CreatorType = "User",
			Name = "OrbitalOwen",
			CreatorTargetId = 212423,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "8-Bit Power Up Sound Effect Edit",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["5227247373"] = {
		AssetTypeId = 3,
		TargetId = 5227247373,
		IsNew = false,
		Updated = "2020-07-22T04:34:12.543Z",
		AssetId = 5227247373,
		ProductId = 1041512305,
		MinimumMembershipLevel = 0,
		Created = "2020-06-24T07:04:31.02Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Female - Rarity",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimitedUnique = false,
	},
	["7094625009"] = {
		AssetTypeId = 3,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-07-14T12:16:42.33Z",
		AssetId = 7094625009,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-07-14T12:16:42.317Z",
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Breaking Stones",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["5300055939"] = {
		AssetTypeId = 3,
		TargetId = 0,
		IsNew = false,
		Updated = "2020-07-06T17:13:23.45Z",
		AssetId = 5300055939,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2020-07-06T17:13:23.563Z",
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Kick",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["348225739"] = {
		AssetTypeId = 3,
		TargetId = 348225739,
		IsNew = false,
		Updated = "2016-01-26T00:01:06.963Z",
		AssetId = 348225739,
		ProductId = 31402271,
		MinimumMembershipLevel = 0,
		Created = "2016-01-26T00:00:22.04Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = true,
		Name = "Hadoken",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 4659954,
			CreatorType = "User",
			Name = "Gameplayer1500",
			CreatorTargetId = 4659954,
		},
		IsLimitedUnique = false,
	},
	["8264221100"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:18:28.207Z",
		AssetId = 8264221100,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:18:28.193Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Play Saxophone",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["8264220082"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:18:15.51Z",
		AssetId = 8264220082,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:18:15.487Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Lift Weight",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["931391007"] = {
		AssetTypeId = 3,
		TargetId = 931391007,
		IsNew = false,
		Updated = "2017-07-22T05:13:26.627Z",
		AssetId = 931391007,
		ProductId = 88246780,
		MinimumMembershipLevel = 0,
		Created = "2017-07-22T05:12:49.657Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = true,
		Name = "MMX8 - Warning! Warning!",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 29816920,
			CreatorType = "User",
			Name = "CptRedder",
			CreatorTargetId = 29816920,
		},
		IsLimitedUnique = false,
	},
	["6835851999"] = {
		AssetTypeId = 3,
		TargetId = 6835851999,
		IsNew = false,
		Updated = "2021-05-19T09:23:04.163Z",
		AssetId = 6835851999,
		ProductId = 1175146106,
		MinimumMembershipLevel = 0,
		Created = "2021-05-19T09:22:18.18Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "I Work Out💪",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimitedUnique = false,
	},
	["8264202048"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:13:51.193Z",
		AssetId = 8264202048,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:13:51.173Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Golden Touch",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["5694691260"] = {
		AssetTypeId = 3,
		TargetId = 5694691260,
		IsNew = false,
		Updated = "2021-02-02T03:58:37.093Z",
		AssetId = 5694691260,
		ProductId = 1147683073,
		MinimumMembershipLevel = 0,
		Created = "2020-09-15T11:32:43.677Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Sakura Map Jingle",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimitedUnique = false,
	},
	["6766230018"] = {
		AssetTypeId = 3,
		TargetId = 6766230018,
		IsNew = false,
		Updated = "2021-05-04T09:35:01.703Z",
		AssetId = 6766230018,
		ProductId = 1169766974,
		MinimumMembershipLevel = 0,
		Created = "2021-05-04T09:35:01.647Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 66,
		ContentRatingTypeId = 0,
		IsPublicDomain = true,
		Name = "Silence",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimitedUnique = false,
	},
	["5493115980"] = {
		AssetTypeId = 3,
		TargetId = 0,
		IsNew = false,
		Updated = "2020-08-03T23:32:32.61Z",
		AssetId = 5493115980,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2020-08-03T23:32:32.55Z",
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Holy",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["7058308619"] = {
		AssetTypeId = 3,
		TargetId = 7058308619,
		IsNew = false,
		Updated = "2021-07-07T04:53:44.223Z",
		AssetId = 7058308619,
		ProductId = 1188274301,
		MinimumMembershipLevel = 0,
		Created = "2021-07-07T04:53:16.483Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Developer Product",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimitedUnique = false,
	},
	["8984136257"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2022-03-02T04:38:33.09Z",
		AssetId = 8984136257,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2022-03-02T04:38:33.06Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Poke",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["525743689"] = {
		AssetTypeId = 3,
		TargetId = 525743689,
		IsNew = false,
		Updated = "2021-02-18T14:06:16.35Z",
		AssetId = 525743689,
		ProductId = 39516956,
		MinimumMembershipLevel = 0,
		Created = "2016-10-19T02:58:00.927Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = true,
		Name = "YEET sound effect",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 19071074,
			CreatorType = "User",
			Name = "CaikSlyce",
			CreatorTargetId = 19071074,
		},
		IsLimitedUnique = false,
	},
	["8264189040"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:10:39.043Z",
		AssetId = 8264189040,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:10:38.997Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Jhin Dance",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["1841601378"] = {
		AssetTypeId = 3,
		TargetId = 1841601378,
		IsNew = false,
		Updated = "2018-05-26T18:58:56.023Z",
		AssetId = 1841601378,
		ProductId = 255176505,
		MinimumMembershipLevel = 0,
		Created = "2018-05-26T18:58:56.01Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = true,
		Name = "Legend of the Vampire a",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 1,
			CreatorType = "User",
			Name = "Roblox",
			CreatorTargetId = 1,
		},
		IsLimitedUnique = false,
	},
	["8264203326"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:14:09.983Z",
		AssetId = 8264203326,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:14:09.97Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Hell Flames",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["348225677"] = {
		AssetTypeId = 3,
		TargetId = 348225677,
		IsNew = false,
		Updated = "2016-01-26T00:01:24.463Z",
		AssetId = 348225677,
		ProductId = 31402277,
		MinimumMembershipLevel = 0,
		Created = "2016-01-26T00:00:14.54Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = true,
		Name = "Shoryuken",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 4659954,
			CreatorType = "User",
			Name = "Gameplayer1500",
			CreatorTargetId = 4659954,
		},
		IsLimitedUnique = false,
	},
	["138811664"] = {
		AssetTypeId = 3,
		TargetId = 138811664,
		IsNew = false,
		Updated = "2013-12-17T07:37:16.43Z",
		AssetId = 138811664,
		ProductId = 18493368,
		MinimumMembershipLevel = 0,
		Created = "2013-12-17T07:37:01.36Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = true,
		Name = "Vortex Manipulator Teleport",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 7733466,
			CreatorType = "User",
			Name = "InceptionTime",
			CreatorTargetId = 7733466,
		},
		IsLimitedUnique = false,
	},
	["131038747"] = {
		AssetTypeId = 3,
		TargetId = 131038747,
		IsNew = false,
		Updated = "2013-09-28T17:16:08.753Z",
		AssetId = 131038747,
		ProductId = 17906892,
		MinimumMembershipLevel = 0,
		Created = "2013-09-28T17:11:59Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = true,
		Name = "Heart Beat",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 47680722,
			CreatorType = "User",
			Name = "JacobTerranceBridges",
			CreatorTargetId = 47680722,
		},
		IsLimitedUnique = false,
	},
	["1843463175"] = {
		AssetTypeId = 3,
		TargetId = 1843463175,
		IsNew = false,
		Updated = "2018-05-27T02:04:07.997Z",
		AssetId = 1843463175,
		ProductId = 255713943,
		MinimumMembershipLevel = 0,
		Created = "2018-05-27T02:04:07.98Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = true,
		Name = "Phantom At The Opera",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 1,
			CreatorType = "User",
			Name = "Roblox",
			CreatorTargetId = 1,
		},
		IsLimitedUnique = false,
	},
	["8264226347"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:19:36.367Z",
		AssetId = 8264226347,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:19:36.33Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Chest Close",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["8264196993"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:12:37.323Z",
		AssetId = 8264196993,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:12:37.297Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Wiggle Dance",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["8264191397"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:11:13.973Z",
		AssetId = 8264191397,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:11:13.933Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Russian Dance",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["8264195119"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:12:12.587Z",
		AssetId = 8264195119,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:12:12.57Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Victor Dance",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["8264190306"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:10:56.297Z",
		AssetId = 8264190306,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:10:56.28Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Kog'Maw Dance",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["5227832696"] = {
		AssetTypeId = 3,
		TargetId = 5227832696,
		IsNew = false,
		Updated = "2021-02-02T06:41:35.017Z",
		AssetId = 5227832696,
		ProductId = 1041513170,
		MinimumMembershipLevel = 0,
		Created = "2020-06-24T10:54:37.227Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Female Taunt",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimitedUnique = false,
	},
	["8264185145"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:09:33.85Z",
		AssetId = 8264185145,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:09:33.82Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Floss",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["8264206706"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:15:00.897Z",
		AssetId = 8264206706,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:15:00.88Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Thunderstruck",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["8264214941"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:17:02.99Z",
		AssetId = 8264214941,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:17:02.967Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Equip Sword",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["8264192686"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:11:32.75Z",
		AssetId = 8264192686,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:11:32.723Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Shaco Dance",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["8264187182"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:10:10.777Z",
		AssetId = 8264187182,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:10:10.75Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Garen Dance",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["8264208682"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:15:31.297Z",
		AssetId = 8264208682,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:15:31.253Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Crawl",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["436748675"] = {
		AssetTypeId = 3,
		TargetId = 436748675,
		IsNew = false,
		Updated = "2016-06-19T08:48:31.103Z",
		AssetId = 436748675,
		ProductId = 35360291,
		MinimumMembershipLevel = 0,
		Created = "2016-06-19T08:37:35.523Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = true,
		Name = "DBZ jump Sound Effect",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 133256995,
			CreatorType = "User",
			Name = "MindlessHD",
			CreatorTargetId = 133256995,
		},
		IsLimitedUnique = false,
	},
	["4706127159"] = {
		AssetTypeId = 3,
		TargetId = 0,
		IsNew = false,
		Updated = "2020-02-19T11:08:08.993Z",
		AssetId = 4706127159,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2020-02-19T11:08:08.74Z",
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Sword Hit Player",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["5448293193"] = {
		AssetTypeId = 3,
		TargetId = 5448293193,
		IsNew = false,
		Updated = "2021-02-02T06:45:00.263Z",
		AssetId = 5448293193,
		ProductId = 1147705380,
		MinimumMembershipLevel = 0,
		Created = "2020-07-28T10:06:02.327Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Male Taunts04",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimitedUnique = false,
	},
	["8264184250"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:09:20.397Z",
		AssetId = 8264184250,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:09:20.38Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Dio Pose",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["8264211462"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:16:11.62Z",
		AssetId = 8264211462,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:16:11.607Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Stun",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["8264177263"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:07:40.79Z",
		AssetId = 8264177263,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:07:40.777Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "R15Run",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["8264210459"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:15:55.397Z",
		AssetId = 8264210459,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:15:55.383Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Front Dash",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["9236263698"] = {
		AssetTypeId = 3,
		TargetId = 9236263698,
		IsNew = false,
		Updated = "2022-03-30T15:40:45.483Z",
		AssetId = 9236263698,
		ProductId = 1253208209,
		MinimumMembershipLevel = 0,
		Created = "2022-03-30T15:36:11.053Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Shadow Magic Loop",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimitedUnique = false,
	},
	["6832897808"] = {
		AssetTypeId = 3,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-05-18T15:33:38.9Z",
		AssetId = 6832897808,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-05-18T15:33:38.883Z",
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Coin",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["8264215478"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:17:11.313Z",
		AssetId = 8264215478,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:17:11.28Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Slash Left",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["131228548"] = {
		AssetTypeId = 3,
		TargetId = 131228548,
		IsNew = false,
		Updated = "2013-09-30T04:29:10.577Z",
		AssetId = 131228548,
		ProductId = 17920631,
		MinimumMembershipLevel = 0,
		Created = "2013-09-29T23:50:16.07Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = true,
		Name = "Get Over Here (Scorpion)",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 30566138,
			CreatorType = "User",
			Name = "SquidNoob",
			CreatorTargetId = 30566138,
		},
		IsLimitedUnique = false,
	},
	["6833193639"] = {
		AssetTypeId = 3,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-05-18T16:54:25.897Z",
		AssetId = 6833193639,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-05-18T16:54:25.893Z",
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Heartbeat",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["1843700644"] = {
		AssetTypeId = 3,
		TargetId = 1843700644,
		IsNew = false,
		Updated = "2018-05-27T03:04:29.407Z",
		AssetId = 1843700644,
		ProductId = 255783920,
		MinimumMembershipLevel = 0,
		Created = "2018-05-27T03:04:29.407Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = true,
		Name = "Inside Hell",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 1,
			CreatorType = "User",
			Name = "Roblox",
			CreatorTargetId = 1,
		},
		IsLimitedUnique = false,
	},
	["6836806238"] = {
		AssetTypeId = 3,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-05-19T15:15:33.953Z",
		AssetId = 6836806238,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-05-19T15:15:33.95Z",
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Ignite",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["5490563834"] = {
		AssetTypeId = 3,
		TargetId = 0,
		IsNew = false,
		Updated = "2020-08-03T15:42:34.397Z",
		AssetId = 5490563834,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2020-08-03T15:42:34.61Z",
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Magical Explosions",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["8791525604"] = {
		AssetTypeId = 3,
		TargetId = 8791525604,
		IsNew = false,
		Updated = "2022-03-30T15:42:40.74Z",
		AssetId = 8791525604,
		ProductId = 1253208581,
		MinimumMembershipLevel = 0,
		Created = "2022-02-11T12:50:51.737Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Seeker Announcer",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimitedUnique = false,
	},
	["6785774853"] = {
		AssetTypeId = 3,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-05-08T13:46:59.5Z",
		AssetId = 6785774853,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-05-08T13:46:59.483Z",
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Golden Touch",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["7094625713"] = {
		AssetTypeId = 3,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-07-14T12:16:53.047Z",
		AssetId = 7094625713,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-07-14T12:16:53.03Z",
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Gained Gems",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["8264211054"] = {
		AssetTypeId = 24,
		TargetId = 8264211054,
		IsNew = false,
		Updated = "2022-02-23T01:19:39.54Z",
		AssetId = 8264211054,
		ProductId = 1239826099,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:16:04.287Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Hook",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimitedUnique = false,
	},
	["6819925055"] = {
		AssetTypeId = 3,
		TargetId = 6819925055,
		IsNew = false,
		Updated = "2021-05-19T09:22:37.077Z",
		AssetId = 6819925055,
		ProductId = 1175146058,
		MinimumMembershipLevel = 0,
		Created = "2021-05-15T16:02:14.397Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Work It💪",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimitedUnique = false,
	},
	["6868681385"] = {
		AssetTypeId = 3,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-05-26T17:46:04.613Z",
		AssetId = 6868681385,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-05-26T17:46:04.61Z",
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Defeat",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["6636512585"] = {
		AssetTypeId = 3,
		TargetId = 6636512585,
		IsNew = false,
		Updated = "2022-03-08T05:02:19.84Z",
		AssetId = 6636512585,
		ProductId = 1163295636,
		MinimumMembershipLevel = 0,
		Created = "2021-04-05T17:48:04.05Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "(Removed for copyright)",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimitedUnique = false,
	},
	["5448291635"] = {
		AssetTypeId = 3,
		TargetId = 5448291635,
		IsNew = false,
		Updated = "2021-02-02T06:41:39.52Z",
		AssetId = 5448291635,
		ProductId = 1147704402,
		MinimumMembershipLevel = 0,
		Created = "2020-07-28T10:05:41.103Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Male Taunts01",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimitedUnique = false,
	},
	["8759075101"] = {
		AssetTypeId = 3,
		TargetId = 0,
		IsNew = false,
		Updated = "2022-02-07T12:19:58.113Z",
		AssetId = 8759075101,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2022-02-07T12:19:58.11Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "F2P Logo",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["5448292145"] = {
		AssetTypeId = 3,
		TargetId = 5448292145,
		IsNew = false,
		Updated = "2021-02-02T06:40:55Z",
		AssetId = 5448292145,
		ProductId = 1051067793,
		MinimumMembershipLevel = 0,
		Created = "2020-07-28T10:05:48.263Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Male Taunts02",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimitedUnique = false,
	},
	["6836922548"] = {
		AssetTypeId = 3,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-05-19T15:47:27.133Z",
		AssetId = 6836922548,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-05-19T15:47:27.123Z",
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Dark Magic",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["8264193514"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:11:48.3Z",
		AssetId = 8264193514,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:11:48.277Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Take the L",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["8264204803"] = {
		AssetTypeId = 24,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-12-16T11:14:28.457Z",
		AssetId = 8264204803,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-12-16T11:14:28.433Z",
		Creator = {
			Id = 1782595412,
			CreatorType = "Group",
			Name = "F2P Entertainment",
			CreatorTargetId = 7178382,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Kick",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["6837221467"] = {
		AssetTypeId = 3,
		TargetId = 0,
		IsNew = false,
		Updated = "2021-05-19T17:10:14.64Z",
		AssetId = 6837221467,
		ProductId = 0,
		MinimumMembershipLevel = 0,
		Created = "2021-05-19T17:10:14.637Z",
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Snake Bite",
		IsForSale = false,
		IconImageAssetId = 0,
		IsLimitedUnique = false,
	},
	["6805283409"] = {
		AssetTypeId = 3,
		TargetId = 6805283409,
		IsNew = false,
		Updated = "2021-05-12T11:29:55.683Z",
		AssetId = 6805283409,
		ProductId = 1173303507,
		MinimumMembershipLevel = 0,
		Created = "2021-05-12T11:29:33.42Z",
		ProductType = "User Product",
		IsLimited = false,
		Sales = 0,
		ContentRatingTypeId = 0,
		IsPublicDomain = false,
		Name = "Psychosis",
		IsForSale = false,
		IconImageAssetId = 0,
		Creator = {
			Id = 252175492,
			CreatorType = "Group",
			Name = "Kitsune's Hideout",
			CreatorTargetId = 3132914,
		},
		IsLimitedUnique = false,
	},
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">38d136ec74d9240302cc7f550001a0ce</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX86965ce5c4e448dd842922d60fdb7205">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Product</string>
						<string name="ScriptGuid">{7B579722-8304-4FC2-9BC4-077DAE771130}</string>
						<ProtectedString name="Source"><![CDATA[return {
	["1229460979"] = {
		AssetTypeId = 0,
		TargetId = 10841773,
		IsNew = false,
		Updated = "2022-02-23T07:19:57.7Z",
		AssetId = 0,
		ProductId = 1229460979,
		MinimumMembershipLevel = 0,
		Created = "2021-12-15T06:40:43.103Z",
		ProductType = "Developer Product",
		IsLimited = false,
		IsPublicDomain = false,
		IsForSale = true,
		Name = "Gem Pass",
		PriceInRobux = 1,
		IconImageAssetId = 8256276972,
		Creator = {
			Id = 0,
			CreatorTargetId = 0,
		},
		IsLimitedUnique = false,
	},
	["1229460908"] = {
		AssetTypeId = 0,
		TargetId = 10841763,
		IsNew = false,
		Updated = "2021-12-15T06:48:59.207Z",
		AssetId = 0,
		ProductId = 1229460908,
		MinimumMembershipLevel = 0,
		Created = "2021-12-15T06:39:25.72Z",
		ProductType = "Developer Product",
		IsLimited = false,
		IsForSale = true,
		IsPublicDomain = false,
		Name = "1320 Gems",
		PriceInRobux = 799,
		IconImageAssetId = 8256268060,
		Creator = {
			Id = 0,
			CreatorTargetId = 0,
		},
		IsLimitedUnique = false,
	},
	["1229460883"] = {
		AssetTypeId = 0,
		TargetId = 10841762,
		IsNew = false,
		Updated = "2021-12-15T06:48:47.617Z",
		AssetId = 0,
		ProductId = 1229460883,
		MinimumMembershipLevel = 0,
		Created = "2021-12-15T06:38:45.187Z",
		ProductType = "Developer Product",
		IsLimited = false,
		IsForSale = true,
		IsPublicDomain = false,
		Name = "650 Gems",
		PriceInRobux = 399,
		IconImageAssetId = 8256267457,
		Creator = {
			Id = 0,
			CreatorTargetId = 0,
		},
		IsLimitedUnique = false,
	},
	["1229460948"] = {
		AssetTypeId = 0,
		TargetId = 10841768,
		IsNew = false,
		Updated = "2021-12-15T06:49:08.767Z",
		AssetId = 0,
		ProductId = 1229460948,
		MinimumMembershipLevel = 0,
		Created = "2021-12-15T06:39:54.907Z",
		ProductType = "Developer Product",
		IsLimited = false,
		IsForSale = true,
		IsPublicDomain = false,
		Name = "1720 Gems",
		PriceInRobux = 999,
		IconImageAssetId = 8256268585,
		Creator = {
			Id = 0,
			CreatorTargetId = 0,
		},
		IsLimitedUnique = false,
	},
	["1229460828"] = {
		AssetTypeId = 0,
		TargetId = 10841753,
		IsNew = false,
		Updated = "2022-01-02T05:19:53.303Z",
		AssetId = 0,
		ProductId = 1229460828,
		MinimumMembershipLevel = 0,
		Created = "2021-12-15T06:37:47.7Z",
		ProductType = "Developer Product",
		IsLimited = false,
		IsForSale = true,
		IsPublicDomain = false,
		Name = "130 Gems",
		PriceInRobux = 79,
		IconImageAssetId = 8429799439,
		Creator = {
			Id = 0,
			CreatorTargetId = 0,
		},
		IsLimitedUnique = false,
	},
	["1229460969"] = {
		AssetTypeId = 0,
		TargetId = 10841772,
		IsNew = false,
		Updated = "2022-03-15T10:08:54.867Z",
		AssetId = 0,
		ProductId = 1229460969,
		MinimumMembershipLevel = 0,
		Created = "2021-12-15T06:40:28.113Z",
		ProductType = "Developer Product",
		IsLimited = false,
		IsPublicDomain = false,
		IsForSale = true,
		Name = "7100 Gems",
		PriceInRobux = 3999,
		IconImageAssetId = 8256269628,
		Creator = {
			Id = 0,
			CreatorTargetId = 0,
		},
		IsLimitedUnique = false,
	},
	["1229460957"] = {
		AssetTypeId = 0,
		TargetId = 10841770,
		IsNew = false,
		Updated = "2021-12-15T06:49:21.387Z",
		AssetId = 0,
		ProductId = 1229460957,
		MinimumMembershipLevel = 0,
		Created = "2021-12-15T06:40:13.187Z",
		ProductType = "Developer Product",
		IsLimited = false,
		IsForSale = true,
		IsPublicDomain = false,
		Name = "3550 Gems",
		PriceInRobux = 1999,
		IconImageAssetId = 8256269250,
		Creator = {
			Id = 0,
			CreatorTargetId = 0,
		},
		IsLimitedUnique = false,
	},
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">38d136ec74d9240302cc7f550001a0d0</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4ff8e10aebdb4a38a0147b8b6d498e66">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">GamePass</string>
						<string name="ScriptGuid">{534ea8b8-ceb5-4f46-be87-5fb904f39054}</string>
						<ProtectedString name="Source"><![CDATA[return {
	["17187404"] = {
		AssetTypeId = 0,
		TargetId = 17187404,
		IsNew = false,
		Updated = "2022-04-11T17:44:03.543Z",
		AssetId = 0,
		ProductId = 1167354346,
		MinimumMembershipLevel = 0,
		Created = "2021-04-25T09:14:18.94Z",
		ProductType = "Game Pass",
		IsLimited = false,
		Sales = 9,
		IsForSale = true,
		IsPublicDomain = false,
		Name = "Coin x2",
		PriceInRobux = 15,
		IconImageAssetId = 6726100408,
		Creator = {
			Id = 105648390,
			CreatorType = "User",
			Name = "RuizuKun_Dev",
			CreatorTargetId = 105648390,
		},
		IsLimitedUnique = false,
	},
	["17125823"] = {
		AssetTypeId = 0,
		TargetId = 17125823,
		IsNew = false,
		Updated = "2022-04-11T17:43:57.22Z",
		AssetId = 0,
		ProductId = 1166962580,
		MinimumMembershipLevel = 0,
		Created = "2021-04-23T17:23:21.923Z",
		ProductType = "Game Pass",
		IsLimited = false,
		Sales = 9,
		IsForSale = true,
		IsPublicDomain = false,
		Name = "EXP x2",
		PriceInRobux = 15,
		IconImageAssetId = 6726099617,
		Creator = {
			Id = 105648390,
			CreatorType = "User",
			Name = "RuizuKun_Dev",
			CreatorTargetId = 105648390,
		},
		IsLimitedUnique = false,
	},
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">118b823fbc6f4004040d84d9000032c3</UniqueId>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBXf2802d0472404c97b73ef66f569c743a">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Bindables</string>
				<string name="ScriptGuid">{2FCC5897-2D92-4AC1-9853-FA22168C1E45}</string>
				<ProtectedString name="Source"><![CDATA[export type Bindable = {
	Name: string,

	BindableEvent: BindableEvent,
	Event: RBXScriptSignal,
	Signal: Signal,
	Events: Dictionary,
	Fire: (...any) -> void,

	Wait: (string) -> (...any?),

	BindableFunction: BindableFunction,
	-- OnInvoke = BindableFunction.OnInvoke,
	Functions: Dictionary,
	Invoke: (...any) -> (...any),

	Connection: RBXScriptConnection?,
}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local Signals = require(Utilities.Signals)

local function makeBindableEvent(name: string): BindableEvent
	local BindableEvent = Instance.new("BindableEvent")
	BindableEvent.Name = name .. ".BE"
	return BindableEvent
end

local function makeBindableFunction(name: string): BindableFunction
	local BindableFunction = Instance.new("BindableFunction")
	BindableFunction.Name = name .. ".BF"
	return BindableFunction
end

local Bindables = {}

function Bindables.create(name: string): Bindable
	if not Bindables[name] then
		local signal = Signals.create()

		local BindableEvent = makeBindableEvent(name)

		local BindableFunction = makeBindableFunction(name)

		local waitForEvent
		function waitForEvent(event: string): ...any?
			local result = table.pack(signal:Wait())
			if result[1] == event then
				return unpack(result, 2)
			end

			return waitForEvent(event)
		end

		local Bindable = {
			Name = name,

			BindableEvent = BindableEvent,
			Signal = signal,
			Event = BindableEvent.Event,
			Events = {},
			Fire = function(...)
				signal:Fire(...)
			end,

			Wait = waitForEvent,

			BindableFunction = BindableFunction,
			Functions = {},
			Invoke = function(...): any
				return BindableFunction:Invoke(...)
			end,
		}

		local functions = Bindable.Functions
		function BindableFunction.OnInvoke(instruction: string, ...): any
			local callback = functions[instruction]
			if callback then
				local errorMessage, stacktrace
				local results = table.pack(xpcall(callback, function(err)
					errorMessage = err
					stacktrace = debug.traceback()
				end, ...))
				if not results[1] then
					error(
						string.format(
							"Error Message: %s.\nFrom Instruction %q with BindableFunction %q\nStack trace:%s",
							tostring(errorMessage),
							tostring(instruction),
							tostring(name),
							tostring(stacktrace)
						)
					)
				end
				return unpack(results, 2)
			else
				warn(instruction, "is an Invalid Function for", BindableFunction, "BindableFunction")
			end
		end

		Bindables[name] = Bindable

		BindableEvent.Parent = script
		BindableFunction.Parent = script

		script:SetAttribute(name, true)
	else
		warn("BindableEvent", name, "already exists use Bindables.get instead")
	end
	return Bindables[name]
end

function Bindables.get(name: string): Bindable
	if not Bindables[name] then
		script:WaitForChild(name .. ".BE")
		script:WaitForChild(name .. ".BF")
	end
	return Bindables[name]
end

local function setEvents(Bindable: Bindable, newInstructions: Dictionary)
	local events = Bindable.Events

	for instruction: string, callback in pairs(newInstructions) do
		events[instruction] = callback
	end
end

function Bindables.handleEvents(Bindable: Bindable, newInstructions: Dictionary)
	setEvents(Bindable, newInstructions)

	if not Bindable.Connection then
		local events = Bindable.Events
		Bindable.Connection = Bindable.Signal:Connect(function(instruction: string, ...)
			local callback = events[instruction]
			if callback then
				local errorMessage, stacktrace
				local success = xpcall(callback, function(err)
					errorMessage = err
					stacktrace = debug.traceback()
				end, ...)
				if not success then
					error(
						string.format(
							"Error Message: %s.\nFrom Instruction %q with BindableEvent %q\nStack trace:%s",
							tostring(errorMessage),
							tostring(instruction),
							tostring(Bindable.Name),
							tostring(stacktrace)
						)
					)
				end
			else
				warn(instruction, "is an Invalid Event for", Bindable.Name, "BindableEvent")
			end
		end)
	end
end

local function setFunctions(Bindable: Bindable, newInstructions: Dictionary)
	local functions = Bindable.Functions

	for instruction: string, callback in pairs(newInstructions) do
		functions[instruction] = callback
	end
end

function Bindables.handleFunctions(Bindable: Bindable, newInstructions: Dictionary)
	setFunctions(Bindable, newInstructions)
end

return Bindables
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">38d136ec74d9240302cc7f550007aa15</UniqueId>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXe516ae2b515b4f9e8be6c7a62b8008e3">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Configurations</string>
				<string name="ScriptGuid">{E8C1EACA-A421-4CD1-9750-B7171450447D}</string>
				<ProtectedString name="Source"><![CDATA[local Configurations = {}

Configurations.CAN_RESET = false

Configurations.CORE_GUI_SETTINGS = {
	[Enum.CoreGuiType.Backpack] = false,
	[Enum.CoreGuiType.Chat] = false,
	[Enum.CoreGuiType.EmotesMenu] = false,
	[Enum.CoreGuiType.Health] = false,
	[Enum.CoreGuiType.PlayerList] = false,
}
Configurations.ChatActive = false

--| SHARED:
Configurations.COLLECTION_TAGS = {}

Configurations.Attributes = {}

return Configurations
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">38d136ec74d9240302cc7f550007aa17</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="LuaWebService" referent="RBX42bcd04c47eb4fc6a7f147f536c7303d">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d68</UniqueId>
		</Properties>
	</Item>
	<Item class="ProcessInstancePhysicsService" referent="RBX1f4fe3805ae84af4b4264a2df5fefc30">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ProcessInstancePhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013d69</UniqueId>
		</Properties>
	</Item>
	<Item class="LanguageService" referent="RBX3d389af148bc4692a6615736a0327a6c">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LanguageService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013f3f</UniqueId>
		</Properties>
	</Item>
	<Item class="Lighting" referent="RBX393f67323bd54a16939232bc83dde659">
		<Properties>
			<Color3 name="Ambient">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="Brightness">0</float>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<float name="EnvironmentDiffuseScale">0</float>
			<float name="EnvironmentSpecularScale">0</float>
			<float name="ExposureCompensation">0</float>
			<Color3 name="FogColor">
				<R>0.752941251</R>
				<G>0.752941251</G>
				<B>0.752941251</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">0</float>
			<bool name="GlobalShadows">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<bool name="Outlines">false</bool>
			<float name="ShadowSoftness">0.200000003</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">1</token>
			<string name="TimeOfDay">00:00:00</string>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013db2</UniqueId>
		</Properties>
	</Item>
	<Item class="LodDataService" referent="RBX5e97a480b238494f8ca87eac59988f0b">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013db5</UniqueId>
		</Properties>
	</Item>
	<Item class="DataStoreService" referent="RBXd2b2267c643c471f91b5727f83199fb5">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutomaticRetry">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LegacyNamingScheme">false</bool>
			<string name="Name">DataStoreService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013f47</UniqueId>
		</Properties>
	</Item>
	<Item class="HttpService" referent="RBX5c7b09fb4110424e8ec7a3a3809e144e">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="HttpEnabled">false</bool>
			<string name="Name">HttpService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013f4a</UniqueId>
		</Properties>
	</Item>
	<Item class="Teams" referent="RBX9e33b9b8c34d45899a6935f22ff0dc6c">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Teams</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013f52</UniqueId>
		</Properties>
	</Item>
	<Item class="TestService" referent="RBXa4ae0001c0c7460e9187e41089f013f9">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoRuns">true</bool>
			<string name="Description"></string>
			<bool name="ExecuteWithStudioRun">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="Is30FpsThrottleEnabled">true</bool>
			<bool name="IsPhysicsEnvironmentalThrottled">true</bool>
			<bool name="IsSleepAllowed">true</bool>
			<string name="Name">TestService</string>
			<int name="NumberOfPlayers">0</int>
			<double name="SimulateSecondsLag">0</double>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<double name="Timeout">10</double>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013f54</UniqueId>
		</Properties>
		<Item class="Folder" referent="RBX59c738db40174d1984073273c776b34e">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">DevPackages</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">1517939d06f7510002cb45270001a06d</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="RBXc6e29b143b744ea996646bdd91fcc6b0">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TestEZ</string>
					<string name="ScriptGuid">{a2874bb9-c28b-40a8-8354-6afdfd42f235}</string>
					<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["ruizukun-dev_testez@0.4.8"]["testez"])
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003289</UniqueId>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXbd0d60cd253a4358af617a208c060591">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">_Index</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">118b823fbc6f4004040d84d9000032fb</UniqueId>
				</Properties>
				<Item class="Folder" referent="RBXd0b28fad98f4403b995123e75a23429e">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">ruizukun-dev_testez@0.4.8</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">118b823fbc6f4004040d84d9000032fc</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBXf86746e66254454ea72e2db4535c9be8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">testez</string>
							<string name="ScriptGuid">{94a98013-864d-4fd5-8055-f7ebaafa399e}</string>
							<ProtectedString name="Source"><![CDATA[local Expectation = require(script.Expectation)
local TestBootstrap = require(script.TestBootstrap)
local TestEnum = require(script.TestEnum)
local TestPlan = require(script.TestPlan)
local TestPlanner = require(script.TestPlanner)
local TestResults = require(script.TestResults)
local TestRunner = require(script.TestRunner)
local TestSession = require(script.TestSession)
local TextReporter = require(script.Reporters.TextReporter)
local TextReporterQuiet = require(script.Reporters.TextReporterQuiet)
local TeamCityReporter = require(script.Reporters.TeamCityReporter)

local function run(testRoot, callback)
	local modules = TestBootstrap:getModules(testRoot)
	local plan = TestPlanner.createPlan(modules)
	local results = TestRunner.runPlan(plan)

	callback(results)
end

local TestEZ = {
	run = run,
	Expectation = Expectation,
	TestBootstrap = TestBootstrap,
	TestEnum = TestEnum,
	TestPlan = TestPlan,
	TestPlanner = TestPlanner,
	TestResults = TestResults,
	TestRunner = TestRunner,
	TestSession = TestSession,
	Reporters = {
		TextReporter = TextReporter,
		TextReporterQuiet = TextReporterQuiet,
		TeamCityReporter = TeamCityReporter,
	},
}

return TestEZ
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags">V2FsbHk=</BinaryString>
							<UniqueId name="UniqueId">118b823fbc6f4004040d84d9000032fd</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX5bf229b3cb5b4a2cb3233ef4384f760b">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Context</string>
								<string name="ScriptGuid">{6c707902-262c-4b04-ba80-0c39c9a282e8}</string>
								<ProtectedString name="Source"><![CDATA[local Context = {}

function Context.new(parent)
	local meta = {}
	local index = {}

	meta.__index = index

	if parent then
		for key, value in pairs(getmetatable(parent).__index) do
			index[key] = value
		end
	end

	function meta.__newindex(_obj, key, value)
		assert(index[key] == nil, string.format("Cannot reassign %s in context", tostring(key)))

		index[key] = value
	end

	return setmetatable({}, meta)
end

return Context
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d9000032fe</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXa3aa0097c8244b378ead6891dbabb56c">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Expectation</string>
								<string name="ScriptGuid">{ce9089bd-b6e3-4c2d-be0d-236b9d10c89b}</string>
								<ProtectedString name="Source"><![CDATA[local Expectation = {}
local SELF_KEYS = {
	to = true,
	be = true,
	been = true,
	have = true,
	was = true,
	at = true,
}
local NEGATION_KEYS = { never = true }

local function assertLevel(condition, message, level)
	message = message or "Assertion failed!"
	level = level or 1

	if not condition then
		error(message, level + 1)
	end
end
local function bindSelf(self, method)
	return function(firstArg, ...)
		if firstArg == self then
			return method(self, ...)
		else
			return method(self, firstArg, ...)
		end
	end
end
local function formatMessage(result, trueMessage, falseMessage)
	if result then
		return trueMessage
	else
		return falseMessage
	end
end

function Expectation.new(value)
	local self = {
		value = value,
		successCondition = true,
		condition = false,
		matchers = {},
		_boundMatchers = {},
	}

	setmetatable(self, Expectation)

	self.a = bindSelf(self, self.a)
	self.an = self.a
	self.ok = bindSelf(self, self.ok)
	self.equal = bindSelf(self, self.equal)
	self.throw = bindSelf(self, self.throw)
	self.near = bindSelf(self, self.near)

	return self
end
function Expectation.checkMatcherNameCollisions(name)
	if SELF_KEYS[name] or NEGATION_KEYS[name] or Expectation[name] then
		return false
	end

	return true
end
function Expectation:extend(matchers)
	self.matchers = matchers or {}

	for name, implementation in pairs(self.matchers) do
		self._boundMatchers[name] = bindSelf(self, function(_self, ...)
			local result = implementation(self.value, ...)
			local pass = result.pass == self.successCondition

			assertLevel(pass, result.message, 3)
			self:_resetModifiers()

			return self
		end)
	end

	return self
end
function Expectation.__index(self, key)
	if SELF_KEYS[key] then
		return self
	end
	if NEGATION_KEYS[key] then
		local newExpectation = Expectation.new(self.value):extend(self.matchers)

		newExpectation.successCondition = not self.successCondition

		return newExpectation
	end
	if self._boundMatchers[key] then
		return self._boundMatchers[key]
	end

	return Expectation[key]
end
function Expectation:_resetModifiers()
	self.successCondition = true
end
function Expectation:a(typeName)
	local result = (type(self.value) == typeName) == self.successCondition
	local message = formatMessage(
		self.successCondition,
		("Expected value of type %q, got value %q of type %s"):format(typeName, tostring(self.value), type(self.value)),
		("Expected value not of type %q, got value %q of type %s"):format(
			typeName,
			tostring(self.value),
			type(self.value)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

Expectation.an = Expectation.a

function Expectation:ok()
	local result = (self.value ~= nil) == self.successCondition
	local message = formatMessage(
		self.successCondition,
		("Expected value %q to be non-nil"):format(tostring(self.value)),
		("Expected value %q to be nil"):format(tostring(self.value))
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end
function Expectation:equal(otherValue)
	local result = (self.value == otherValue) == self.successCondition
	local message = formatMessage(
		self.successCondition,
		("Expected value %q (%s), got %q (%s) instead"):format(
			tostring(otherValue),
			type(otherValue),
			tostring(self.value),
			type(self.value)
		),
		("Expected anything but value %q (%s)"):format(tostring(otherValue), type(otherValue))
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end
function Expectation:near(otherValue, limit)
	assert(type(self.value) == "number", "Expectation value must be a number to use 'near'")
	assert(type(otherValue) == "number", "otherValue must be a number")
	assert(type(limit) == "number" or limit == nil, "limit must be a number or nil")

	limit = limit or 1e-7

	local result = (math.abs(self.value - otherValue) <= limit) == self.successCondition
	local message = formatMessage(
		self.successCondition,
		("Expected value to be near %f (within %f) but got %f instead"):format(otherValue, limit, self.value),
		([[Expected value to not be near %f (within %f) but got %f instead]]):format(otherValue, limit, self.value)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end
function Expectation:throw(messageSubstring)
	local ok, err = pcall(self.value)
	local result = ok ~= self.successCondition

	if messageSubstring and not ok then
		if self.successCondition then
			result = err:find(messageSubstring, 1, true) ~= nil
		else
			result = err:find(messageSubstring, 1, true) == nil
		end
	end

	local message

	if messageSubstring then
		message = formatMessage(
			self.successCondition,
			([[Expected function to throw an error containing %q, but it %s]]):format(
				messageSubstring,
				err and ("threw: %s"):format(err) or "did not throw."
			),
			([[Expected function to never throw an error containing %q, but it threw: %s]]):format(
				messageSubstring,
				tostring(err)
			)
		)
	else
		message = formatMessage(
			self.successCondition,
			"Expected function to throw an error, but it did not throw.",
			("Expected function to succeed, but it threw an error: %s"):format(tostring(err))
		)
	end

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

return Expectation
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d9000032ff</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX4c28f8bd66e14a6e942f1d88d173c382">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ExpectationContext</string>
								<string name="ScriptGuid">{d69ca198-5b6b-4d34-9752-fd898f10eaa4}</string>
								<ProtectedString name="Source"><![CDATA[local Expectation = require(script.Parent.Expectation)
local checkMatcherNameCollisions = Expectation.checkMatcherNameCollisions

local function copy(t)
	local result = {}

	for key, value in pairs(t) do
		result[key] = value
	end

	return result
end

local ExpectationContext = {}

ExpectationContext.__index = ExpectationContext

function ExpectationContext.new(parent)
	local self = {
		_extensions = parent and copy(parent._extensions) or {},
	}

	return setmetatable(self, ExpectationContext)
end
function ExpectationContext:startExpectationChain(...)
	return Expectation.new(...):extend(self._extensions)
end
function ExpectationContext:extend(config)
	for key, value in pairs(config) do
		assert(self._extensions[key] == nil, string.format("Cannot reassign %q in expect.extend", key))
		assert(checkMatcherNameCollisions(key), string.format("Cannot overwrite matcher %q; it already exists", key))

		self._extensions[key] = value
	end
end

return ExpectationContext
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003300</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX2be908f5c2aa4e06a99c4c71e9de8126">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">LifecycleHooks</string>
								<string name="ScriptGuid">{eaae7a9a-7a2a-4fc2-b6fc-3eb77c33e0a1}</string>
								<ProtectedString name="Source"><![CDATA[local TestEnum = require(script.Parent.TestEnum)
local LifecycleHooks = {}

LifecycleHooks.__index = LifecycleHooks

function LifecycleHooks.new()
	local self = { _stack = {} }

	return setmetatable(self, LifecycleHooks)
end
function LifecycleHooks:getBeforeEachHooks()
	local key = TestEnum.NodeType.BeforeEach
	local hooks = {}

	for _, level in ipairs(self._stack) do
		for _, hook in ipairs(level[key]) do
			table.insert(hooks, hook)
		end
	end

	return hooks
end
function LifecycleHooks:getAfterEachHooks()
	local key = TestEnum.NodeType.AfterEach
	local hooks = {}

	for _, level in ipairs(self._stack) do
		for _, hook in ipairs(level[key]) do
			table.insert(hooks, 1, hook)
		end
	end

	return hooks
end
function LifecycleHooks:popHooks()
	table.remove(self._stack, #self._stack)
end
function LifecycleHooks:pushHooksFrom(planNode)
	assert(planNode ~= nil)
	table.insert(self._stack, {
		[TestEnum.NodeType.BeforeAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeAll),
		[TestEnum.NodeType.AfterAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterAll),
		[TestEnum.NodeType.BeforeEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeEach),
		[TestEnum.NodeType.AfterEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterEach),
	})
end
function LifecycleHooks:getBeforeAllHooks()
	return self._stack[#self._stack][TestEnum.NodeType.BeforeAll]
end
function LifecycleHooks:getAfterAllHooks()
	return self._stack[#self._stack][TestEnum.NodeType.AfterAll]
end
function LifecycleHooks:_getHooksOfType(nodes, key)
	local hooks = {}

	for _, node in ipairs(nodes) do
		if node.type == key then
			table.insert(hooks, node.callback)
		end
	end

	return hooks
end

return LifecycleHooks
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003301</UniqueId>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBXb99d404f29634d05a0051a9f43e22a54">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">Reporters</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003302</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXcdc935a45d174a198d606d98d6b7deeb">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">TeamCityReporter</string>
									<string name="ScriptGuid">{4ffd80f9-4a92-46d1-b743-0b0cbd527482}</string>
									<ProtectedString name="Source"><![CDATA[local TestService = game:GetService("TestService")
local TestEnum = require(script.Parent.Parent.TestEnum)
local TeamCityReporter = {}

local function teamCityEscape(str)
	str = string.gsub(str, "([]|'[])", "|%1")
	str = string.gsub(str, "\r", "|r")
	str = string.gsub(str, "\n", "|n")

	return str
end
local function teamCityEnterSuite(suiteName)
	return string.format("##teamcity[testSuiteStarted name='%s']", teamCityEscape(suiteName))
end
local function teamCityLeaveSuite(suiteName)
	return string.format("##teamcity[testSuiteFinished name='%s']", teamCityEscape(suiteName))
end
local function teamCityEnterCase(caseName)
	return string.format("##teamcity[testStarted name='%s']", teamCityEscape(caseName))
end
local function teamCityLeaveCase(caseName)
	return string.format("##teamcity[testFinished name='%s']", teamCityEscape(caseName))
end
local function teamCityFailCase(caseName, errorMessage)
	return string.format(
		"##teamcity[testFailed name='%s' message='%s']",
		teamCityEscape(caseName),
		teamCityEscape(errorMessage)
	)
end
local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end
	if node.planNode.type == TestEnum.NodeType.Describe then
		table.insert(buffer, teamCityEnterSuite(node.planNode.phrase))

		for _, child in ipairs(node.children) do
			reportNode(child, buffer, level + 1)
		end

		table.insert(buffer, teamCityLeaveSuite(node.planNode.phrase))
	else
		table.insert(buffer, teamCityEnterCase(node.planNode.phrase))

		if node.status == TestEnum.TestStatus.Failure then
			table.insert(buffer, teamCityFailCase(node.planNode.phrase, table.concat(node.errors, "\n")))
		end

		table.insert(buffer, teamCityLeaveCase(node.planNode.phrase))
	end
end
local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end
local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TeamCityReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(results.successCount, results.failureCount, results.skippedCount),
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end
	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)
			print("")
		end
	end
end

return TeamCityReporter
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003303</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXd134a980e4934ae98437bc2e3fff5c94">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">TextReporter</string>
									<string name="ScriptGuid">{306fdd4c-3f0d-40eb-bd73-0054f01d26dd}</string>
									<ProtectedString name="Source"><![CDATA[local TestService = game:GetService("TestService")
local TestEnum = require(script.Parent.Parent.TestEnum)
local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~",
}
local UNKNOWN_STATUS_SYMBOL = "?"
local TextReporter = {}

local function compareNodes(a, b)
	return a.planNode.phrase:lower() < b.planNode.phrase:lower()
end
local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(INDENT:rep(level), symbol, node.planNode.phrase)
	else
		line = ("%s%s"):format(INDENT:rep(level), node.planNode.phrase)
	end

	table.insert(buffer, line)
	table.sort(node.children, compareNodes)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end
local function reportRoot(node)
	local buffer = {}

	table.sort(node.children, compareNodes)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end
local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(results.successCount, results.failureCount, results.skippedCount),
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end
	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)
			print("")
		end
	end
end

return TextReporter
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003304</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX95f49efe934f413791607f403505cd37">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">TextReporterQuiet</string>
									<string name="ScriptGuid">{6321a93b-d0f5-4114-affa-dd386bd59141}</string>
									<ProtectedString name="Source"><![CDATA[local TestService = game:GetService("TestService")
local TestEnum = require(script.Parent.Parent.TestEnum)
local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~",
}
local UNKNOWN_STATUS_SYMBOL = "?"
local TextReporterQuiet = {}

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status ~= TestEnum.TestStatus.Success then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(INDENT:rep(level), symbol, node.planNode.phrase)
	end

	table.insert(buffer, line)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end
local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end
local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporterQuiet.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(results.successCount, results.failureCount, results.skippedCount),
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end
	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)
			print("")
		end
	end
end

return TextReporterQuiet
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003305</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXef4a2cc982c04f29b9b485688d435293">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TestBootstrap</string>
								<string name="ScriptGuid">{0ce71330-2a4f-470a-b4e6-ca842be032e7}</string>
								<ProtectedString name="Source"><![CDATA[local TestPlanner = require(script.Parent.TestPlanner)
local TestRunner = require(script.Parent.TestRunner)
local TextReporter = require(script.Parent.Reporters.TextReporter)
local TestBootstrap = {}

local function stripSpecSuffix(name)
	return (name:gsub("%.spec$", ""))
end
local function isSpecScript(aScript)
	return aScript:IsA("ModuleScript") and aScript.Name:match("%.spec$")
end
local function getPath(module, root)
	root = root or game

	local path = {}
	local last = module

	if last.Name == "init.spec" then
		last = last.Parent
	end

	while last ~= nil and last ~= root do
		table.insert(path, stripSpecSuffix(last.Name))

		last = last.Parent
	end

	table.insert(path, stripSpecSuffix(root.Name))

	return path
end
local function toStringPath(tablePath)
	local stringPath = ""
	local first = true

	for _, element in ipairs(tablePath) do
		if first then
			stringPath = element
			first = false
		else
			stringPath = element .. " " .. stringPath
		end
	end

	return stringPath
end

function TestBootstrap:getModulesImpl(root, modules, current)
	modules = modules or {}
	current = current or root

	if isSpecScript(current) then
		local method = require(current)
		local path = getPath(current, root)
		local pathString = toStringPath(path)

		table.insert(modules, {
			method = method,
			path = path,
			pathStringForSorting = pathString:lower(),
		})
	end
end
function TestBootstrap:getModules(root)
	local modules = {}

	self:getModulesImpl(root, modules)

	for _, child in ipairs(root:GetDescendants()) do
		self:getModulesImpl(root, modules, child)
	end

	return modules
end
function TestBootstrap:run(roots, reporter, otherOptions)
	reporter = reporter or TextReporter
	otherOptions = otherOptions or {}

	local showTimingInfo = otherOptions.showTimingInfo or false
	local testNamePattern = otherOptions.testNamePattern
	local extraEnvironment = otherOptions.extraEnvironment or {}

	if type(roots) ~= "table" then
		error(([[Bad argument #1 to TestBootstrap:run. Expected table, got %s]]):format(typeof(roots)), 2)
	end

	local startTime = tick()
	local modules = {}

	for _, subRoot in ipairs(roots) do
		local newModules = self:getModules(subRoot)

		for _, newModule in ipairs(newModules) do
			table.insert(modules, newModule)
		end
	end

	local afterModules = tick()
	local plan = TestPlanner.createPlan(modules, testNamePattern, extraEnvironment)
	local afterPlan = tick()
	local results = TestRunner.runPlan(plan)
	local afterRun = tick()

	reporter.report(results)

	local afterReport = tick()

	if showTimingInfo then
		local timing = {
			("Took %f seconds to locate test modules"):format(afterModules - startTime),
			("Took %f seconds to create test plan"):format(afterPlan - afterModules),
			("Took %f seconds to run tests"):format(afterRun - afterPlan),
			("Took %f seconds to report tests"):format(afterReport - afterRun),
		}

		print(table.concat(timing, "\n"))
	end

	return results
end

return TestBootstrap
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003306</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXea61b1c657614bc49a4a75d385596dd5">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TestEnum</string>
								<string name="ScriptGuid">{17161058-811c-4dbb-a6a1-2cb61d252196}</string>
								<ProtectedString name="Source"><![CDATA[local TestEnum = {}

TestEnum.TestStatus = {
	Success = "Success",
	Failure = "Failure",
	Skipped = "Skipped",
}
TestEnum.NodeType = {
	Describe = "Describe",
	It = "It",
	BeforeAll = "BeforeAll",
	AfterAll = "AfterAll",
	BeforeEach = "BeforeEach",
	AfterEach = "AfterEach",
}
TestEnum.NodeModifier = {
	None = "None",
	Skip = "Skip",
	Focus = "Focus",
}

return TestEnum
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003307</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX766b299ff1ea4e4d8f2e0fd4b1457d53">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TestPlan</string>
								<string name="ScriptGuid">{dea0959e-99c9-43d3-9c4e-d3ac7e5e71f4}</string>
								<ProtectedString name="Source"><![CDATA[local TestEnum = require(script.Parent.TestEnum)
local Expectation = require(script.Parent.Expectation)

local function newEnvironment(currentNode, extraEnvironment)
	local env = {}

	if extraEnvironment then
		if type(extraEnvironment) ~= "table" then
			error(("Bad argument #2 to newEnvironment. Expected table, got %s"):format(typeof(extraEnvironment)), 2)
		end

		for key, value in pairs(extraEnvironment) do
			env[key] = value
		end
	end

	local function addChild(phrase, callback, nodeType, nodeModifier)
		local node = currentNode:addChild(phrase, nodeType, nodeModifier)

		node.callback = callback

		if nodeType == TestEnum.NodeType.Describe then
			node:expand()
		end

		return node
	end

	function env.describeFOCUS(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Focus)
	end
	function env.describeSKIP(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Skip)
	end
	function env.describe(phrase, callback, nodeModifier)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.None)
	end
	function env.itFOCUS(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Focus)
	end
	function env.itSKIP(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)
	end
	function env.itFIXME(phrase, callback)
		local node = addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)

		warn("FIXME: broken test", node:getFullName())
	end
	function env.it(phrase, callback, nodeModifier)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.None)
	end

	local lifecyclePhaseId = 0
	local lifecycleHooks = {
		[TestEnum.NodeType.BeforeAll] = "beforeAll",
		[TestEnum.NodeType.AfterAll] = "afterAll",
		[TestEnum.NodeType.BeforeEach] = "beforeEach",
		[TestEnum.NodeType.AfterEach] = "afterEach",
	}

	for nodeType, name in pairs(lifecycleHooks) do
		env[name] = function(callback)
			addChild(name .. "_" .. tostring(lifecyclePhaseId), callback, nodeType, TestEnum.NodeModifier.None)

			lifecyclePhaseId = lifecyclePhaseId + 1
		end
	end

	function env.FIXME(optionalMessage)
		warn("FIXME: broken test", currentNode:getFullName(), optionalMessage or "")

		currentNode.modifier = TestEnum.NodeModifier.Skip
	end
	function env.FOCUS()
		currentNode.modifier = TestEnum.NodeModifier.Focus
	end
	function env.SKIP()
		currentNode.modifier = TestEnum.NodeModifier.Skip
	end
	function env.HACK_NO_XPCALL()
		warn(
			[[HACK_NO_XPCALL is deprecated. It is now safe to yield in an xpcall, so this is no longer necessary. It can be safely deleted.]]
		)
	end

	env.fit = env.itFOCUS
	env.xit = env.itSKIP
	env.fdescribe = env.describeFOCUS
	env.xdescribe = env.describeSKIP
	env.expect = setmetatable({
		extend = function(...)
			error('Cannot call "expect.extend" from within a "describe" node.')
		end,
	}, {
		__call = function(_self, ...)
			return Expectation.new(...)
		end,
	})

	return env
end

local TestNode = {}

TestNode.__index = TestNode

function TestNode.new(plan, phrase, nodeType, nodeModifier)
	nodeModifier = nodeModifier or TestEnum.NodeModifier.None

	local node = {
		plan = plan,
		phrase = phrase,
		type = nodeType,
		modifier = nodeModifier,
		children = {},
		callback = nil,
		parent = nil,
	}

	node.environment = newEnvironment(node, plan.extraEnvironment)

	return setmetatable(node, TestNode)
end

local function getModifier(name, pattern, modifier)
	if pattern and (modifier == nil or modifier == TestEnum.NodeModifier.None) then
		if name:match(pattern) then
			return TestEnum.NodeModifier.Focus
		else
			return TestEnum.NodeModifier.Skip
		end
	end

	return modifier
end

function TestNode:addChild(phrase, nodeType, nodeModifier)
	if nodeType == TestEnum.NodeType.It then
		for _, child in pairs(self.children) do
			if child.phrase == phrase then
				error("Duplicate it block found: " .. child:getFullName())
			end
		end
	end

	local childName = self:getFullName() .. " " .. phrase

	nodeModifier = getModifier(childName, self.plan.testNamePattern, nodeModifier)

	local child = TestNode.new(self.plan, phrase, nodeType, nodeModifier)

	child.parent = self

	table.insert(self.children, child)

	return child
end
function TestNode:getFullName()
	if self.parent then
		local parentPhrase = self.parent:getFullName()

		if parentPhrase then
			return parentPhrase .. " " .. self.phrase
		end
	end

	return self.phrase
end
function TestNode:expand()
	local originalEnv = getfenv(self.callback)
	local callbackEnv = setmetatable({}, { __index = originalEnv })

	for key, value in pairs(self.environment) do
		callbackEnv[key] = value
	end

	callbackEnv.script = originalEnv.script

	setfenv(self.callback, callbackEnv)

	local success, result = xpcall(self.callback, function(message)
		return debug.traceback(tostring(message), 2)
	end)

	if not success then
		self.loadError = result
	end
end

local TestPlan = {}

TestPlan.__index = TestPlan

function TestPlan.new(testNamePattern, extraEnvironment)
	local plan = {
		children = {},
		testNamePattern = testNamePattern,
		extraEnvironment = extraEnvironment,
	}

	return setmetatable(plan, TestPlan)
end
function TestPlan:addChild(phrase, nodeType, nodeModifier)
	nodeModifier = getModifier(phrase, self.testNamePattern, nodeModifier)

	local child = TestNode.new(self, phrase, nodeType, nodeModifier)

	table.insert(self.children, child)

	return child
end
function TestPlan:addRoot(path, method)
	local curNode = self

	for i = #path, 1, -1 do
		local nextNode = nil

		for _, child in ipairs(curNode.children) do
			if child.phrase == path[i] then
				nextNode = child

				break
			end
		end

		if nextNode == nil then
			nextNode = curNode:addChild(path[i], TestEnum.NodeType.Describe)
		end

		curNode = nextNode
	end

	curNode.callback = method

	curNode:expand()
end
function TestPlan:visitAllNodes(callback, root, level)
	root = root or self
	level = level or 0

	for _, child in ipairs(root.children) do
		callback(child, level)
		self:visitAllNodes(callback, child, level + 1)
	end
end
function TestPlan:visualize()
	local buffer = {}

	self:visitAllNodes(function(node, level)
		table.insert(buffer, (" "):rep(3 * level) .. node.phrase)
	end)

	return table.concat(buffer, "\n")
end
function TestPlan:findNodes(callback)
	local results = {}

	self:visitAllNodes(function(node)
		if callback(node) then
			table.insert(results, node)
		end
	end)

	return results
end

return TestPlan
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003308</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3c14ca82b00541b8b826ec226910a690">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TestPlanner</string>
								<string name="ScriptGuid">{b682e7cb-4584-46a5-99a0-baa899b22a3b}</string>
								<ProtectedString name="Source"><![CDATA[local TestPlan = require(script.Parent.TestPlan)
local TestPlanner = {}

function TestPlanner.createPlan(modulesList, testNamePattern, extraEnvironment)
	local plan = TestPlan.new(testNamePattern, extraEnvironment)

	table.sort(modulesList, function(a, b)
		return a.pathStringForSorting < b.pathStringForSorting
	end)

	for _, module in ipairs(modulesList) do
		plan:addRoot(module.path, module.method)
	end

	return plan
end

return TestPlanner
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d900003309</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3d028e9f0e8844edbcbd4e6a69da727e">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TestResults</string>
								<string name="ScriptGuid">{e5ead331-a98b-4bfd-bd0f-f8a764dce543}</string>
								<ProtectedString name="Source"><![CDATA[local TestEnum = require(script.Parent.TestEnum)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~",
}
local TestResults = {}

TestResults.__index = TestResults

function TestResults.new(plan)
	local self = {
		successCount = 0,
		failureCount = 0,
		skippedCount = 0,
		planNode = plan,
		children = {},
		errors = {},
	}

	setmetatable(self, TestResults)

	return self
end
function TestResults.createNode(planNode)
	local node = {
		planNode = planNode,
		children = {},
		errors = {},
		status = nil,
	}

	return node
end
function TestResults:visitAllNodes(callback, root)
	root = root or self

	for _, child in ipairs(root.children) do
		callback(child)
		self:visitAllNodes(callback, child)
	end
end
function TestResults:visualize(root, level)
	root = root or self
	level = level or 0

	local buffer = {}

	for _, child in ipairs(root.children) do
		if child.planNode.type == TestEnum.NodeType.It then
			local symbol = STATUS_SYMBOLS[child.status] or "?"
			local str = ("%s[%s] %s"):format((" "):rep(3 * level), symbol, child.planNode.phrase)

			if child.messages and #child.messages > 0 then
				str = str
					.. "\n "
					.. (" "):rep(3 * level)
					.. table.concat(child.messages, "\n " .. (" "):rep(3 * level))
			end

			table.insert(buffer, str)
		else
			local str = ("%s%s"):format((" "):rep(3 * level), child.planNode.phrase or "")

			if child.status then
				str = str .. (" (%s)"):format(child.status)
			end

			table.insert(buffer, str)

			if #child.children > 0 then
				local text = self:visualize(child, level + 1)

				table.insert(buffer, text)
			end
		end
	end

	return table.concat(buffer, "\n")
end

return TestResults
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d90000330a</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXb127e480581d4f80ba745c1acab567dc">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TestRunner</string>
								<string name="ScriptGuid">{22764e83-e676-4791-8103-f92fe35dbf79}</string>
								<ProtectedString name="Source"><![CDATA[local TestEnum = require(script.Parent.TestEnum)
local TestSession = require(script.Parent.TestSession)
local LifecycleHooks = require(script.Parent.LifecycleHooks)
local RUNNING_GLOBAL = "__TESTEZ_RUNNING_TEST__"
local TestRunner = { environment = {} }

local function wrapExpectContextWithPublicApi(expectationContext)
	return setmetatable({
		extend = function(...)
			expectationContext:extend(...)
		end,
	}, {
		__call = function(_self, ...)
			return expectationContext:startExpectationChain(...)
		end,
	})
end

function TestRunner.runPlan(plan)
	local session = TestSession.new(plan)
	local lifecycleHooks = LifecycleHooks.new()
	local exclusiveNodes = plan:findNodes(function(node)
		return node.modifier == TestEnum.NodeModifier.Focus
	end)

	session.hasFocusNodes = #exclusiveNodes > 0

	TestRunner.runPlanNode(session, plan, lifecycleHooks)

	return session:finalize()
end
function TestRunner.runPlanNode(session, planNode, lifecycleHooks)
	local function runCallback(callback, messagePrefix)
		local success = true
		local errorMessage

		_G[RUNNING_GLOBAL] = true
		messagePrefix = messagePrefix or ""

		local testEnvironment = getfenv(callback)

		for key, value in pairs(TestRunner.environment) do
			testEnvironment[key] = value
		end

		testEnvironment.fail = function(message)
			if message == nil then
				message = "fail() was called."
			end

			success = false
			errorMessage = messagePrefix .. debug.traceback(tostring(message), 2)
		end
		testEnvironment.expect = wrapExpectContextWithPublicApi(session:getExpectationContext())

		local context = session:getContext()
		local nodeSuccess, nodeResult = xpcall(function()
			callback(context)
		end, function(message)
			return messagePrefix .. debug.traceback(tostring(message), 2)
		end)

		if not nodeSuccess then
			success = false
			errorMessage = nodeResult
		end

		_G[RUNNING_GLOBAL] = nil

		return success, errorMessage
	end
	local function runNode(childPlanNode)
		for _, hook in ipairs(lifecycleHooks:getBeforeEachHooks()) do
			local success, errorMessage = runCallback(hook, "beforeEach hook: ")

			if not success then
				return false, errorMessage
			end
		end

		local testSuccess, testErrorMessage = runCallback(childPlanNode.callback)

		for _, hook in ipairs(lifecycleHooks:getAfterEachHooks()) do
			local success, errorMessage = runCallback(hook, "afterEach hook: ")

			if not success then
				if not testSuccess then
					return false,
						testErrorMessage .. [[

While cleaning up the failed test another error was found:
]] .. errorMessage
				end

				return false, errorMessage
			end
		end

		if not testSuccess then
			return false, testErrorMessage
		end

		return true, nil
	end

	lifecycleHooks:pushHooksFrom(planNode)

	local halt = false

	for _, hook in ipairs(lifecycleHooks:getBeforeAllHooks()) do
		local success, errorMessage = runCallback(hook, "beforeAll hook: ")

		if not success then
			session:addDummyError("beforeAll", errorMessage)

			halt = true
		end
	end

	if not halt then
		for _, childPlanNode in ipairs(planNode.children) do
			if childPlanNode.type == TestEnum.NodeType.It then
				session:pushNode(childPlanNode)

				if session:shouldSkip() then
					session:setSkipped()
				else
					local success, errorMessage = runNode(childPlanNode)

					if success then
						session:setSuccess()
					else
						session:setError(errorMessage)
					end
				end

				session:popNode()
			elseif childPlanNode.type == TestEnum.NodeType.Describe then
				session:pushNode(childPlanNode)
				TestRunner.runPlanNode(session, childPlanNode, lifecycleHooks)

				if childPlanNode.loadError then
					local message = "Error during planning: " .. childPlanNode.loadError

					session:setError(message)
				else
					session:setStatusFromChildren()
				end

				session:popNode()
			end
		end
	end

	for _, hook in ipairs(lifecycleHooks:getAfterAllHooks()) do
		local success, errorMessage = runCallback(hook, "afterAll hook: ")

		if not success then
			session:addDummyError("afterAll", errorMessage)
		end
	end

	lifecycleHooks:popHooks()
end

return TestRunner
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d90000330b</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXf6c5257a8dfe4bee9df4087add692599">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TestSession</string>
								<string name="ScriptGuid">{b5418cec-02d2-4e7e-aeb6-d0d94e621ee9}</string>
								<ProtectedString name="Source"><![CDATA[local TestEnum = require(script.Parent.TestEnum)
local TestResults = require(script.Parent.TestResults)
local Context = require(script.Parent.Context)
local ExpectationContext = require(script.Parent.ExpectationContext)
local TestSession = {}

TestSession.__index = TestSession

function TestSession.new(plan)
	local self = {
		results = TestResults.new(plan),
		nodeStack = {},
		contextStack = {},
		expectationContextStack = {},
		hasFocusNodes = false,
	}

	setmetatable(self, TestSession)

	return self
end
function TestSession:calculateTotals()
	local results = self.results

	results.successCount = 0
	results.failureCount = 0
	results.skippedCount = 0

	results:visitAllNodes(function(node)
		local status = node.status
		local nodeType = node.planNode.type

		if nodeType == TestEnum.NodeType.It then
			if status == TestEnum.TestStatus.Success then
				results.successCount = results.successCount + 1
			elseif status == TestEnum.TestStatus.Failure then
				results.failureCount = results.failureCount + 1
			elseif status == TestEnum.TestStatus.Skipped then
				results.skippedCount = results.skippedCount + 1
			end
		end
	end)
end
function TestSession:gatherErrors()
	local results = self.results

	results.errors = {}

	results:visitAllNodes(function(node)
		if #node.errors > 0 then
			for _, message in ipairs(node.errors) do
				table.insert(results.errors, message)
			end
		end
	end)
end
function TestSession:finalize()
	if #self.nodeStack ~= 0 then
		error("Cannot finalize TestResults with nodes still on the stack!", 2)
	end

	self:calculateTotals()
	self:gatherErrors()

	return self.results
end
function TestSession:pushNode(planNode)
	local node = TestResults.createNode(planNode)
	local lastNode = self.nodeStack[#self.nodeStack] or self.results

	table.insert(lastNode.children, node)
	table.insert(self.nodeStack, node)

	local lastContext = self.contextStack[#self.contextStack]
	local context = Context.new(lastContext)

	table.insert(self.contextStack, context)

	local lastExpectationContext = self.expectationContextStack[#self.expectationContextStack]
	local expectationContext = ExpectationContext.new(lastExpectationContext)

	table.insert(self.expectationContextStack, expectationContext)
end
function TestSession:popNode()
	assert(#self.nodeStack > 0, "Tried to pop from an empty node stack!")
	table.remove(self.nodeStack, #self.nodeStack)
	table.remove(self.contextStack, #self.contextStack)
	table.remove(self.expectationContextStack, #self.expectationContextStack)
end
function TestSession:getContext()
	assert(#self.contextStack > 0, "Tried to get context from an empty stack!")

	return self.contextStack[#self.contextStack]
end
function TestSession:getExpectationContext()
	assert(#self.expectationContextStack > 0, "Tried to get expectationContext from an empty stack!")

	return self.expectationContextStack[#self.expectationContextStack]
end
function TestSession:shouldSkip()
	if self.hasFocusNodes then
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end
			if node.planNode.modifier == TestEnum.NodeModifier.Focus then
				return false
			end
		end

		return true
	else
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end
		end
	end

	return false
end
function TestSession:setSuccess()
	assert(#self.nodeStack > 0, "Attempting to set success status on empty stack")

	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Success
end
function TestSession:setSkipped()
	assert(#self.nodeStack > 0, "Attempting to set skipped status on empty stack")

	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Skipped
end
function TestSession:setError(message)
	assert(#self.nodeStack > 0, "Attempting to set error status on empty stack")

	local last = self.nodeStack[#self.nodeStack]

	last.status = TestEnum.TestStatus.Failure

	table.insert(last.errors, message)
end
function TestSession:addDummyError(phrase, message)
	self:pushNode({
		type = TestEnum.NodeType.It,
		phrase = phrase,
	})
	self:setError(message)
	self:popNode()

	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Failure
end
function TestSession:setStatusFromChildren()
	assert(#self.nodeStack > 0, "Attempting to set status from children on empty stack")

	local last = self.nodeStack[#self.nodeStack]
	local status = TestEnum.TestStatus.Success
	local skipped = true

	for _, child in ipairs(last.children) do
		if child.status ~= TestEnum.TestStatus.Skipped then
			skipped = false

			if child.status == TestEnum.TestStatus.Failure then
				status = TestEnum.TestStatus.Failure
			end
		end
	end

	if skipped then
		status = TestEnum.TestStatus.Skipped
	end

	last.status = status
end

return TestSession
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">118b823fbc6f4004040d84d90000330c</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="BoolValue" referent="RBX27394f12961a42838b7dd3482b0640d9">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">ENABLE_DEBUG</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">1517939d06f7510002cb45270001a0e6</UniqueId>
				<bool name="Value">true</bool>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXc7b472b43cb940c6b4657cfbcadbfd11">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">FakePlayers</string>
				<string name="ScriptGuid">{F6C8794E-A9D4-425F-A263-2D702397F0E2}</string>
				<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")

local FakePlayers = {
	Array = {},
	Dictionary = {},
}

function FakePlayers.create(name: string): Configuration
	local fakeplayer = Instance.new("Configuration")
	fakeplayer.Name = name
	FakePlayers.Dictionary[name] = fakeplayer
	table.insert(FakePlayers.Array, fakeplayer)
	fakeplayer.Parent = Players
	return fakeplayer
end

function FakePlayers.get(name: string): Configuration
	return FakePlayers.Dictionary[name]
end

function FakePlayers.getPlayers()
	return FakePlayers.Array
end

function FakePlayers.remove(name: string)
	local fakeplayer = FakePlayers.get(name)
	FakePlayers.Dictionary[name] = nil
	local index = table.find(FakePlayers.Array, name)
	table.remove(FakePlayers.Array, index)
	fakeplayer:Destroy()
end

FakePlayers.create("mesa4070")

return FakePlayers
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">1517939d06f7510002cb45270002a447</UniqueId>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXab51026435634412830085745ae64278">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">testez</string>
				<string name="ScriptGuid">{20D427AA-39A9-49F4-A84C-2F339602595A}</string>
				<ProtectedString name="Source"><![CDATA[return require(game.TestService.DevPackages.testez)

]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">1517939d06f7510002cb45270002a449</UniqueId>
			</Properties>
		</Item>
		<Item class="BoolValue" referent="RBXe4e9b6143ca74003bf220354a28fa3d4">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">ENABLE_BENCHMARKER</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">67d4872af4cc4f6d02cb54530001a2b1</UniqueId>
				<bool name="Value">false</bool>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXbbc579d154b14b3a910f1466e198c13d">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ClientTests</string>
				<string name="ScriptGuid">{C59AF5DA-172D-413C-B6A2-9FD2208AE941}</string>
				<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

if RunService:IsStudio() then
	local TestService = game:GetService("TestService")
	if TestService.ENABLE_TESTS.Value then
		local TestEZ = require(TestService.testez)
		if RunService:IsClient() then
			local results = TestEZ.TestBootstrap:run({ script })
			if results.failureCount == 0 then
				print(script, "✅")
			else
				print(script, "❌")
				error("Tests failed")
			end
		end
	end
end

return {}
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags">QXV0by1SdW4gW0NsaWVudF0AV2FsbHk=</BinaryString>
				<UniqueId name="UniqueId">6bf83d196d25993702cb8fa20001a0ea</UniqueId>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX557404669829459dbcdaafe27dbd7d2f">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ServerTests</string>
				<string name="ScriptGuid">{BC81D60E-4F5C-445B-9CA6-7F708C4D449D}</string>
				<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

if RunService:IsStudio() then
	local TestService = game:GetService("TestService")
	if TestService.ENABLE_TESTS.Value then
		local TestEZ = require(TestService.testez)
		if RunService:IsServer() then
			local results = TestEZ.TestBootstrap:run({ script })
			if results.failureCount == 0 then
				print(script, "✅")
			else
				print(script, "❌")
				error("Tests failed")
			end
		end
	end
end

return {}
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags">QXV0by1SdW4gW1NlcnZlcl0AV2FsbHk=</BinaryString>
				<UniqueId name="UniqueId">6bf83d196d25993702cb8fa20001a0ec</UniqueId>
			</Properties>
		</Item>
		<Item class="BoolValue" referent="RBX14cc967534854192abf0a2ab9d5c1a71">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">ENABLE_TESTS</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">6bf83d196d25993702cb8fa20001a0ee</UniqueId>
				<bool name="Value">false</bool>
			</Properties>
		</Item>
	</Item>
	<Item class="VirtualInputManager" referent="RBXf2bb3184b3834ea4add738546ae93da3">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VirtualInputManager</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">20d1792214748cc902cb375400013f56</UniqueId>
		</Properties>
	</Item>
	<Item class="VoiceChatService" referent="RBX61a8e0ec94694640ade4ddf9689737d4">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="EnableDefaultVoice">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VoiceChatService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">354376ce1e53961902cc6be30001a17e</UniqueId>
		</Properties>
	</Item>
	<SharedStrings>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>