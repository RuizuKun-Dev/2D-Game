<roblox version="4">
  <Item class="ReplicatedStorage" referent="0">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="1">
      <Properties>
        <string name="Name">Packages</string>
      </Properties>
      <Item class="ModuleScript" referent="2">
        <Properties>
          <string name="Name">Nature2D</string>
          <string name="Source"><![CDATA[return require(script.Parent._Index["ruizukun-dev_nature2d@0.7.3"]["nature2d"])
]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="3">
        <Properties>
          <string name="Name">_Index</string>
        </Properties>
        <Item class="Folder" referent="4">
          <Properties>
            <string name="Name">ruizukun-dev_nature2d@0.7.3</string>
          </Properties>
          <Item class="ModuleScript" referent="5">
            <Properties>
              <string name="Name">nature2d</string>
              <string name="Source"><![CDATA[return require(script.Engine)
]]></string>
            </Properties>
            <Item class="Folder" referent="6">
              <Properties>
                <string name="Name">Constants</string>
              </Properties>
              <Item class="ModuleScript" referent="7">
                <Properties>
                  <string name="Name">Globals</string>
                  <string name="Source"><![CDATA[return {
	engineInit = {
		gravity = Vector2.new(0, 0.3),
		friction = 0.9,
		airfriction = 0.98,
		bounce = 0.8,
		timeSteps = 1,
		canvas = {
			topLeft = Vector2.new(0, 0),
			size = workspace.CurrentCamera.ViewportSize,
		},
	},
	universalMass = 1,
	speed = 55,
	properties = {
		"gravity",
		"friction",
		"collisionmultiplier",
		"airfriction",
		"universalmass",
	},
	rigidbody = {
		props = {
			"Object",
			"Collidable",
			"Anchored",
			"LifeSpan",
			"KeepInCanvas",
			"Gravity",
			"Friction",
			"AirFriction",
			"Structure",
			"Mass",
			"CanRotate",
		},
		must_have = {
			"Object",
		},
	},
	constraint = {
		color = Color3.new(1, 1, 1),
		thickness = 4,
		types = {
			"rope",
			"spring",
			"rod",
		},
		props = {
			"Type",
			"Point1",
			"Point2",
			"Visible",
			"Thickness",
			"RestLength",
			"SpringConstant",
			"Color",
		},
		must_have = {
			"Type",
			"Point1",
			"Point2",
		},
	},
	point = {
		radius = 2.5,
		color = Color3.new(1),
		uicRadius = UDim.new(1, 0),
		props = {
			"Position",
			"Visible",
			"Snap",
			"KeepInCanvas",
			"Radius",
			"Color",
		},
		must_have = {
			"Position",
		},
	},
	offset = Vector2.new(0, 36),
	VALID_OBJECT_PROPS = {
		"Position",
		"Visible",
		"Snap",
		"KeepInCanvas",
		"Radius",
		"Color",
		"Type",
		"Point1",
		"Point2",
		"Thickness",
		"RestLength",
		"SpringConstant",
		"Object",
		"Collidable",
		"Anchored",
		"LifeSpan",
		"Gravity",
		"Friction",
		"AirFriction",
		"Structure",
		"Mass",
		"CanRotate",
	},
	OBJECT_PROPS_TYPES = {
		Position = "Vector2",
		Visible = "boolean",
		Snap = "boolean",
		KeepInCanvas = "boolean",
		Radius = "number",
		Color = "Color3",
		Type = "string",
		Thickness = "number",
		RestLength = "number",
		SpringConstant = "number",
		Object = "Instance",
		Collidable = "boolean",
		Anchored = "boolean",
		LifeSpan = "number",
		Gravity = "Vector2",
		Friction = "number",
		AirFriction = "number",
		Structure = "table",
		Mass = "number",
		CanRotate = "boolean",
	},
}
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="8">
              <Properties>
                <string name="Name">Debugging</string>
              </Properties>
              <Item class="ModuleScript" referent="9">
                <Properties>
                  <string name="Name">Exceptions</string>
                  <string name="Source"><![CDATA[local TYPES = {
	NO_CANVAS_FOUND = "No canvas found, initialize the engine's canvas using Engine:CreateCanvas().",
	NO_RIGIDBODIES_FOUND = "No rigid bodies found on start.",
	PROPERTY_NOT_FOUND = "Invalid Argument #1. Property not found.",
	INVALID_CONSTRAINT_TYPE = "Received Invalid Constraint Type.",
	INVALID_CONSTRAINT_LENGTH = "Received Invalid Constraint Length.",
	INVALID_CONSTRAINT_THICKNESS = "Received Invalid Constraint Thickness.",
	SAME_ID = "Cannot ignore collisions for the same RigidBodies.",
	INVALID_RIGIDBODY = "Received Invalid RigidBody.",
	INVALID_OBJECT = "Received an Invalid Object. Valid objects - RigidBody, Point and Constraint.",
	INVALID_PROPERTY = "Received an Invalid Object Property.",
	MUST_HAVE_PROPERTY = "Missing must-have properties.",
	CANVAS_FRAME_NOT_FOUND = "No canvas frame found, initialize the canvas's frame to render custom Points and Constraints!",
	INVALID_TIME = "Received invalid time to apply force for.",
	ALREADY_STARTED = "Engine is already running.",
	CANNOT_SET_COLLISION_ITERATIONS = "Cannot set collision iterations! You must turn on quadtree usage using Engine:UseQuadtrees(true).",
}

return function(TASK: string, TYPE: string, details: string?)
	if TYPES[TYPE] then
		local exception = string.format("[Nature2D]: %s%s", TYPES[TYPE], if details then " " .. details else "")

		if TASK == "warn" then
			warn(exception)
		elseif TASK == "error" then
			error(exception, 2)
		end
	end
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="10">
                <Properties>
                  <string name="Name">Restrict</string>
                  <string name="Source"><![CDATA[return function(custom)
	if custom then
		error([[[Nature2D]: This method cannot be used with custom RigidBodies]], 2)
	end
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="11">
                <Properties>
                  <string name="Name">TypeErrors</string>
                  <string name="Source"><![CDATA[return function(arg, param, pos, expected)
	if typeof(param) ~= expected then
		error(
			string.format(
				[[[Nature2D]: Invalid Argument #%s. Expected type %q for %s, got %q]],
				tostring(pos),
				expected,
				arg,
				typeof(param)
			),
			2
		)
	end
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="12">
              <Properties>
                <string name="Name">Engine</string>
                <string name="Source"><![CDATA[-- #selene: allow(unused_variable)

local RigidBody = require(script.Parent.Physics.RigidBody)
local Point = require(script.Parent.Physics.Point)
local Constraint = require(script.Parent.Physics.Constraint)
local PhysicsRunner = require(script.Parent.Physics.Runner)
local Globals = require(script.Parent.Constants.Globals)
local Signal = require(script.Parent.Utilities.Signal)
local Quadtree = require(script.Parent.Utilities.Quadtree)
local Janitor = require(script.Parent.Utilities.Janitor)
local Types = require(script.Parent.Types)
local throwException = require(script.Parent.Debugging.Exceptions)
local throwTypeError = require(script.Parent.Debugging.TypeErrors)
local RunService = game:GetService("RunService")

local function SearchTable(t, a, lambda)
	for _, v in ipairs(t) do
		if lambda(a, v) then
			return v
		end
	end

	return nil
end

local Engine = {}

Engine.__index = Engine

function Engine.init(screengui)
	if not typeof(screengui) == "Instance" or not screengui:IsA("Instance") then
		error("Invalid Argument #1. 'screengui' must be a ScreenGui.", 2)
	end

	local self = setmetatable({
		bodies = {},
		constraints = {},
		points = {},
		connection = nil,
		_janitor = nil,
		gravity = Globals.engineInit.gravity,
		friction = Globals.engineInit.friction,
		airfriction = Globals.engineInit.airfriction,
		bounce = Globals.engineInit.bounce,
		timeSteps = Globals.engineInit.timeSteps,
		mass = Globals.universalMass,
		path = screengui,
		speed = Globals.speed,
		quadtrees = false,
		independent = true,
		canvas = {
			frame = nil,
			topLeft = Globals.engineInit.canvas.topLeft,
			size = Globals.engineInit.canvas.size,
		},
		iterations = {
			constraint = 1,
			collision = 1,
		},
		Started = Signal.new(),
		Stopped = Signal.new(),
		ObjectAdded = Signal.new(),
		ObjectRemoved = Signal.new(),
		Updated = Signal.new(),
	}, Engine)
	local janitor = Janitor.new()

	janitor:Add(self.Started, "Destroy")
	janitor:Add(self.Stopped, "Destroy")
	janitor:Add(self.ObjectAdded, "Destroy")
	janitor:Add(self.ObjectRemoved, "Destroy")
	janitor:Add(self.Updated, "Destroy")

	self._janitor = janitor

	return self
end
function Engine:Start()
	if not self.canvas then
		throwException("error", "NO_CANVAS_FOUND")
	end
	if #self.bodies == 0 then
		throwException("warn", "NO_RIGIDBODIES_FOUND")
	end
	if self.connection then
		throwException("warn", "ALREADY_STARTED")

		return
	end

	self.Started:Fire()

	local fixedDeltaTime = 1.6666666666666665E-2
	local epsilon = 1E-3
	local accumulator = 0
	local connection

	connection = RunService.RenderStepped:Connect(function(deltaTime)
		if self.independent then
			accumulator += deltaTime

			while accumulator > 0 do
				accumulator -= fixedDeltaTime

				PhysicsRunner.Update(self, deltaTime)
				PhysicsRunner.Render(self)
			end

			if accumulator >= -epsilon then
				accumulator = 0
			end
		else
			accumulator = 0

			PhysicsRunner.Update(self, deltaTime)
			PhysicsRunner.Render(self)
		end
	end)
	self.connection = connection

	self._janitor:Add(self.connection, "Disconnect", "MainConnection")
end
function Engine:Stop()
	if self.connection then
		self.Stopped:Fire()
		self._janitor:Remove("MainConnection")

		self.connection = nil
	end
end
function Engine:Create(object, properties)
	throwTypeError("object", object, 1, "string")
	throwTypeError("properties", properties, 2, "table")

	if object ~= "Constraint" and object ~= "Point" and object ~= "RigidBody" then
		throwException("error", "INVALID_OBJECT")
	end

	for prop, value in pairs(properties) do
		if not table.find(Globals.VALID_OBJECT_PROPS, prop) then
			throwException("error", "INVALID_PROPERTY", string.format("%q is not a valid property!", prop))

			return
		end
		if not table.find(Globals[string.lower(object)].props, prop) then
			throwException(
				"error",
				"INVALID_PROPERTY",
				string.format("%q is not a valid property for a %s!", prop, object)
			)

			return
		end
		if Globals.OBJECT_PROPS_TYPES[prop] and typeof(value) ~= Globals.OBJECT_PROPS_TYPES[prop] then
			error(
				string.format(
					[[[Nature2D]: Invalid Property type for %q. Expected %q got %q.]],
					prop,
					Globals.OBJECT_PROPS_TYPES[prop],
					typeof(value)
				),
				2
			)
		end
	end
	for _, prop in ipairs(Globals[string.lower(object)].must_have) do
		if not properties[prop] then
			local throw = true

			if prop == "Object" and properties.Structure then
				throw = false
			end
			if throw then
				throwException(
					"error",
					"MUST_HAVE_PROPERTY",
					string.format("You must specify the %q property for a %s!", prop, object)
				)

				return
			end
		end
	end

	local newObject

	if object == "Point" then
		local newPoint = Point.new(properties.Position or Vector2.new(), self.canvas, self, {
			snap = properties.Snap,
			selectable = false,
			render = properties.Visible,
			keepInCanvas = properties.KeepInCanvas or true,
		}, nil)

		if properties.Radius then
			newPoint:SetRadius(properties.Radius)
		end
		if properties.Color then
			newPoint:Stroke(properties.Color)
		end

		table.insert(self.points, newPoint)

		newObject = newPoint
	elseif object == "Constraint" then
		if not table.find(Globals.constraint.types, string.lower(properties.Type or "")) then
			throwException("error", "INVALID_CONSTRAINT_TYPE")
		end
		if properties.RestLength and properties.RestLength <= 0 then
			throwException("error", "INVALID_CONSTRAINT_LENGTH")
		end
		if properties.Thickness and properties.Thickness <= 0 then
			throwException("error", "INVALID_CONSTRAINT_THICKNESS")
		end
		if properties.Point1 and properties.Point2 and properties.Type then
			local dist = (properties.Point1.pos - properties.Point2.pos).Magnitude
			local newConstraint = Constraint.new(properties.Point1, properties.Point2, self.canvas, {
				restLength = properties.RestLength or dist,
				render = properties.Visible,
				thickness = properties.Thickness,
				support = false,
				TYPE = string.upper(properties.Type),
			}, self)

			if properties.SpringConstant then
				newConstraint:SetSpringConstant(properties.SpringConstant)
			end
			if properties.Color then
				newConstraint:Stroke(properties.Color)
			end

			table.insert(self.constraints, newConstraint)

			newObject = newConstraint
		end
	elseif object == "RigidBody" then
		if properties.Object and not properties.Object:IsA("GuiObject") and not properties.Structure then
			error("'Object' must be a GuiObject", 2)
		end

		local obj = nil

		if not properties.Structure then
			obj = properties.Object
		end

		local custom = {
			Vertices = {},
			Edges = {},
		}

		if properties.Structure then
			if not self.canvas.frame then
				throwException("error", "CANVAS_FRAME_NOT_FOUND")
			end

			for _, c in ipairs(properties.Structure) do
				local a = c[1]
				local b = c[2]
				local support = c[3]

				if typeof(a) ~= "Vector2" or typeof(b) ~= "Vector2" then
					error([[[Nature2D]: Invalid point positions for custom RigidBody structure.]], 2)
				end
				if support and typeof(support) ~= "boolean" then
					error("[Nature2D]: 'support' must be a boolean or nil")
				end
				if a == b then
					error("[Nature2D]: A constraint cannot have the same points.", 2)
				end

				local PointA = SearchTable(custom.Vertices, a, function(i, v)
					return i == v.pos
				end)
				local PointB = SearchTable(custom.Vertices, b, function(i, v)
					return i == v.pos
				end)

				if not PointA then
					PointA = Point.new(a, self.canvas, self, {
						snap = properties.Anchored,
						selectable = false,
						render = false,
						keepInCanvas = properties.KeepInCanvas or true,
					})

					table.insert(custom.Vertices, PointA)
				end
				if not PointB then
					PointB = Point.new(b, self.canvas, self, {
						snap = properties.Anchored,
						selectable = false,
						render = false,
						keepInCanvas = properties.KeepInCanvas or true,
					})

					table.insert(custom.Vertices, PointB)
				end

				local edge = Constraint.new(PointA, PointB, self.canvas, {
					render = support and false or true,
					thickness = 2,
					support = support,
					TYPE = "ROD",
				}, self)

				table.insert(custom.Edges, edge)
			end
		end

		local newBody = RigidBody.new(
			obj,
			properties.Mass or self.mass,
			properties.Collidable,
			properties.Anchored,
			self,
			properties.Structure and custom or nil,
			properties.Structure
		)

		if properties.LifeSpan then
			newBody:SetLifeSpan(properties.LifeSpan)
		end
		if typeof(properties.KeepInCanvas) == "boolean" then
			newBody:KeepInCanvas(properties.KeepInCanvas)
		end
		if properties.Gravity then
			newBody:SetGravity(properties.Gravity)
		end
		if properties.Friction then
			newBody:SetFriction(properties.Friction)
		end
		if properties.AirFriction then
			newBody:SetAirFriction(properties.AirFriction)
		end
		if typeof(properties.CanRotate) == "boolean" and not properties.Structure then
			newBody:CanRotate(properties.CanRotate)
		end

		table.insert(self.bodies, newBody)

		newObject = newBody
	end

	self._janitor:Add(newObject, "Destroy")
	self.ObjectAdded:Fire(newObject)

	return newObject
end
function Engine:GetBodies()
	return self.bodies
end
function Engine:GetConstraints()
	return self.constraints
end
function Engine:GetPoints()
	return self.points
end
function Engine:CreateCanvas(topLeft, size, frame)
	throwTypeError("topLeft", topLeft, 1, "Vector2")
	throwTypeError("size", size, 2, "Vector2")

	self.canvas.topLeft = topLeft
	self.canvas.size = size

	if frame and frame:IsA("Frame") then
		self.canvas.frame = frame
	end
end
function Engine:SetSimulationSpeed(speed)
	throwTypeError("speed", speed, 1, "number")

	self.speed = speed
end
function Engine:SetPhysicalProperty(property, value)
	throwTypeError("property", property, 1, "string")

	local properties = Globals.properties

	local function Update(object)
		if string.lower(property) == "collisionmultiplier" then
			throwTypeError("value", value, 2, "number")

			object.bounce = value
		elseif string.lower(property) == "gravity" then
			throwTypeError("value", value, 2, "Vector2")

			object.gravity = value
		elseif string.lower(property) == "friction" then
			throwTypeError("value", value, 2, "number")

			object.friction = math.clamp(1 - value, 0, 1)
		elseif string.lower(property) == "airfriction" then
			throwTypeError("value", value, 2, "number")

			object.airfriction = math.clamp(1 - value, 0, 1)
		elseif string.lower(property) == "universalmass" then
			throwTypeError("value", value, 2, "number")

			object.mass = math.max(0, value)
		end
	end

	if table.find(properties, string.lower(property)) then
		if #self.bodies < 1 then
			Update(self)
		else
			Update(self)

			for _, b in ipairs(self.bodies) do
				for _, v in ipairs(b:GetVertices()) do
					Update(v)
				end
			end
		end
	else
		throwException("error", "PROPERTY_NOT_FOUND")
	end
end
function Engine:GetBodyById(id)
	throwTypeError("id", id, 1, "string")

	for _, b in ipairs(self.bodies) do
		if b.id == id then
			return b
		end
	end

	return
end
function Engine:GetConstraintById(id)
	throwTypeError("id", id, 1, "string")

	for _, c in ipairs(self.constraints) do
		if c.id == id then
			return c
		end
	end

	return
end
function Engine:GetDebugInfo()
	return {
		Objects = {
			RigidBodies = #self.bodies,
			Constraints = #self.constraints,
			Points = #self.points,
		},
		Running = not not self.connection,
		Physics = {
			Gravity = self.gravity,
			Friction = 1 - self.friction,
			AirFriction = 1 - self.airfriction,
			CollisionMultiplier = self.bounce,
			TimeSteps = self.timeSteps,
			SimulationSpeed = self.speed,
			UsingQuadtrees = self.quadtrees,
			FramerateIndependent = self.independent,
		},
		Path = self.path,
		Canvas = {
			Frame = self.canvas.frame,
			TopLeft = self.canvas.topLeft,
			Size = self.canvas.size,
		},
	}
end
function Engine:UseQuadtrees(use)
	throwTypeError("useQuadtrees", use, 1, "boolean")

	self.quadtrees = use
end
function Engine:FrameRateIndependent(independent)
	throwTypeError("independent", independent, 1, "boolean")

	self.independent = independent
end
function Engine:SetConstraintIterations(iterations)
	throwTypeError("iterations", iterations, 1, "number")

	self.iterations.constraint = math.floor(math.clamp(iterations, 1, 10))
end
function Engine:SetCollisionIterations(iterations)
	throwTypeError("iterations", iterations, 1, "number")

	if self.quadtrees then
		self.iterations.collision = math.floor(math.clamp(iterations, 1, 10))
	else
		throwException("warn", "CANNOT_SET_COLLISION_ITERATIONS")
	end
end
function Engine:Destroy()
	self._janitor:Destroy()
	setmetatable(self, nil)
end

return Engine
]]></string>
              </Properties>
            </Item>
            <Item class="Folder" referent="13">
              <Properties>
                <string name="Name">Physics</string>
              </Properties>
              <Item class="ModuleScript" referent="14">
                <Properties>
                  <string name="Name">Constraint</string>
                  <string name="Source"><![CDATA[-- #selene: allow(unused_variable)

local line = require(script.Parent.Parent.Utilities.Line)
local Globals = require(script.Parent.Parent.Constants.Globals)
local throwTypeError = require(script.Parent.Parent.Debugging.TypeErrors)
local throwException = require(script.Parent.Parent.Debugging.Exceptions)
local Janitor = require(script.Parent.Parent.Utilities.Janitor)
local Types = require(script.Parent.Parent.Types)
local https = game:GetService("HttpService")
local Constraint = {}

Constraint.__index = Constraint

function Constraint.new(p1, p2, canvas, config, engine, parent)
	local self = setmetatable({
		id = https:GenerateGUID(false),
		_janitor = nil,
		engine = engine,
		Parent = parent,
		frame = nil,
		canvas = canvas,
		point1 = p1,
		point2 = p2,
		restLength = config.restLength or (p2.pos - p1.pos).Magnitude,
		render = config.render,
		thickness = config.thickness or Globals.constraint.thickness,
		support = config.support,
		_TYPE = config.TYPE,
		k = 0.1,
		color = nil,
	}, Constraint)
	local janitor = Janitor.new()

	janitor:Add(self, "Destroy")
	janitor:Add(self.point1, "Destroy")
	janitor:Add(self.point2, "Destroy")

	if self.Parent then
		janitor:Add(self.Parent, "Destroy")
	end

	self._janitor = janitor
	self.point1.Parent = self
	self.point2.Parent = self

	self.point1._janitor:Add(self.point1.Parent, "Destroy")
	self.point2._janitor:Add(self.point2.Parent, "Destroy")

	return self
end
function Constraint:Constrain()
	local cur = (self.point2.pos - self.point1.pos).Magnitude
	local force

	if self._TYPE == "ROPE" then
		local restLength = self.restLength

		if cur < self.thickness then
			restLength = self.thickness
		end
		if cur > self.restLength or self.restLength < self.thickness then
			local offset = ((restLength - cur) / restLength) / 2

			force = self.point2.pos - self.point1.pos

			force *= offset
		end
	elseif self._TYPE == "ROD" then
		local offset = self.restLength - cur
		local dif = self.point2.pos - self.point1.pos

		dif = dif.Unit
		force = (dif * offset) / 2
	elseif self._TYPE == "SPRING" then
		force = self.point2.pos - self.point1.pos

		local mag = force.Magnitude - self.restLength

		force = force.Unit

		force *= -1 * self.k * mag
	else
		return
	end
	if force then
		if not self.point1.snap then
			self.point1.pos -= force
		end
		if not self.point2.snap then
			self.point2.pos += force
		end
	end
end
function Constraint:Render()
	if self.render and not self.support then
		if not self.canvas.frame then
			throwException("error", "CANVAS_FRAME_NOT_FOUND")
		end

		local thickness = self.thickness or Globals.constraint.thickness
		local color = self.color or Globals.constraint.color
		local image = self._TYPE == "SPRING" and "rbxassetid://8404350124" or nil

		if not self.frame then
			self.frame = line(self.point1.pos, self.point2.pos, self.canvas.frame, thickness, color, nil, image)

			self._janitor:Add(self.frame, "Destroy")
		end

		line(self.point1.pos, self.point2.pos, self.canvas.frame, thickness, color, self.frame, image)
	end
end
function Constraint:SetLength(newLength)
	throwTypeError("length", newLength, 1, "number")

	if newLength <= 0 then
		throwException("error", "INVALID_CONSTRAINT_LENGTH")
	end

	self.restLength = newLength
end
function Constraint:GetLength()
	return (self.point2.pos - self.point1.pos).Magnitude
end
function Constraint:Stroke(color)
	throwTypeError("color", color, 1, "Color3")

	self.color = color
end
function Constraint:Destroy()
	self._janitor:Cleanup()

	if not self.Parent then
		for i, c in ipairs(self.engine.constraints) do
			if c.id == self.id then
				table.remove(self.engine.constraints, i)
				self.engine.ObjectRemoved:Fire(self)

				break
			end
		end
	end

	self.point1 = nil
	self.point2 = nil
end
function Constraint:GetPoints()
	return self.point1, self.point2
end
function Constraint:GetFrame()
	return self.frame
end
function Constraint:SetSpringConstant(k)
	throwTypeError("springConstant", k, 1, "number")

	self.k = k
end
function Constraint:GetId()
	return self.id
end
function Constraint:GetParent()
	return self.Parent
end

return Constraint
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="15">
                <Properties>
                  <string name="Name">Point</string>
                  <string name="Source"><![CDATA[-- #selene: allow(unused_variable)

local Globals = require(script.Parent.Parent.Constants.Globals)
local Types = require(script.Parent.Parent.Types)
local throwTypeError = require(script.Parent.Parent.Debugging.TypeErrors)
local throwException = require(script.Parent.Parent.Debugging.Exceptions)
local Janitor = require(script.Parent.Parent.Utilities.Janitor)
local HttpService = game:GetService("HttpService")
local Point = {}

Point.__index = Point

function Point.new(pos, canvas, engine, config, parent)
	local self = setmetatable({
		id = HttpService:GenerateGUID(false),
		Parent = parent,
		frame = nil,
		_janitor = nil,
		engine = engine,
		canvas = canvas,
		oldPos = pos,
		pos = pos,
		oldForces = Vector2.new(),
		forces = Vector2.new(),
		maxForce = nil,
		gravity = engine.gravity,
		friction = engine.friction,
		airfriction = engine.airfriction,
		bounce = engine.bounce,
		snap = config.snap,
		selectable = config.selectable,
		render = config.render,
		keepInCanvas = config.keepInCanvas,
		color = nil,
		radius = Globals.point.radius,
		timed = {
			start = nil,
			t = nil,
			force = Vector2.new(),
		},
	}, Point)
	local janitor = Janitor.new()

	janitor:Add(self, "Destroy")

	if self.Parent then
		janitor:Add(self.Parent, "Destroy")
	end

	self._janitor = janitor

	return self
end
function Point:ApplyForce(force, t)
	throwTypeError("force", force, 1, "Vector2")

	self.forces += force

	if t then
		throwTypeError("time", t, 2, "number")

		if t <= 0 then
			throwException("error", "INVALID_TIME")
		end

		self.timed.start = os.clock()
		self.timed.t = t
		self.timed.force = force
	end
end
function Point:Update(dt)
	if not self.snap then
		self:ApplyForce(self.gravity)

		if self.timed.start then
			if os.clock() - self.timed.start < self.timed.t then
				self:ApplyForce(self.timed.force)
			else
				self.timed.start = nil
				self.timed.t = nil
				self.timed.force = Vector2.new()
			end
		end

		local velocity = self.pos

		velocity -= self.oldPos
		velocity += self.forces

		local body = self.Parent

		if body and body.Parent then
			local mass = body.Parent.mass

			if mass then
				self.forces /= mass
			end
			if body.Parent.Collisions.CanvasEdge or body.Parent.Collisions.Body then
				velocity *= self.friction
			else
				velocity *= self.airfriction
			end
		else
			velocity *= self.friction
		end
		if self.maxForce then
			velocity = velocity.Unit * math.min(velocity.Magnitude, self.maxForce)
		end

		self.oldPos = self.pos

		self.pos += velocity

		self.oldForces = self.forces

		self.forces *= 0
	end
end
function Point:KeepInCanvas()
	local vx = self.pos.X - self.oldPos.X
	local vy = self.pos.Y - self.oldPos.Y
	local boundX = self.canvas.topLeft.X + self.canvas.size.X
	local boundY = self.canvas.topLeft.Y + self.canvas.size.Y
	local collision = false
	local edge

	if self.pos.Y > boundY then
		self.pos = Vector2.new(self.pos.X, boundY)
		self.oldPos = Vector2.new(self.oldPos.X, self.pos.Y + vy * self.bounce)
		collision = true
		edge = "Bottom"
	elseif self.pos.Y < self.canvas.topLeft.Y then
		self.pos = Vector2.new(self.pos.X, self.canvas.topLeft.Y)
		self.oldPos = Vector2.new(self.oldPos.X, self.pos.Y - vy * self.bounce)
		collision = true
		edge = "Top"
	end
	if self.pos.X < self.canvas.topLeft.X then
		self.pos = Vector2.new(self.canvas.topLeft.X, self.pos.Y)
		self.oldPos = Vector2.new(self.pos.X + vx * self.bounce, self.oldPos.Y)
		collision = true
		edge = "Left"
	elseif self.pos.X > boundX then
		self.pos = Vector2.new(boundX, self.pos.Y)
		self.oldPos = Vector2.new(self.pos.X - vx * self.bounce, self.oldPos.Y)
		collision = true
		edge = "Right"
	end

	local body = self.Parent

	if body and body.Parent then
		if collision then
			local prev = body.Parent.Collisions.CanvasEdge

			body.Parent.Collisions.CanvasEdge = true

			if prev == false then
				body.Parent.CanvasEdgeTouched:Fire(edge)
			end
		else
			body.Parent.Collisions.CanvasEdge = false
		end
	end
end
function Point:Render()
	if self.render then
		if not self.canvas.frame then
			throwException("error", "CANVAS_FRAME_NOT_FOUND")
		end
		if not self.frame then
			local p = Instance.new("Frame")
			local border = Instance.new("UICorner")
			local r = self.radius or Globals.point.radius

			p.AnchorPoint = Vector2.new(0.5, 0.5)
			p.BackgroundColor3 = self.color or Globals.point.color
			p.Size = UDim2.new(0, r * 2, 0, r * 2)
			p.Parent = self.canvas.frame
			border.CornerRadius = Globals.point.uicRadius
			border.Parent = p
			self.frame = p

			self._janitor:Add(self.frame, "Destroy")
		end

		self.frame.Position = UDim2.new(0, self.pos.x, 0, self.pos.y)
	end
	if self.keepInCanvas then
		self:KeepInCanvas()
	end
end
function Point:Destroy()
	self._janitor:Cleanup()

	if not self.Parent then
		for i, c in ipairs(self.engine.points) do
			if c.id == self.id then
				table.remove(self.engine.points, i)
				self.engine.ObjectRemoved:Fire(self)

				break
			end
		end
	end
end
function Point:SetRadius(radius)
	throwTypeError("radius", radius, 1, "number")

	self.radius = radius
end
function Point:Stroke(color)
	throwTypeError("color", color, 1, "Color3")

	self.color = color
end
function Point:Snap(snap)
	throwTypeError("snap", snap, 1, "boolean")

	self.snap = snap
end
function Point:Velocity()
	return self.pos - self.oldPos
end
function Point:GetNetForce()
	return self.oldForces
end
function Point:GetParent()
	return self.Parent
end
function Point:SetPosition(x, y)
	throwTypeError("x", x, 1, "number")
	throwTypeError("y", y, 2, "number")

	local newPosition = Vector2.new(x, y)

	self.oldPos = newPosition
	self.pos = newPosition
end
function Point:SetMaxForce(maxForce)
	throwTypeError("maxForce", maxForce, 1, "number")

	self.maxForce = math.abs(maxForce)
end

return Point
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="16">
                <Properties>
                  <string name="Name">RigidBody</string>
                  <string name="Source"><![CDATA[-- #selene: allow(unused_variable)

local Point = require(script.Parent.Point)
local Constraint = require(script.Parent.Constraint)
local Globals = require(script.Parent.Parent.Constants.Globals)
local Signal = require(script.Parent.Parent.Utilities.Signal)
local Types = require(script.Parent.Parent.Types)
local Janitor = require(script.Parent.Parent.Utilities.Janitor)
local throwTypeError = require(script.Parent.Parent.Debugging.TypeErrors)
local throwException = require(script.Parent.Parent.Debugging.Exceptions)
local restrict = require(script.Parent.Parent.Debugging.Restrict)
local HttpService = game:GetService("HttpService")
local RigidBody = {}

RigidBody.__index = RigidBody

local function GetCorners(frame, engine)
	local pos, size = frame.AbsolutePosition, frame.AbsoluteSize
	local rotation = math.rad(frame.Rotation)
	local center = pos + size / 2
	local temp = math.sqrt((size.X / 2) ^ 2 + (size.Y / 2) ^ 2)
	local offset = (engine.path and engine.path.IgnoreGuiInset) and Globals.offset or Vector2.new(0, 0)
	local t = math.atan2(size.Y, size.X)
	local a = rotation + t
	local b = rotation - t

	return {
		center - temp * Vector2.new(math.cos(a), math.sin(a)) + offset,
		center + temp * Vector2.new(math.cos(b), math.sin(b)) + offset,
		center - temp * Vector2.new(math.cos(b), math.sin(b)) + offset,
		center + temp * Vector2.new(math.cos(a), math.sin(a)) + offset,
	}
end
local function CalculatePenetration(minA, maxA, minB, maxB)
	if minA < minB then
		return minB - maxA
	else
		return minA - maxB
	end
end
local function CalculateOffset(pos, anchorPoint, size)
	return (Vector2.new(0.5, 0.5) - anchorPoint) * size
end
local function CalculateCenter(vertices)
	local center = Vector2.new(0, 0)
	local minX = math.huge
	local minY = math.huge
	local maxX = -math.huge
	local maxY = -math.huge

	for _, v in ipairs(vertices) do
		center += v.pos

		minX = math.min(minX, v.pos.x)
		minY = math.min(minY, v.pos.y)
		maxX = math.max(maxX, v.pos.x)
		maxY = math.max(maxY, v.pos.y)
	end

	center /= #vertices

	return center
end
local function CalculateSize(vertices)
	local minX = math.huge
	local minY = math.huge
	local maxX = -math.huge
	local maxY = -math.huge

	for _, v in ipairs(vertices) do
		minX = math.min(minX, v.pos.x)
		minY = math.min(minY, v.pos.y)
		maxX = math.max(maxX, v.pos.x)
		maxY = math.max(maxY, v.pos.y)
	end

	return Vector2.new(maxX - minX, maxY - minY)
end
local function CreateRotationCache(cache, center, vertices)
	table.clear(cache)

	for _, p in ipairs(vertices) do
		local r = (p.pos - center).Magnitude
		local theta = math.atan2(p.pos.Y - center.Y, p.pos.X - center.X)

		table.insert(cache, { r, theta })
	end
end
local function UpdateVertices(frame, vertices, engine)
	local corners = GetCorners(frame, engine)

	for i, vertex in ipairs(vertices) do
		vertex:SetPosition(corners[i].X, corners[i].Y)
	end
end

function RigidBody.new(frame, m, collidable, anchored, engine, custom, structure)
	local isCustom = false

	if custom then
		isCustom = true
	end

	local vertices = isCustom and custom.Vertices or {}
	local edges = isCustom and custom.Edges or {}
	local pointConfig = {
		snap = anchored,
		selectable = false,
		render = false,
		keepInCanvas = true,
	}
	local constraintConfig = {
		restLength = nil,
		render = false,
		thickness = 4,
		support = false,
		TYPE = "ROD",
	}

	local function addPoint(pos)
		local newPoint = Point.new(pos, engine.canvas, engine, pointConfig)

		vertices[#vertices + 1] = newPoint

		return newPoint
	end
	local function addConstraint(p1, p2, support)
		constraintConfig.support = support

		local newConstraint = Constraint.new(p1, p2, engine.canvas, constraintConfig)

		edges[#edges + 1] = newConstraint

		return newConstraint
	end

	if not isCustom then
		local corners = GetCorners(frame, engine)
		local topleft = addPoint(corners[1])
		local topright = addPoint(corners[2])
		local bottomleft = addPoint(corners[3])
		local bottomright = addPoint(corners[4])

		addConstraint(topleft, topright, false)
		addConstraint(topleft, bottomleft, false)
		addConstraint(topright, bottomright, false)
		addConstraint(bottomleft, bottomright, false)
		addConstraint(topleft, bottomright, true)
		addConstraint(topright, bottomleft, true)
	end

	local self = setmetatable({
		id = HttpService:GenerateGUID(false),
		custom = isCustom,
		_janitor = Janitor.new(),
		structure = structure,
		vertices = vertices,
		edges = edges,
		frame = isCustom and nil or frame,
		size = isCustom and CalculateSize(vertices) or nil,
		anchored = anchored,
		mass = m,
		collidable = collidable,
		canRotate = true,
		rotationCache = {},
		center = isCustom and CalculateCenter(vertices) or frame.AbsolutePosition + frame.AbsoluteSize / 2,
		engine = engine,
		spawnedAt = os.clock(),
		lifeSpan = nil,
		anchorRotation = (anchored and not isCustom) and frame.Rotation or nil,
		anchorPos = (anchored and not isCustom) and frame.AbsolutePosition + frame.AbsoluteSize / 2 or nil,
		Touched = nil,
		TouchEnded = nil,
		CanvasEdgeTouched = nil,
		Collisions = {
			Body = false,
			CanvasEdge = false,
			Other = {},
		},
		States = {},
		filtered = {},
	}, RigidBody)

	if engine.path and engine.path.IgnoreGuiInset then
		self.anchorPos = self.anchorPos and self.anchorPos + Globals.offset or nil

		if not self.custom then
			self.center += Globals.offset
		end
	end

	self.Touched = Signal.new()
	self.TouchEnded = Signal.new()
	self.CanvasEdgeTouched = Signal.new()

	for _, edge in ipairs(edges) do
		edge.Parent = self

		edge._janitor:Add(edge.Parent, "Destroy")
		self._janitor:Add(edge, "Destroy")
	end

	self._janitor:Add(self.Touched, "Destroy")
	self._janitor:Add(self.TouchEnded, "Destroy")
	self._janitor:Add(self.CanvasEdgeTouched, "Destroy")

	if not self.custom then
		self._janitor:Add(self.frame, "Destroy")
		self._janitor:LinkToInstance(self.frame)
	end
	if #self.rotationCache < 1 then
		CreateRotationCache(self.rotationCache, self.center, self.vertices)
	end

	return self
end
function RigidBody:CreateProjection(Axis, Min, Max)
	local DotP = Axis:Dot(self.vertices[1].pos)

	Min, Max = DotP, DotP

	for _, v in ipairs(self.vertices) do
		DotP = Axis:Dot(v.pos)
		Min = math.min(DotP, Min)
		Max = math.max(DotP, Max)
	end

	return Min, Max
end
function RigidBody:DetectCollision(other)
	if not self.custom and (not self.frame and not other.frame) then
		return { false, {} }
	end

	self.center = CalculateCenter(self.vertices)

	local minDist = math.huge
	local collision = {
		axis = nil,
		depth = nil,
		edge = nil,
		vertex = nil,
	}

	for i = 1, #self.edges + #other.edges, 1 do
		local edge = i <= #self.edges and self.edges[i] or other.edges[i - #self.edges]

		if not edge.support then
			local axis = Vector2.new(edge.point1.pos.Y - edge.point2.pos.Y, edge.point2.pos.X - edge.point1.pos.X).Unit
			local MinA, MinB, MaxA, MaxB

			MinA, MaxA = self:CreateProjection(axis, MinA, MaxA)
			MinB, MaxB = other:CreateProjection(axis, MinB, MaxB)

			local dist = CalculatePenetration(MinA, MaxA, MinB, MaxB)

			if dist > 0 then
				return { false, {} }
			elseif math.abs(dist) < minDist then
				minDist = math.abs(dist)
				collision.axis = axis
				collision.edge = edge
			end
		end
	end

	collision.depth = minDist

	if collision.edge and collision.edge.Parent ~= other then
		local Temp = other

		other = self
		self = Temp
	end

	local centerDif = self.center - other.center
	local dot = collision.axis:Dot(centerDif)

	if dot < 0 then
		collision.axis *= -1
	end

	local minMag = math.huge

	for i = 1, #self.vertices, 1 do
		local dif = self.vertices[i].pos - other.center
		local dist = collision.axis:Dot(dif)

		if dist < minMag then
			minMag = dist
			collision.vertex = self.vertices[i]
		end
	end

	return { true, collision }
end
function RigidBody:ApplyForce(force, t)
	throwTypeError("force", force, 1, "Vector2")

	if t then
		throwTypeError("time", t, 2, "number")

		if t <= 0 then
			throwException("error", "INVALID_TIME")
		end
	end

	for _, v in ipairs(self.vertices) do
		v:ApplyForce(force, t)
	end
end
function RigidBody:Update(dt)
	self.center = CalculateCenter(self.vertices)

	for i, vertex in ipairs(self.vertices) do
		if not self.canRotate then
			local info = self.rotationCache[i]
			local r = info[1]
			local t = info[2]

			vertex:ApplyForce((self.center + Vector2.new(math.cos(t), math.sin(t)) * r) - vertex.pos)
		end

		vertex:Update(dt)
		vertex:Render()
	end
	for _, edge in ipairs(self.edges) do
		for i = 1, self.engine.iterations.constraint do
			edge:Constrain()
		end

		edge:Render()
	end
end
function RigidBody:Render()
	if self.lifeSpan and os.clock() - self.spawnedAt >= self.lifeSpan then
		self:Destroy()
	end
	if self.custom then
		return
	end
	if self.anchored then
		local anchorPos = self.anchorPos
			- CalculateOffset(self.anchorPos, self.frame.AnchorPoint, self.frame.AbsoluteSize)

		self.frame.Position = UDim2.fromOffset(anchorPos.X, anchorPos.Y)

		if self.canRotate then
			self:Rotate(self.anchorRotation)
		end
	else
		local center = self.center - CalculateOffset(self.center, self.frame.AnchorPoint, self.frame.AbsoluteSize)
		local dif = self.vertices[2].pos - self.vertices[1].pos

		self.frame.Position = UDim2.new(0, center.X, 0, center.Y)

		if self.canRotate then
			self.frame.Rotation = math.deg(math.atan2(dif.Y, dif.X))
		end
	end
end
function RigidBody:Clone(deepCopy)
	if not self.custom and not self.frame then
		return
	end
	if not self.engine then
		return
	end

	local frame

	if not self.custom then
		frame = self.frame:Clone()
		frame.Parent = self.frame.Parent
	end

	local copy = self.engine:Create("RigidBody", {
		Mass = self.mass,
		Object = frame,
		Structure = self.custom and self.structure or nil,
		Anchored = self.anchored,
		Collidable = self.collidable,
	})

	if deepCopy == true then
		copy.States = self.States

		if self.lifeSpan then
			copy:SetLifeSpan(self.lifeSpan)
		end

		for _, body in ipairs(self.filtered) do
			copy:FilterCollisionsWith(body)
		end
	end

	return copy
end
function RigidBody:Destroy(keepFrame)
	self._janitor:Cleanup()

	for i, body in ipairs(self.engine.bodies) do
		if self.id == body.id then
			table.clear(self.Collisions.Other)
			table.remove(self.engine.bodies, i)
			self.engine.ObjectRemoved:Fire(self)

			break
		end
	end

	table.clear(self.vertices)
	table.clear(self.edges)
end
function RigidBody:Rotate(newRotation)
	throwTypeError("newRotation", newRotation, 1, "number")

	if self.anchored and self.anchorRotation then
		self.anchorRotation = newRotation
	end

	local oldRotation

	if self.custom then
		local dif = self.vertices[2].pos - self.vertices[1].pos

		oldRotation = math.deg(math.atan2(dif.Y, dif.X))

		local tempRotationCache = {}

		CreateRotationCache(tempRotationCache, self.center, self.vertices)

		for i, info in ipairs(tempRotationCache) do
			local r = info[1]
			local t = info[2] + math.rad(newRotation)
			local v = self.vertices[i]

			v.pos = self.center + Vector2.new(math.cos(t), math.sin(t)) * r
			v.oldPos = v.pos
		end
	else
		oldRotation = self.frame.Rotation

		local offset = CalculateOffset(self.anchorPos, self.frame.AnchorPoint, self.frame.AbsoluteSize)
		local position = self.anchorPos - offset

		self.frame.Position = self.anchored and UDim2.fromOffset(position.X, position.Y)
			or UDim2.fromOffset(self.center.x, self.center.y)
		self.frame.Rotation = newRotation

		UpdateVertices(self.frame, self.vertices, self.engine)
	end

	return oldRotation, newRotation
end
function RigidBody:SetPosition(PositionX, PositionY)
	throwTypeError("PositionX", PositionX, 1, "number")
	throwTypeError("PositionY", PositionY, 2, "number")

	if self.anchored and self.anchorPos then
		self.anchorPos = Vector2.new(PositionX, PositionY)
	end

	local oldPosition

	if self.custom then
		oldPosition = UDim2.fromOffset(self.center.X, self.center.Y)

		local tempRotationCache = {}

		CreateRotationCache(tempRotationCache, self.center, self.vertices)

		self.center = Vector2.new(PositionX, PositionY)

		for i, info in ipairs(tempRotationCache) do
			local r = info[1]
			local t = info[2]
			local v = self.vertices[i]

			v.pos = self.center + Vector2.new(math.cos(t), math.sin(t)) * r
			v.oldPos = v.pos
		end
	else
		oldPosition = self.frame.Position
		self.frame.Position = UDim2.fromOffset(PositionX, PositionY)

		UpdateVertices(self.frame, self.vertices, self.engine)
	end

	return oldPosition, UDim2.fromOffset(PositionX, PositionY)
end
function RigidBody:SetSize(SizeX, SizeY)
	restrict(self.custom)
	throwTypeError("SizeX", SizeX, 1, "number")
	throwTypeError("SizeY", SizeY, 2, "number")

	local oldSize = self.frame.Size

	self.frame.Size = UDim2.fromOffset(SizeX, SizeY)

	UpdateVertices(self.frame, self.vertices, self.engine)

	for _, edge in ipairs(self.edges) do
		edge.restLength = (edge.point2.pos - edge.point1.pos).Magnitude
	end

	return oldSize, UDim2.fromOffset(SizeX, SizeY)
end
function RigidBody:SetScale(scale)
	if not self.custom then
		return
	end

	throwTypeError("scale", scale, 1, "number")

	scale = math.max(0.00001, scale)

	for i, info in ipairs(self.rotationCache) do
		local r = info[1] * scale
		local t = info[2]
		local v = self.vertices[i]

		v.pos = self.center + Vector2.new(math.cos(t), math.sin(t)) * r
		v.oldPos = v.pos
	end
	for _, edge in ipairs(self.edges) do
		edge.restLength = (edge.point2.pos - edge.point1.pos).Magnitude
	end
end
function RigidBody:Anchor()
	self.anchored = true
	self.anchorRotation = self.frame and self.frame.Rotation or nil
	self.anchorPos = self.center

	for _, vertex in ipairs(self.vertices) do
		if not vertex.selectable then
			vertex.snap = self.anchored
		end
	end
end
function RigidBody:Unanchor()
	self.anchored = false
	self.anchorRotation = nil
	self.anchorPos = nil

	for _, vertex in ipairs(self.vertices) do
		if not vertex.selectable then
			vertex.snap = self.anchored
		end
	end
end
function RigidBody:CanCollide(collidable)
	throwTypeError("collidable", collidable, 1, "boolean")

	self.collidable = collidable
end
function RigidBody:CanRotate(canRotate)
	restrict(self.custom)
	throwTypeError("canRotate", canRotate, 1, "boolean")

	self.canRotate = canRotate

	CreateRotationCache(self.rotationCache, self.center, self.vertices)
end
function RigidBody:GetFrame()
	return self.frame
end
function RigidBody:GetId()
	return self.id
end
function RigidBody:GetVertices()
	return self.vertices
end
function RigidBody:GetConstraints()
	return self.edges
end
function RigidBody:SetLifeSpan(seconds)
	throwTypeError("seconds", seconds, 1, "number")

	self.lifeSpan = seconds
end
function RigidBody:KeepInCanvas(keepInCanvas)
	throwTypeError("keepInCanvas", keepInCanvas, 1, "boolean")

	for _, p in ipairs(self.vertices) do
		p.keepInCanvas = keepInCanvas
	end
end
function RigidBody:SetFriction(friction)
	throwTypeError("friction", friction, 1, "number")

	for _, p in ipairs(self.vertices) do
		p.friction = math.clamp(1 - friction, 0, 1)
	end
end
function RigidBody:SetAirFriction(friction)
	throwTypeError("friction", friction, 1, "number")

	for _, p in ipairs(self.vertices) do
		p.airfriction = math.clamp(1 - friction, 0, 1)
	end
end
function RigidBody:SetGravity(force)
	throwTypeError("force", force, 1, "Vector2")

	for _, p in ipairs(self.vertices) do
		p.gravity = force
	end
end
function RigidBody:SetMass(mass)
	if self.mass ~= mass and mass >= 1 then
		self.mass = mass
	end
end
function RigidBody:IsInBounds()
	local canvas = self.engine.canvas

	if not canvas then
		return false
	end

	for _, v in ipairs(self.vertices) do
		local pos = v.pos

		if
			not (
				(pos.X >= canvas.topLeft.X and pos.X <= canvas.topLeft.X + canvas.size.X)
				and (pos.Y >= canvas.topLeft.Y and pos.Y <= canvas.topLeft.Y + canvas.size.Y)
			)
		then
			return false
		end
	end

	return true
end
function RigidBody:AverageVelocity()
	local sum = Vector2.new(0, 0)

	for _, v in ipairs(self.vertices) do
		sum += v:Velocity()
	end

	return sum / #self.vertices
end
function RigidBody:SetState(state, value)
	throwTypeError("state", state, 1, "string")

	if self.States[state] == value then
		return
	end

	self.States[state] = value
end
function RigidBody:GetState(state)
	throwTypeError("state", state, 1, "string")

	return self.States[state]
end
function RigidBody:GetCenter()
	return self.center
end
function RigidBody:FilterCollisionsWith(otherBody)
	if not otherBody.id or not typeof(otherBody.id) == "string" or not otherBody.filtered then
		throwException("error", "INVALID_RIGIDBODY")
	end
	if otherBody.id == self.id then
		throwException("error", "SAME_ID")
	end
	if not table.find(self.filtered, otherBody.id) then
		table.insert(self.filtered, otherBody.id)
		table.insert(otherBody.filtered, self.id)
	end
end
function RigidBody:UnfilterCollisionsWith(otherBody)
	if not otherBody.id or not typeof(otherBody.id) == "string" or not otherBody.filtered then
		throwException("error", "INVALID_RIGIDBODY")
	end
	if otherBody.id == self.id then
		throwException("error", "SAME_ID")
	end

	local i1 = table.find(self.filtered, otherBody.id)
	local i2 = table.find(otherBody.filtered, self.id)

	if i1 and i2 then
		table.remove(self.filtered, i1)
		table.remove(otherBody.filtered, i2)
	end
end
function RigidBody:GetFilteredRigidBodies()
	return self.filtered
end
function RigidBody:GetTouchingRigidBodies()
	return self.Collisions.Other
end
function RigidBody:SetMaxForce(maxForce)
	throwTypeError("maxForce", maxForce, 1, "number")

	for _, p in ipairs(self.vertices) do
		p:SetMaxForce(maxForce)
	end
end

return RigidBody
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="17">
                <Properties>
                  <string name="Name">Runner</string>
                  <string name="Source"><![CDATA[-- #selene: allow(unused_variable)

local Types = require(script.Parent.Parent.Types)
local Quadtree = require(script.Parent.Parent.Utilities.Quadtree)

local function SearchTable(t, a, lambda)
	for _, v in ipairs(t) do
		if lambda(a, v) then
			return v
		end
	end

	return nil
end

local Runner = {}

function Runner.CollisionResponse(body, other, isColliding, Collision, dt, oldCollidingWith, iteration)
	if not isColliding then
		return
	end
	if iteration == 1 and body.Touched._handlerListHead and body.Touched._handlerListHead.Connected then
		if not SearchTable(oldCollidingWith, other, function(a, b)
			return a.id == b.id
		end) then
			body.Touched:Fire(other.id, Collision)
		end
	end

	local penetration = Collision.axis * Collision.depth
	local p1 = Collision.edge.point1
	local p2 = Collision.edge.point2
	local t

	if math.abs(p1.pos.X - p2.pos.X) > math.abs(p1.pos.Y - p2.pos.Y) then
		t = (Collision.vertex.pos.X - penetration.X - p1.pos.X) / (p2.pos.X - p1.pos.X)
	else
		t = (Collision.vertex.pos.Y - penetration.Y - p1.pos.Y) / (p2.pos.Y - p1.pos.Y)
	end

	local factor = 1 / (t ^ 2 + (1 - t) ^ 2)
	local bodyMass = Collision.edge.Parent.mass
	local m = t * bodyMass + (1 - t) * bodyMass
	local cMass = 1 / (m + Collision.vertex.Parent.Parent.mass)
	local r1 = Collision.vertex.Parent.Parent.mass * cMass
	local r2 = m * cMass

	if not Collision.edge.Parent.anchored then
		p1.pos -= penetration * ((1 - t) * factor * r1)
		p2.pos -= penetration * (t * factor * r1)
	end
	if not Collision.vertex.Parent.Parent.anchored then
		Collision.vertex.pos += penetration * r2
	end
end
function Runner.Update(self, dt)
	local tree

	if self.quadtrees then
		tree = Quadtree.new(self.canvas.topLeft, self.canvas.size, 4)

		for _, body in ipairs(self.bodies) do
			if body.collidable then
				tree:Insert(body)
			end
		end
	else
		if self.iterations.collision ~= 1 then
			self.iterations.collision = 1
		end
	end

	for _, body in ipairs(self.bodies) do
		body:Update(dt)

		local OldCollidingWith = body.Collisions.Other
		local CollidingWith = {}

		if body.collidable then
			local filtered = self.bodies

			if self.quadtrees then
				local abs = body.custom and body.size or body.frame.AbsoluteSize
				local side = abs.X > abs.Y and abs.X or abs.Y
				local range = {
					position = body.center - Vector2.new(side * 1.5, side * 1.5),
					size = Vector2.new(side * 3, side * 3),
				}

				filtered = tree:Search(range, {})
			end

			for _, other in ipairs(filtered) do
				if body.id ~= other.id and other.collidable and not table.find(body.filtered, other.id) then
					local result, isColliding, Collision, didCollide

					for i = 1, self.iterations.collision do
						result = body:DetectCollision(other)
						isColliding = result[1]
						Collision = result[2]

						if i == 1 and not isColliding then
							break
						end

						didCollide = true

						Runner.CollisionResponse(body, other, isColliding, Collision, dt, OldCollidingWith, i)
					end

					if didCollide then
						body.Collisions.Body = true
						other.Collisions.Body = true

						table.insert(CollidingWith, other)
					else
						body.Collisions.Body = false
						other.Collisions.Body = false

						if body.TouchEnded._handlerListHead and body.TouchEnded._handlerListHead.Connected then
							if
								SearchTable(OldCollidingWith, other, function(a, b)
									return a.id == b.id
								end)
							then
								body.TouchEnded:Fire(other.id)
							end
						end
					end
				end
			end
		end

		body.Collisions.Other = CollidingWith
	end

	if #self.points > 0 then
		for _, point in ipairs(self.points) do
			point:Update(dt)
		end
	end
	if #self.constraints > 0 then
		for _, constraint in ipairs(self.constraints) do
			if constraint._TYPE ~= "SPRING" then
				for i = 1, self.iterations.constraint do
					constraint:Constrain()
				end
			else
				constraint:Constrain()
			end
		end
	end

	self.Updated:Fire()
end
function Runner.Render(self)
	for _, body in ipairs(self.bodies) do
		body:Render()
	end
	for _, point in ipairs(self.points) do
		point:Render()
	end
	for _, constraint in ipairs(self.constraints) do
		constraint:Render()
	end
end

return Runner
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="18">
              <Properties>
                <string name="Name">Plugins</string>
                <string name="Source"><![CDATA[return {
	MouseConstraint = require(script.MouseConstraint),
	Quad = require(script.Quad),
	Triangle = require(script.Triangle),
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="19">
                <Properties>
                  <string name="Name">MouseConstraint</string>
                  <string name="Source"><![CDATA[local UserInputService = game:GetService("UserInputService")

return function(engine, range)
	local held = nil
	local connections = {}

	connections.InputBegan = UserInputService.InputBegan:Connect(function(input, processedEvent)
		if processedEvent then
			return
		end
		if input.UserInputType == Enum.UserInputType.MouseButton1 and not held then
			for _, b in ipairs(engine.bodies) do
				for _, p in ipairs(b.vertices) do
					if (p.pos - UserInputService:GetMouseLocation()).Magnitude <= range then
						p.selectable = true
						p.snap = true
						held = p

						break
					end
				end

				if held then
					break
				end
			end
		end
	end)
	connections.InputEnded = UserInputService.InputEnded:Connect(function(input, processedEvent)
		if processedEvent then
			return
		end
		if input.UserInputType == Enum.UserInputType.MouseButton1 and held then
			held.selectable = false
			held.snap = false
			held = nil
		end
	end)
	connections.InputChanged = UserInputService.InputChanged:Connect(function(input, processedEvent)
		if processedEvent then
			return
		end
		if input.UserInputType == Enum.UserInputType.MouseMovement and held then
			local mouse = UserInputService:GetMouseLocation()

			held:SetPosition(mouse.X, mouse.Y)
		end
	end)

	return function()
		held.snap = false
		held = nil

		connections.InputBegan:Disconnect()
		connections.InputEnded:Disconnect()
		connections.InputChanged:Disconnect()
	end
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="20">
                <Properties>
                  <string name="Name">Quad</string>
                  <string name="Source"><![CDATA[return function(a, b, c, d)
	return {
		{ a, b, false },
		{ b, c, false },
		{ c, d, false },
		{ d, a, false },
		{ a, c, true },
		{ b, d, true },
	}
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="21">
                <Properties>
                  <string name="Name">Triangle</string>
                  <string name="Source"><![CDATA[return function(a, b, c)
	return {
		{ a, b, false },
		{ a, c, false },
		{ b, c, false },
	}
end
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="22">
              <Properties>
                <string name="Name">Types</string>
                <string name="Source"><![CDATA[return nil
]]></string>
              </Properties>
            </Item>
            <Item class="Folder" referent="23">
              <Properties>
                <string name="Name">Utilities</string>
              </Properties>
              <Item class="ModuleScript" referent="24">
                <Properties>
                  <string name="Name">Janitor</string>
                  <string name="Source"><![CDATA[local GetPromiseLibrary = require(script.GetPromiseLibrary)
local Symbol = require(script.Symbol)
local FoundPromiseLibrary, Promise = GetPromiseLibrary()
local IndicesReference = Symbol("IndicesReference")
local LinkToInstanceIndex = Symbol("LinkToInstanceIndex")
local METHOD_NOT_FOUND_ERROR = [[Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s]]
local NOT_A_PROMISE = [[Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s))]]
local Janitor = {}

Janitor.ClassName = "Janitor"
Janitor.CurrentlyCleaning = true
Janitor[IndicesReference] = nil
Janitor.__index = Janitor

local TypeDefaults = {
	["function"] = true,
	RBXScriptConnection = "Disconnect",
}

function Janitor.Is(Object)
	return type(Object) == "table" and getmetatable(Object) == Janitor
end
function Janitor:Add(Object, MethodName, Index)
	if Index then
		self:Remove(Index)

		local This = self[IndicesReference]

		if not This then
			This = {}
			self[IndicesReference] = This
		end

		This[Index] = Object
	end

	MethodName = MethodName or TypeDefaults[typeof(Object)] or "Destroy"

	if type(Object) ~= "function" and not Object[MethodName] then
		warn(string.format(METHOD_NOT_FOUND_ERROR, tostring(Object), tostring(MethodName), debug.traceback(nil, 2)))
	end

	self[Object] = MethodName

	return Object
end
function Janitor:AddPromise(PromiseObject)
	if FoundPromiseLibrary then
		if not Promise.is(PromiseObject) then
			error(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject)))
		end
		if PromiseObject:getStatus() == Promise.Status.Started then
			local Id = newproxy(false)
			local NewPromise = self:Add(
				Promise.new(function(Resolve, _, OnCancel)
					if OnCancel(function()
						PromiseObject:cancel()
					end) then
						return
					end

					Resolve(PromiseObject)
				end),
				"cancel",
				Id
			)

			NewPromise:finallyCall(self.Remove, self, Id)

			return NewPromise
		else
			return PromiseObject
		end
	else
		return PromiseObject
	end
end
function Janitor:Remove(Index)
	local This = self[IndicesReference]

	if This then
		local Object = This[Index]

		if Object then
			local MethodName = self[Object]

			if MethodName then
				if MethodName == true then
					Object()
				else
					local ObjectMethod = Object[MethodName]

					if ObjectMethod then
						ObjectMethod(Object)
					end
				end

				self[Object] = nil
			end

			This[Index] = nil
		end
	end

	return self
end
function Janitor:Get(Index)
	local This = self[IndicesReference]

	if This then
		return This[Index]
	else
		return nil
	end
end

local function GetFenv(self)
	return function()
		for Object, MethodName in pairs(self) do
			if Object ~= IndicesReference then
				return Object, MethodName
			end
		end
	end
end

function Janitor:Cleanup()
	if not self.CurrentlyCleaning then
		self.CurrentlyCleaning = nil

		local Get = GetFenv(self)
		local Object, MethodName = Get()

		while Object and MethodName do
			if MethodName == true then
				Object()
			else
				local ObjectMethod = Object[MethodName]

				if ObjectMethod then
					ObjectMethod(Object)
				end
			end

			self[Object] = nil
			Object, MethodName = Get()
		end

		local This = self[IndicesReference]

		if This then
			table.clear(This)

			self[IndicesReference] = {}
		end

		self.CurrentlyCleaning = false
	end
end
function Janitor:Destroy()
	self:Cleanup()
	table.clear(self)
	setmetatable(self, nil)
end

Janitor.__call = Janitor.Cleanup

local RbxScriptConnection = {}

RbxScriptConnection.Connected = true
RbxScriptConnection.__index = RbxScriptConnection

function RbxScriptConnection:Disconnect()
	if self.Connected then
		self.Connected = false

		self.Connection:Disconnect()
	end
end
function RbxScriptConnection._new(RBXScriptConnection)
	return setmetatable({ Connection = RBXScriptConnection }, RbxScriptConnection)
end
function RbxScriptConnection:__tostring()
	return "RbxScriptConnection<" .. tostring(self.Connected) .. ">"
end
function Janitor:LinkToInstance(Object, AllowMultiple)
	local Connection
	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex
	local IsNilParented = Object.Parent == nil
	local ManualDisconnect = setmetatable({}, RbxScriptConnection)

	local function ChangedFunction(_DoNotUse, NewParent)
		if ManualDisconnect.Connected then
			_DoNotUse = nil
			IsNilParented = NewParent == nil

			if IsNilParented then
				task.defer(function()
					if not ManualDisconnect.Connected then
						return
					elseif not Connection.Connected then
						self:Cleanup()
					else
						while IsNilParented and Connection.Connected and ManualDisconnect.Connected do
							task.wait()
						end

						if ManualDisconnect.Connected and IsNilParented then
							self:Cleanup()
						end
					end
				end)
			end
		end
	end

	Connection = Object.AncestryChanged:Connect(ChangedFunction)
	ManualDisconnect.Connection = Connection

	if IsNilParented then
		ChangedFunction(nil, Object.Parent)
	end

	Object = nil

	return self:Add(ManualDisconnect, "Disconnect", IndexToUse)
end
function Janitor:LinkToInstances(...)
	local ManualCleanup = Janitor.new()

	for _, Object in ipairs({ ... }) do
		ManualCleanup:Add(self:LinkToInstance(Object, true), "Disconnect")
	end

	return ManualCleanup
end
function Janitor.new()
	return setmetatable({
		CurrentlyCleaning = false,
		[IndicesReference] = nil,
	}, Janitor)
end

return Janitor
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="25">
                  <Properties>
                    <string name="Name">GetPromiseLibrary</string>
                    <string name="Source"><![CDATA[local ReplicatedFirst = game:GetService("ReplicatedFirst")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local ServerStorage = game:GetService("ServerStorage")
local LOCATIONS_TO_SEARCH = {
	script.Parent.Parent,
	ReplicatedFirst,
	ReplicatedStorage,
	ServerScriptService,
	ServerStorage,
}

local function FindFirstDescendantWithNameAndClassName(Parent, Name, ClassName)
	for _, Descendant in ipairs(Parent:GetDescendants()) do
		if Descendant:IsA(ClassName) and Descendant.Name == Name then
			return Descendant
		end
	end

	return nil
end
local function GetPromiseLibrary()
	local Plugin = script:FindFirstAncestorOfClass("Plugin")

	if Plugin then
		local Promise = FindFirstDescendantWithNameAndClassName(Plugin, "Promise", "ModuleScript")

		if Promise then
			return true, require(Promise)
		else
			return false
		end
	end

	local Promise

	for _, Location in ipairs(LOCATIONS_TO_SEARCH) do
		Promise = FindFirstDescendantWithNameAndClassName(Location, "Promise", "ModuleScript")

		if Promise then
			break
		end
	end

	if Promise then
		return true, require(Promise)
	else
		return false
	end
end

return GetPromiseLibrary
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="26">
                  <Properties>
                    <string name="Name">Symbol</string>
                    <string name="Source"><![CDATA[local function Symbol(Name)
	local self = newproxy(true)
	local Metatable = getmetatable(self)

	function Metatable.__tostring()
		return Name
	end

	return self
end

return Symbol
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="27">
                <Properties>
                  <string name="Name">Line</string>
                  <string name="Source"><![CDATA[local Globals = require(script.Parent.Parent.Constants.Globals)

local function draw(hyp, origin, thickness, parent, color, l, image)
	local line = l or (image and Instance.new("ImageLabel") or Instance.new("Frame"))

	line.Name = "Constraint"
	line.AnchorPoint = Vector2.new(0.5, 0.5)
	line.Size = UDim2.new(0, hyp, 0, (thickness or Globals.constraint.thickness) + (image and 15 or 0))
	line.BackgroundTransparency = image and 1 or 0
	line.BorderSizePixel = 0
	line.Position = UDim2.fromOffset(origin.X, origin.Y)
	line.ZIndex = 1

	if image then
		line.Image = image
		line.ImageColor3 = color or Globals.constraint.color
	else
		line.BackgroundColor3 = color or Globals.constraint.color
	end

	line.Parent = parent

	return line
end

return function(origin, endpoint, parent, thickness, color, l, image)
	local hyp = (endpoint - origin).Magnitude
	local line = draw(hyp, origin, thickness, parent, color, l, image)
	local mid = (origin + endpoint) / 2
	local theta = math.atan2((origin - endpoint).Y, (origin - endpoint).X)

	line.Position = UDim2.fromOffset(mid.x, mid.y)
	line.Rotation = math.deg(theta)

	return line
end
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="28">
                <Properties>
                  <string name="Name">Quadtree</string>
                  <string name="Source"><![CDATA[-- #selene: allow(unused_variable)

local Types = require(script.Parent.Parent.Types)
local Quadtree = {}

Quadtree.__index = Quadtree

local function GetDivisions(position, size)
	return {
		position,
		position + Vector2.new(size.X / 2, 0),
		position + Vector2.new(0, size.Y / 2),
		position + Vector2.new(size.X / 2, size.Y / 2),
	}
end
local function RangeOverlapsNode(node, range)
	local ap1 = range.position
	local as1 = range.size
	local sum = ap1 + as1
	local ap2 = node.position
	local as2 = node.size
	local sum2 = ap2 + as2

	return (ap1.x < sum2.x and sum.x > ap2.x) and (ap1.y < sum2.y and sum.y > ap2.y)
end
local function RangeHasPoint(range, obj)
	local p = obj.center

	return (
		(p.X > range.position.X)
		and (p.X < (range.position.X + range.size.X))
		and (p.Y > range.position.Y)
		and (p.Y < (range.position.Y + range.size.Y))
	)
end
local function merge(array1, array2)
	if #array2 > 0 then
		for _, v in ipairs(array2) do
			table.insert(array1, v)
		end
	end

	return array1
end

function Quadtree.new(_position, _size, _capacity)
	return setmetatable({
		position = _position,
		size = _size,
		capacity = _capacity,
		objects = {},
		divided = false,
	}, Quadtree)
end
function Quadtree:Insert(body)
	if not self:HasObject(body.center) then
		return
	end
	if #self.objects < self.capacity then
		self.objects[#self.objects + 1] = body
	else
		if not self.divided then
			self:SubDivide()

			self.divided = true
		end

		self.topLeft:Insert(body)
		self.topRight:Insert(body)
		self.bottomLeft:Insert(body)
		self.bottomRight:Insert(body)
	end
end
function Quadtree:HasObject(p)
	return (
		(p.X > self.position.X)
		and (p.X < (self.position.X + self.size.X))
		and (p.Y > self.position.Y)
		and (p.Y < (self.position.Y + self.size.Y))
	)
end
function Quadtree:SubDivide()
	local divisions = GetDivisions(self.position, self.size)

	self.topLeft = Quadtree.new(divisions[1], self.size / 2, self.capacity)
	self.topRight = Quadtree.new(divisions[2], self.size / 2, self.capacity)
	self.bottomLeft = Quadtree.new(divisions[3], self.size / 2, self.capacity)
	self.bottomRight = Quadtree.new(divisions[4], self.size / 2, self.capacity)
end
function Quadtree:Search(range, objects)
	if not objects then
		objects = {}
	end
	if not RangeOverlapsNode(self, range) then
		return objects
	end

	for _, obj in ipairs(self.objects) do
		if RangeHasPoint(range, obj) then
			objects[#objects + 1] = obj
		end
	end

	if self.divided then
		self.topLeft:Search(range, objects)
		self.topRight:Search(range, objects)
		self.bottomLeft:Search(range, objects)
		self.bottomRight:Search(range, objects)
	end

	return objects
end

return Quadtree
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="29">
                <Properties>
                  <string name="Name">Signal</string>
                  <string name="Source"><![CDATA[local freeRunnerThread = nil

local function acquireRunnerThreadAndCallEventHandler(fn, ...)
    local acquiredRunnerThread = freeRunnerThread

    freeRunnerThread = nil

    fn(...)

    freeRunnerThread = acquiredRunnerThread
end
local function runEventHandlerInFreeThread(...)
    acquireRunnerThreadAndCallEventHandler(...)

    while true do
        acquireRunnerThreadAndCallEventHandler(coroutine.yield())
    end
end

local Connection = {}

Connection.__index = Connection

function Connection.new(signal, fn)
    return setmetatable({
        Connected = true,
        _signal = signal,
        _fn = fn,
        _next = false,
    }, Connection)
end
function Connection:Disconnect()
    if not self.Connected then
        return
    end

    self.Connected = false

    if self._signal._handlerListHead == self then
        self._signal._handlerListHead = self._next
    else
        local prev = self._signal._handlerListHead

        while prev and prev._next ~= self do
            prev = prev._next
        end

        if prev then
            prev._next = self._next
        end
    end
end

Connection.Destroy = Connection.Disconnect

setmetatable(Connection, {
    __index = function(_tb, key)
        if key ~= '_handlerListHead' then
            error(('Attempt to get Connection::%s (not a valid member)'):format(tostring(key)), 2)
        end
    end,
    __newindex = function(_tb, key, _value)
        error(('Attempt to set Connection::%s (not a valid member)'):format(tostring(key)), 2)
    end,
})

local Signal = {}

Signal.__index = Signal

function Signal.new()
    local self = setmetatable({
        _handlerListHead = false,
        _proxyHandler = nil,
    }, Signal)

    return self
end
function Signal.Wrap(rbxScriptSignal)
    assert(typeof(rbxScriptSignal) == 'RBXScriptSignal', 'Argument #1 to Signal.Wrap must be a RBXScriptSignal; got ' .. typeof(rbxScriptSignal))

    local signal = Signal.new()

    signal._proxyHandler = rbxScriptSignal:Connect(function(...)
        signal:Fire(...)
    end)

    return signal
end
function Signal.Is(obj)
    return type(obj) == 'table' and getmetatable(obj) == Signal
end
function Signal:Connect(fn)
    local connection = Connection.new(self, fn)

    if self._handlerListHead then
        connection._next = self._handlerListHead
        self._handlerListHead = connection
    else
        self._handlerListHead = connection
    end

    return connection
end
function Signal:GetConnections()
    local items = {}
    local item = self._handlerListHead

    while item do
        table.insert(items, item)

        item = item._next
    end

    return items
end
function Signal:DisconnectAll()
    local item = self._handlerListHead

    while item do
        item.Connected = false
        item = item._next
    end

    self._handlerListHead = false
end
function Signal:Fire(...)
    local item = self._handlerListHead

    while item do
        if item.Connected then
            if not freeRunnerThread then
                freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
            end

            task.spawn(freeRunnerThread, item._fn, ...)
        end

        item = item._next
    end
end
function Signal:FireDeferred(...)
    local item = self._handlerListHead

    while item do
        task.defer(item._fn, ...)

        item = item._next
    end
end
function Signal:Wait()
    local waitingCoroutine = coroutine.running()
    local cn

    cn = self:Connect(function(...)
        cn:Disconnect()
        task.spawn(waitingCoroutine, ...)
    end)

    return coroutine.yield()
end
function Signal:Destroy()
    self:DisconnectAll()

    local proxyHandler = rawget(self, '_proxyHandler')

    if proxyHandler then
        proxyHandler:Disconnect()
    end
end

setmetatable(Signal, {
    __index = function(_tb, key)
        if key ~= 'Connected' then
            error(('Attempt to get Signal::%s (not a valid member)'):format(tostring(key)), 2)
        end
    end,
    __newindex = function(_tb, key, _value)
        error(('Attempt to set Signal::%s (not a valid member)'):format(tostring(key)), 2)
    end,
})

return Signal
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
        </Item>
      </Item>
    </Item>
    <Item class="ModuleScript" referent="30">
      <Properties>
        <string name="Name">Utilities</string>
        <string name="Source"><![CDATA[local Utilities = {}

local InsertService = game:GetService("InsertService")

local RunService = game:GetService("RunService")
local isServer = RunService:IsServer()

local ERROR_FORMAT = "Found duplicated %s modules: %q, name must be unique"

local function registerUtilityModules()
	for _, child: Instance in ipairs(script:GetChildren()) do
		if child:IsA("ModuleScript") then
			local moduleScript: ModuleScript = child
			if Utilities[moduleScript.Name] == nil then
				Utilities[moduleScript.Name] = moduleScript
			else
				error(string.format(ERROR_FORMAT, "Utilities", moduleScript.Name))
			end
		end
	end
end

registerUtilityModules()

local function registerThirdPartyModules()
	local THIRDPARTY_MODULE_ASSET_ID = 8255468519
	local Model: Model = InsertService:LoadAsset(THIRDPARTY_MODULE_ASSET_ID)
	local thirdpartyModule: ModuleScript = require(Model.MainModule)
	for _, child: Instance in ipairs(thirdpartyModule:GetChildren()) do
		if child:IsA("ModuleScript") then
			local moduleScript: ModuleScript = child
			moduleScript.Parent = script
			if Utilities[moduleScript.Name] == nil then
				Utilities[moduleScript.Name] = moduleScript
			else
				error(string.format(ERROR_FORMAT, "Third-party", moduleScript.Name))
			end
		end
	end
	thirdpartyModule:Destroy()
end

if isServer then
	registerThirdPartyModules()
end

return Utilities
]]></string>
        <BinaryString name="Tags">QXV0by1SdW4AV2FsbHk=</BinaryString>
      </Properties>
      <Item class="ModuleScript" referent="31">
        <Properties>
          <string name="Name">Colors</string>
          <string name="Source"><![CDATA[local Color = {
	Alder = Color3.new(0.705882, 0.501961, 1.000000),
	Artichoke = Color3.new(0.541176, 0.670588, 0.521569),
	Beige = Color3.new(0.792157, 0.749020, 0.639216),
	Black = Color3.new(0.105882, 0.164706, 0.207843),
	Bronze = Color3.new(0.494118, 0.407843, 0.247059),
	Brown = Color3.new(0.486275, 0.360784, 0.274510),
	Burgundy = Color3.new(0.533333, 0.243137, 0.243137),
	Burlap = Color3.new(0.780392, 0.674510, 0.470588),
	Buttermilk = Color3.new(0.996078, 0.952941, 0.733333),
	Camo = Color3.new(0.227451, 0.490196, 0.082353),
	Cashmere = Color3.new(0.827451, 0.745098, 0.588235),
	Cocoa = Color3.new(0.337255, 0.141176, 0.141176),
	Copper = Color3.new(0.588235, 0.403922, 0.400000),
	Cork = Color3.new(0.737255, 0.607843, 0.364706),
	Crimson = Color3.new(0.592157, 0.000000, 0.000000),
	Cyan = Color3.new(0.015686, 0.686275, 0.925490),
	Eggplant = Color3.new(0.482353, 0.000000, 0.482353),
	Flint = Color3.new(0.411765, 0.400000, 0.360784),
	Fog = Color3.new(0.780392, 0.831373, 0.894118),
	Fossil = Color3.new(0.623529, 0.631373, 0.674510),
	Gold = Color3.new(0.937255, 0.721569, 0.219608),
	Grime = Color3.new(0.498039, 0.556863, 0.392157),
	Khaki = Color3.new(0.886275, 0.862745, 0.737255),
	Lapis = Color3.new(0.062745, 0.164706, 0.862745),
	Lavender = Color3.new(0.549020, 0.356863, 0.623529),
	Lilac = Color3.new(0.654902, 0.368627, 0.607843),
	Linen = Color3.new(0.686275, 0.580392, 0.513726),
	Magenta = Color3.new(0.666667, 0.000000, 0.666667),
	Maroon = Color3.new(0.458824, 0.000000, 0.000000),
	Mauve = Color3.new(0.878431, 0.698039, 0.815686),
	Mint = Color3.new(0.694118, 0.898039, 0.650980),
	Moss = Color3.new(0.486275, 0.611765, 0.419608),
	Mulberry = Color3.new(0.349020, 0.133333, 0.349020),
	Nougat = Color3.new(0.800000, 0.556863, 0.411765),
	Olive = Color3.new(0.756863, 0.745098, 0.258824),
	Olivine = Color3.new(0.580392, 0.745098, 0.505882),
	Oyster = Color3.new(0.733333, 0.701961, 0.698039),
	Pearl = Color3.new(0.905882, 0.905882, 0.925490),
	Persimmon = Color3.new(1.000000, 0.349020, 0.349020),
	Pink = Color3.new(1.000000, 0.400000, 0.800000),
	Plum = Color3.new(0.482353, 0.184314, 0.482353),
	Rust = Color3.new(0.560784, 0.298039, 0.164706),
	Salmon = Color3.new(1.000000, 0.580392, 0.580392),
	Seashell = Color3.new(0.913726, 0.854902, 0.854902),
	Shamrock = Color3.new(0.356863, 0.603922, 0.298039),
	Sunrise = Color3.new(0.831373, 0.564706, 0.741176),
	Tawny = Color3.new(0.588235, 0.333333, 0.333333),
	Teal = Color3.new(0.070588, 0.933333, 0.831373),
	Toothpaste = Color3.new(0.000000, 1.000000, 1.000000),
	Wheat = Color3.new(0.945098, 0.905882, 0.780392),
	White = Color3.new(0.949020, 0.952941, 0.952941),
	["Baby blue"] = Color3.new(0.596078, 0.760784, 0.858824),
	["Br. yellowish green"] = Color3.new(0.643137, 0.741176, 0.278431),
	["Br. yellowish orange"] = Color3.new(0.886275, 0.607843, 0.250980),
	["Brick yellow"] = Color3.new(0.843137, 0.772549, 0.603922),
	["Bright blue"] = Color3.new(0.050980, 0.411765, 0.674510),
	["Bright bluish green"] = Color3.new(0.000000, 0.560784, 0.611765),
	["Bright green"] = Color3.new(0.294118, 0.592157, 0.294118),
	["Bright orange"] = Color3.new(0.854902, 0.521569, 0.254902),
	["Bright red"] = Color3.new(0.768628, 0.156863, 0.109804),
	["Bright violet"] = Color3.new(0.419608, 0.196078, 0.486275),
	["Bright yellow"] = Color3.new(0.960784, 0.803922, 0.188235),
	["Burnt Sienna"] = Color3.new(0.415686, 0.223529, 0.035294),
	["CGA brown"] = Color3.new(0.666667, 0.333333, 0.000000),
	["Cadet blue"] = Color3.new(0.623529, 0.678431, 0.752941),
	["Carnation pink"] = Color3.new(1.000000, 0.596078, 0.862745),
	["Cloudy grey"] = Color3.new(0.670588, 0.658824, 0.619608),
	["Cool yellow"] = Color3.new(0.992157, 0.917647, 0.552941),
	["Daisy orange"] = Color3.new(0.972549, 0.850980, 0.427451),
	["Dark blue"] = Color3.new(0.000000, 0.062745, 0.690196),
	["Dark green"] = Color3.new(0.156863, 0.498039, 0.278431),
	["Dark indigo"] = Color3.new(0.239216, 0.082353, 0.521569),
	["Dark orange"] = Color3.new(0.627451, 0.372549, 0.207843),
	["Dark stone grey"] = Color3.new(0.388235, 0.372549, 0.384314),
	["Dark taupe"] = Color3.new(0.352941, 0.298039, 0.258824),
	["Deep blue"] = Color3.new(0.129412, 0.329412, 0.725490),
	["Deep orange"] = Color3.new(1.000000, 0.690196, 0.000000),
	["Dirt brown"] = Color3.new(0.337255, 0.258824, 0.211765),
	["Dusty Rose"] = Color3.new(0.639216, 0.294118, 0.294118),
	["Earth green"] = Color3.new(0.152941, 0.274510, 0.176471),
	["Electric blue"] = Color3.new(0.035294, 0.537255, 0.811765),
	["Fawn brown"] = Color3.new(0.627451, 0.517647, 0.309804),
	["Forest green"] = Color3.new(0.121569, 0.501961, 0.113725),
	["Ghost grey"] = Color3.new(0.792157, 0.796079, 0.819608),
	["Hot pink"] = Color3.new(1.000000, 0.000000, 0.749020),
	["Hurricane grey"] = Color3.new(0.584314, 0.537255, 0.533333),
	["Institutional white"] = Color3.new(0.972549, 0.972549, 0.972549),
	["Laurel green"] = Color3.new(0.658824, 0.741176, 0.600000),
	["Light blue"] = Color3.new(0.705882, 0.823529, 0.894118),
	["Light orange"] = Color3.new(0.917647, 0.721569, 0.572549),
	["Light reddish violet"] = Color3.new(0.909804, 0.729412, 0.784314),
	["Light stone grey"] = Color3.new(0.898039, 0.894118, 0.874510),
	["Lily white"] = Color3.new(0.929412, 0.917647, 0.917647),
	["Lime green"] = Color3.new(0.000000, 1.000000, 0.000000),
	["Medium blue"] = Color3.new(0.431373, 0.600000, 0.792157),
	["Medium green"] = Color3.new(0.631373, 0.768628, 0.549020),
	["Medium red"] = Color3.new(0.854902, 0.525490, 0.478431),
	["Medium stone grey"] = Color3.new(0.639216, 0.635294, 0.647059),
	["Mid gray"] = Color3.new(0.803922, 0.803922, 0.803922),
	["Navy blue"] = Color3.new(0.000000, 0.125490, 0.376471),
	["Neon orange"] = Color3.new(0.835294, 0.450980, 0.239216),
	["New Yeller"] = Color3.new(1.000000, 1.000000, 0.000000),
	["Parsley green"] = Color3.new(0.172549, 0.396078, 0.113725),
	["Pastel Blue"] = Color3.new(0.501961, 0.733333, 0.858824),
	["Pastel blue-green"] = Color3.new(0.623529, 0.952941, 0.913726),
	["Pastel brown"] = Color3.new(1.000000, 0.800000, 0.600000),
	["Pastel green"] = Color3.new(0.800000, 1.000000, 0.800000),
	["Pastel light blue"] = Color3.new(0.686275, 0.866667, 1.000000),
	["Pastel orange"] = Color3.new(1.000000, 0.788235, 0.788235),
	["Pastel violet"] = Color3.new(0.694118, 0.654902, 1.000000),
	["Pastel yellow"] = Color3.new(1.000000, 1.000000, 0.800000),
	["Pine Cone"] = Color3.new(0.423529, 0.345098, 0.294118),
	["Quill grey"] = Color3.new(0.874510, 0.874510, 0.870588),
	["Really black"] = Color3.new(0.066667, 0.066667, 0.066667),
	["Really blue"] = Color3.new(0.000000, 0.000000, 1.000000),
	["Really red"] = Color3.new(1.000000, 0.000000, 0.000000),
	["Reddish brown"] = Color3.new(0.411765, 0.250980, 0.156863),
	["Royal purple"] = Color3.new(0.384314, 0.145098, 0.819608),
	["Sage green"] = Color3.new(0.725490, 0.768628, 0.694118),
	["Sand blue"] = Color3.new(0.454902, 0.525490, 0.615686),
	["Sand green"] = Color3.new(0.470588, 0.564706, 0.509804),
	["Sand red"] = Color3.new(0.584314, 0.474510, 0.466667),
	["Sea green"] = Color3.new(0.203922, 0.556863, 0.250980),
	["Slime green"] = Color3.new(0.313726, 0.427451, 0.329412),
	["Smoky grey"] = Color3.new(0.356863, 0.364706, 0.411765),
	["Steel blue"] = Color3.new(0.321569, 0.486275, 0.682353),
	["Storm blue"] = Color3.new(0.200000, 0.345098, 0.509804),
	["Terra Cotta"] = Color3.new(0.745098, 0.407843, 0.384314),
}

Color.white = Color3.new(1, 1, 1)
Color.black = Color3.new(0, 0, 0)

Color.red = Color3.new(1, 0, 0)
Color.green = Color3.new(0, 1, 0)
Color.blue = Color3.new(0, 0, 1)

Color.yellow = Color3.new(1, 1, 0)
Color.orange = Color3.new(1, 0.5, 0)
Color.purple = Color3.new(1, 0, 1)

return Color
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="32">
        <Properties>
          <string name="Name">Cooldown</string>
          <string name="Source"><![CDATA[export type Cooldown = {
	add: (any) -> void,
	has: (any) -> (boolean),
	remove: (any) -> void,
	removeAfter: (any, number) -> void,
}

local Cooldown: Cooldown = {}

function Cooldown.add(object: any)
	Cooldown[object] = true
end

function Cooldown.has(object: any): boolean
	return Cooldown[object] and true
end

function Cooldown.remove(object: any)
	Cooldown[object] = nil
end

function Cooldown.removeAfter(object: any, duration: number)
	Cooldown.add(object)
	task.delay(duration, Cooldown.remove, object)
end

return Cooldown
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="33">
        <Properties>
          <string name="Name">Debris2</string>
          <string name="Source"><![CDATA[local Debris2 = {
	Instances = {},
}

local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat

local Instances = Debris2.Instances

local Connections = {}

local ValidTypes = {
	["Instance"] = "Destroy",
	["table"] = {},
	["RBXScriptConnection"] = "Disconnect",
}

local METHODS = {
	"Destroy",
	"Disconnect",
}

local function removeItem(typeOf: string, object: Instance)
	if typeOf == "Instance" then
		pcall(object.Destroy, object)
	elseif typeOf == "RBXScriptConnection" then
		pcall(object.Disconnect, object)
	else
		for _, v: string in ipairs(METHODS) do -- _, v: method name
			if object[v] then
				pcall(object[v], v)
				break
			end
		end
	end
end

local function addDebris(object: Instance, lifeTime: number)
	local typeOf = typeof(object)

	assert(ValidTypes[typeof(object)], "not valid type")
	assert(typeof(lifeTime) == "number", "lifeTime must be a number")

	if not Instances[object] then
		table.insert(Instances, object)
	end

	Instances[object] = {
		["lifeTime"] = lifeTime,
		removalTime = tick() + lifeTime,
		Cancel = function()
			Connections[object]:Disconnect()
			table.remove(Instances, table.find(Instances, object))
			Instances[object] = nil
		end,
		["Instance"] = object,
	}

	local debris = Instances[object]

	Connections[object] = Heartbeat:Connect(function()
		if debris and tick() >= debris.removalTime then
			if debris.Destroyed then
				debris.Destroyed()
			end
			debris.Cancel()
			removeItem(typeOf, object)
		end
		debris = Instances[object]
	end)

	return Instances[object]
end

function Debris2:AddItem(item, lifeTime: number)
	return addDebris(item, lifeTime)
end

function Debris2:AddItems(arrayOfItems: Array, lifeTime: number)
	for _, item in ipairs(arrayOfItems) do
		addDebris(item, lifeTime)
	end
end

function Debris2.GetAllDebris(): Instances
	return Instances
end

function Debris2.GetDebris(item)
	return Instances[item]
end

return Debris2
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="34">
        <Properties>
          <string name="Name">JSON</string>
          <string name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

export type JSON = {
	Decode: (string: string) -> table,
	DeepCopy: (table: table) -> table,
	Encode: (table: table) -> string,
	Filter: (table: table, filterType: string, cache: table?) -> string,
	GenerateGUID: (wrapInCurlyBraces: boolean) -> string,
	Length: (table: table) -> integer,
	-- Repair: (dictionary: table) -> table,
	Valid: (table: table) -> (boolean, string?, string?),
}

local JSON = {}

function JSON.Decode(string: string): table
	return HttpService:JSONDecode(string)
end

function JSON.DeepCopy(table: table): table
	return JSON.Decode(JSON.Encode(table))
end

function JSON.Encode(table: table): string
	return HttpService:JSONEncode(table)
end

local Filters = require(script.Filters)
function JSON.Filter(table: table, filterType: string, cache: table?): table?
	cache = cache or {}
	local new = {}
	local filter = Filters[filterType]

	cache[table] = true

	for k, v in pairs(table) do
		if typeof(v) == "table" then
			if not cache[v] then
				new[k] = JSON.Filter(v, filterType, cache)
			else
				new[k] = "Cyclic Table: " .. tostring(v)
			end
		elseif filter[typeof(k)] and filter[typeof(v)] then
			new[k] = v
		end
	end

	cache[table] = nil

	return new
end

function JSON.GenerateGUID(wrapInCurlyBraces: boolean): string
	return HttpService:GenerateGUID(wrapInCurlyBraces)
end

function JSON.Length(table: table): integer
	return #JSON.Encode(table)
end

-- function JSON.Repair(dictionary: table): table
-- 	local isValid: boolean, path: Array, problem: string = JSON.Valid(dictionary)
-- 	if not isValid then
-- 		warn(problem, path)
-- 		local index = dictionary
-- 		for i: integer = 2, #path do
-- 			local key = path[i]
-- 			if i == #path then
-- 				index[key] = nil
-- 			else
-- 				index = index[key]
-- 			end
-- 		end
-- 		return JSON.Repair(dictionary)
-- 	end

-- 	return dictionary
-- end

local scanValidity = require(script.scanValidity)

function JSON.Valid(table: table): (boolean, Array?, string?)
	return scanValidity(table)
end

return JSON
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="35">
          <Properties>
            <string name="Name">Filters</string>
            <string name="Source"><![CDATA[local Filters = {}

-- Filters.Type = {
-- 	Attribute = "Attribute",
--	Display = "Display",
-- 	JSON = "JSON",
-- 	-- Network = "Network",
-- }

Filters.Attribute = {
	[typeof(BrickColor.random())] = true,
	[typeof(Color3.new())] = true,
	[typeof(ColorSequence.new(Color3.new()))] = true,
	[typeof(NumberRange.new(0))] = true,
	[typeof(NumberSequence.new(0))] = true,
	[typeof(Rect.new(Vector2.new(), Vector2.new()))] = true,
	[typeof(UDim.new())] = true,
	[typeof(UDim2.new())] = true,
	[typeof(Vector2.new())] = true,
	[typeof(Vector3.new())] = true,

	[typeof(true)] = true,
	[typeof(3.142)] = true,
	[typeof("string")] = "true",
}

Filters.Display = {
	[typeof(BrickColor.random())] = true,
	[typeof(Color3.new())] = true,
	[typeof(ColorSequence.new(Color3.new()))] = true,
	[typeof(NumberRange.new(0))] = true,
	[typeof(NumberSequence.new(0))] = true,
	[typeof(Rect.new(Vector2.new(), Vector2.new()))] = true,
	[typeof(UDim.new())] = true,
	[typeof(UDim2.new())] = true,
	[typeof(Vector2.new())] = true,
	[typeof(Vector3.new())] = true,

	[typeof(true)] = true,
	[typeof(3.142)] = true,
	[typeof("string")] = "true",

	[typeof(CFrame.new())] = true,
	[typeof(Instance.new("Configuration"))] = true,
}

Filters.JSON = {
	[typeof(true)] = true,
	[typeof(3.142)] = true,
	[typeof("string")] = "true",
}

--[[

Filters.Network = { -- INCOMPLETE
	[typeof(BrickColor.random())] = true,
	[typeof(CFrame.new())] = true,
	[typeof(Color3.new())] = true,
	[typeof(ColorSequence.new(Color3.new()))] = true,
	[typeof(ColorSequence.new(Color3.new()))] = true,
	[typeof(Instance.new("Configuration"))] = true,
	[typeof(NumberRange.new(0))] = true,
	[typeof(NumberSequence.new(0))] = true,
	[typeof(Rect.new(Vector2.new(), Vector2.new()))] = true,
	[typeof(UDim.new())] = true,
	[typeof(UDim2.new())] = true,
	[typeof(Vector2.new())] = true,
	[typeof(Vector3.new())] = true,
	[typeof(true)] = true,
	[typeof(3.142)] = true,
	[typeof("string")] = "true",
}

]]

return Filters
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="36">
          <Properties>
            <string name="Name">scanValidity</string>
            <string name="Source"><![CDATA[local function scanValidity(table: table, cache: table?, path: Array?): (boolean, Array?, string?)
	if type(table) ~= "table" then
		return scanValidity({ input = table }, {}, {})
	end
	cache, path = cache or {}, path or { "root" }
	cache[table] = true
	local tblType
	do
		local key = next(table)
		if type(key) == "number" then
			tblType = "Array"
		else
			tblType = "Dictionary"
		end
	end
	local last = 0
	for key, value in next, table do
		path[#path + 1] = tostring(key)
		if type(key) == "number" then
			if tblType == "Dictionary" then
				return false, path, "cannot store mixed tables"
			elseif key % 1 ~= 0 then
				return false, path, "cannot store tables with non-integer indices"
			elseif key == math.huge or key == -math.huge then
				return false, path, "cannot store tables with (-)infinity indices"
			end
		elseif type(key) ~= "string" then
			return false, path, "dictionaries cannot have keys of type " .. typeof(key)
		elseif tblType == "Array" then
			return false, path, "cannot store mixed tables"
		end
		if tblType == "Array" then
			if last ~= key - 1 then
				return false, path, "array has non-sequential indices"
			end
			last = key
		end
		if type(value) == "userdata" or type(value) == "function" or type(value) == "thread" then
			return false, path, "cannot store value '" .. tostring(value) .. "' of type " .. typeof(value)
		end
		if type(value) == "table" then
			if cache[value] then
				return false, path, "cannot store cyclic tables"
			end
			local isValid, keyPath, reason = scanValidity(value, cache, path)
			if not isValid then
				return isValid, keyPath, reason
			end
		end
		path[#path] = nil
	end
	cache[table] = nil
	return true
end

return scanValidity
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="37">
        <Properties>
          <string name="Name">MovementSpeed</string>
          <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Configurations = require(ReplicatedStorage.Configurations)

local MovementSpeed = {
	MovementBuff = 0,
	MovementDebuff = 0,
}

function MovementSpeed.calculateTotalMovementSpeed(): number
	return math.max(
		(Configurations.MovementSpeed.Hiders * (1 + MovementSpeed.MovementBuff)) * (1 - MovementSpeed.MovementDebuff),
		1
	)
end

return MovementSpeed
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="38">
        <Properties>
          <string name="Name">Nature2D</string>
          <string name="Source">require(game.ReplicatedStorage.Packages.Nature2D)</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="39">
        <Properties>
          <string name="Name">TimeInSeconds</string>
          <string name="Source"><![CDATA[local TimeInSeconds = {}

TimeInSeconds.Second = 1
TimeInSeconds.Minute = 60 * TimeInSeconds.Second
TimeInSeconds.Hour = 60 * TimeInSeconds.Minute
TimeInSeconds.Day = 24 * TimeInSeconds.Hour
TimeInSeconds.Week = 7 * TimeInSeconds.Day
TimeInSeconds.Month = 30 * TimeInSeconds.Day
TimeInSeconds.Year = 12 * TimeInSeconds.Month

return TimeInSeconds
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="40">
        <Properties>
          <string name="Name">Timer</string>
          <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat

local Timer = { IS_CYCLICAL = true }
Timer.__index = Timer

type timer = {
	Name: string,
	Duration: number,

	_Change: BindableEvent,
	Changed: RBXScriptSignal,

	_Stop: BindableEvent,
	Stopped: RBXScriptSignal,
}

function Timer.create(name: string, duration: number): timer
	local Change = Instance.new("BindableEvent")
	local Stop = Instance.new("BindableEvent")
	local timer = {
		Name = name,
		Duration = duration,

		_Change = Change,
		Changed = Change.Event,

		_Stop = Stop,
		Stopped = Stop.Event,

		USING_METATABLE = true,
		-- Metatable = Timer,
	}
	Timer[name] = timer
	return setmetatable(timer, Timer)
end

function Timer:Start()
	local timer = self
	if not timer.Heartbeat then
		timer.Heartbeat = Heartbeat:Connect(function(dt)
			timer.Duration -= dt
			if timer.Duration < 0 then
				timer:Destroy()
				return
			end
			timer._Change:Fire(timer.Duration)
		end)
	end
end

function Timer:Destroy()
	local timer = self
	if timer.Heartbeat then
		timer.Heartbeat:Disconnect()
		timer._Stop:Fire()
	end
	timer._Stop:Destroy()
	timer._Change:Destroy()
	Timer[timer.Name] = nil
end

return Timer
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="41">
        <Properties>
          <string name="Name">TypeChecks</string>
          <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local t = require(Utilities.t)

local TypeChecks = {
	Optional = {},
	Strict = {},
}

TypeChecks.Strict.String = t.strict(t.string)

TypeChecks.Strict.Number = t.strict(t.number)

--

TypeChecks.Strict.CFrame = t.strict(t.CFrame)

TypeChecks.Strict.Instance = t.strict(t.Instance)

TypeChecks.Strict.Vector3 = t.strict(t.Vector3)

--

TypeChecks.Animator = t.instanceIsA("Animator")
TypeChecks.Strict.Animator = t.strict(t.instanceIsA("Animator"))

TypeChecks.AnimationTrack = t.instanceIsA("AnimationTrack")
TypeChecks.Strict.AnimationTrack = t.strict(t.instanceIsA("AnimationTrack"))

TypeChecks.BasePart = t.instanceIsA("BasePart")
TypeChecks.Strict.BasePart = t.strict(t.instanceIsA("BasePart"))

TypeChecks.Humanoid = t.instanceIsA("Humanoid")
TypeChecks.Strict.Humanoid = t.strict(t.instanceIsA("Humanoid"))

TypeChecks.Player = t.union(t.instanceIsA("Player"), t.instanceIsA("Configuration"))
TypeChecks.Strict.Player = t.strict(t.union(t.instanceIsA("Player"), t.instanceIsA("Configuration")))

TypeChecks.ProximityPrompt = t.instanceIsA("ProximityPrompt")
TypeChecks.Strict.ProximityPrompt = t.strict(t.instanceIsA("ProximityPrompt"))

TypeChecks.Model = t.instanceIsA("Model")
TypeChecks.Strict.Model = t.strict(t.instanceIsA("Model"))

TypeChecks.Motor6D = t.instanceIsA("Motor6D")
TypeChecks.Strict.Motor6D = t.strict(t.instanceIsA("Motor6D"))

TypeChecks.Tool = t.instanceIsA("Tool")
TypeChecks.Strict.Tool = t.strict(t.instanceIsA("Tool"))

TypeChecks.WorldModel = t.instanceIsA("WorldModel")
TypeChecks.Strict.WorldModel = t.strict(t.instanceIsA("WorldModel"))

--

return TypeChecks
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="42">
        <Properties>
          <string name="Name">array</string>
          <string name="Source"><![CDATA[export type array = {
	combine: (...Array) -> Array,
	deepCopy: (Array) -> Array,
	deepCompare: (Array, Array) -> boolean,
	dequeue: (array: Array) -> (any?),
	enqueue: (array: Array, value: any?) -> void,
	findDuplicates: (array: Array) -> Array,
	findFirstDuliplicate: (Array) -> any?,
	isEmpty: (Array) -> boolean,
	JSONCompare: (Array, Array) -> boolean,
	JSONCopy: (Array) -> Array,
	pop: (array: Array) -> any?,
	push: (array: Array, value: any?) -> void,
	random: (Array) -> any?,
	randoms: (Array, integer) -> any?,
	remove: (Array) -> (any & number)?,
	removeRandom: (Array) -> any?,
	shalowCompare: (Array, Array) -> boolean,
	shalowCopy: (Array) -> Array,
}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local JSON = require(Utilities.JSON)

local Array = {}

function Array.combine(...): Array
	local combinedArray: Array = {}
	local index: integer = 1

	for listIndex = 1, select("#", ...) do
		local list: Array? = select(listIndex, ...)

		if list then
			for _, value: any in ipairs(list) do
				combinedArray[index] = value
				index += 1
			end
		end
	end

	return combinedArray
end

function Array.deepCopy(array: Array): Array
	local deepCopied = {}

	for i, v in ipairs(array) do
		if type(v) == "table" then
			deepCopied[i] = Array.deepCopy(v)
		else
			deepCopied[i] = v
		end
	end

	return deepCopied
end

function Array.enqueue(array: Array, value: any?)
	table.insert(array, 1, value)
end

function Array.dequeue(array: Array): any?
	return table.remove(array, #array)
end

function Array.findFirstDuliplicate(array: Array): any?
	table.sort(array)
	for i: integer, v: any in ipairs(array) do
		if table.find(array, v, i + 1) then
			return v
		end
	end
end

function Array.findDuplicates(array: Array): Array
	local duplicates: Array = {}

	table.sort(array)
	for i: integer, v: any in ipairs(array) do
		if table.find(array, v, i + 1) then
			table.insert(duplicates, v)
		end
	end

	return duplicates
end

function Array.isEmpty(array: Array): boolean
	return #array == 0
end

function Array.JSONCompare(array1: Array, array2: Array): boolean
	return JSON.Encode(array1) == JSON.Encode(array2)
end

function Array.JSONCopy(array: Array): Array
	return JSON.DeepCopy(array)
end

function Array.pop(array: Array): any?
	return table.remove(array, #array)
end

function Array.push(array: Array, value: any?)
	table.insert(array, #array + 1, value)
end

function Array.random(array: Array): any?
	if array and #array > 0 then
		return array[math.random(1, #array)]
	end
end

function Array.randoms(array: Array, entries: integer): any?
	local results = {}
	if array and #array > 0 then
		local deepCopy = Array.deepCopy(array)
		for _ = 1, entries do
			table.insert(results, Array.removeRandom(deepCopy))
		end
		return table.unpack(results)
	end
end

function Array.removeRandom(array: Array): any?
	local value: any = Array.random(array)
	local index: integer = table.find(array, value)
	return table.remove(array, index)
end

function Array.remove(array: Array, value: any?): (any & number)?
	local index: integer? = table.find(array, value)
	if index then
		return table.remove(array, index), index
	end
end

function Array.shallowCompare(array1: Array, array2: Array): boolean
	for i, v in ipairs(array1) do
		if array2[i] ~= v then
			return false
		end
	end
	return true
end

function Array.shalowCopy(array: Array): Array
	return table.pack(table.unpack(array))
end

function Array.clear(array: Array): Array
	for i = #array, 1, -1 do
		table.remove(array, i)
	end
	return array
end

return Array
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="43">
        <Properties>
          <string name="Name">attributeUtil</string>
          <string name="Source"><![CDATA[--| LICENSE: https://gist.github.com/RuizuKun-Dev/768981cc6d68f996a041a4fa1761ea02#file-license-txt

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local instanceUtil = require(Utilities.instanceUtil)
local JSON = require(Utilities.JSON)
local t = require(Utilities.t) -- github.com/osyrisrblx/t

local CollectionService = game:GetService("CollectionService")

export type attributeUtil = {
	ClearAllAttributes: (instance: Instance) -> void,
	FindFirstChildWithAttribute: (parent: Instance, attribute: string, recursive: boolean?) -> Instance?,
	GetAttribute: (instance: Instance, key: string) -> (any),
	GetAttributes: (instance: Instance) -> (Dictionary),
	GetChildrenWithAttribute: (Instance, string) -> Array<Instance>,
	GetDescendantsWithAttribute: (Instance, string) -> Array<Instance>,
	IsSpecialType: (value: any) -> (boolean),
	IsSupportedType: (value: any) -> (boolean),
	SetAttribute: (instance: Instance, key: string, value: any) -> void,
	SetAttributes: (instance: Instance, attributes: { [string]: any }) -> void,
	WaitForChildWithAttribute: (parent: Instance, attribute: string, timeOut: number?) -> Instance?,
}

local attributeUtil = {}

export type SUPPORTED_TYPES = {
	BrickColor: boolean,
	Color: boolean,
	ColorSequence: boolean,
	NumberRange: boolean,
	NumberSequence: boolean,
	Rect: boolean,
	UDim: boolean,
	UDim2: boolean,
	Vector2: boolean,
	Vector3: boolean,
	boolean: boolean,
	number: boolean,
	string: boolean,
}

local SUPPORTED_TYPES: SUPPORTED_TYPES = {
	[typeof(BrickColor.random())] = true,
	[typeof(Color3.new())] = true,
	[typeof(ColorSequence.new(Color3.new()))] = true,
	[typeof(NumberRange.new(0))] = true,
	[typeof(NumberSequence.new(0))] = true,
	[typeof(Rect.new(Vector2.new(), Vector2.new()))] = true,
	[typeof(UDim.new())] = true,
	[typeof(UDim2.new())] = true,
	[typeof(Vector2.new())] = true,
	[typeof(Vector3.new())] = true,
	[typeof(true)] = true,
	[typeof(3.142)] = true,
	[typeof("string")] = "true",
	[typeof(nil)] = true,
}

export type SPECIAL_TYPES = {
	CFrame: CFrame,
	Instance: Instance,
	table: table,
}

local SPECIAL_TYPES: SPECIAL_TYPES = {
	[typeof(CFrame.new())] = true,
	[typeof(Instance.new("Configuration"))] = true,
	[typeof(table)] = true,
}

function attributeUtil.IsSupportedType(value: any): boolean
	return SUPPORTED_TYPES[typeof(value)]
end
local IsSupportedType = attributeUtil.IsSupportedType

function attributeUtil.IsSpecialType(value: any): boolean
	return SPECIAL_TYPES[typeof(value)]
end
local IsSpecialType = attributeUtil.IsSpecialType

local ClearAllAttributes_Check = t.tuple(t.Instance)
function attributeUtil.ClearAllAttributes(instance: Instance)
	assert(ClearAllAttributes_Check(instance))

	for key: string, _ in pairs(instance:GetAttributes()) do
		if key ~= "GUID" then
			instance:SetAttribute(key, nil)
		end
	end
end

local FindFirstChildWithAttribute_Check = t.tuple(t.Instance, t.string, t.optional(t.boolean))
function attributeUtil.FindFirstChildWithAttribute(
	parent: Instance,
	attribute: string,
	recursive: boolean?
): Instance | nil
	assert(FindFirstChildWithAttribute_Check(parent, attribute, recursive))

	if recursive then
		for _, descendant: Instance in ipairs(parent:GetDescendants()) do
			if descendant:GetAttribute(attribute) then
				return descendant
			end
		end
	else
		for _, child: Instance in ipairs(parent:GetChildren()) do
			if child:GetAttribute(attribute) then
				return child
			end
		end
	end

	return nil
end

local Codec = {}

function Codec.Decode(value: string): CFrame | Instance | table
	local success, decoded = pcall(JSON.Decode, value)

	if success then
		if typeof(decoded) == "table" then
			if decoded[1] == "CFrame:" then
				return CFrame.new(table.unpack(decoded[2])) :: CFrame
			elseif decoded[1] == "Instance:" then
				return CollectionService:GetTagged(decoded[2])[1] :: Instance
			elseif (decoded[1]):sub(1, 6) == "Table:" then
				return decoded[2] :: table
			end
		end
	end
end

local GetAttribute_Check = t.tuple(t.Instance, t.string)
function attributeUtil.GetAttribute(instance: Instance, key: string): any
	assert(GetAttribute_Check(instance, key))

	local value = instance:GetAttribute(key)

	return Codec.Decode(value) or value
end
local GetAttribute = attributeUtil.GetAttribute

local GetAttributes_Check = t.tuple(t.Instance)
function attributeUtil.GetAttributes(instance: Instance): Dictionary
	assert(GetAttributes_Check(instance))

	local attributes = instance:GetAttributes()

	for key: string, value: any in pairs(attributes) do
		attributes[key] = Codec.Decode(value) or value
	end

	return attributes
end

function Codec.Encode(value: CFrame | Instance | table): string
	if typeof(value) == "CFrame" then
		local cframe: CFrame = value
		return JSON.Encode({ "CFrame:", { cframe:GetComponents() } })
	elseif typeof(value) == "Instance" then
		local instance = value
		return JSON.Encode({ "Instance:", instance:GetAttribute("GUID") })
	elseif typeof(value) == "table" then
		local table: table = value
		return JSON.Encode({ "Table:" .. string.sub(tostring(table), 7), JSON.Filter(table, "JSON") })
	end
end

local GetChildrenWithAttribute_Check = t.tuple(t.Instance, t.string)
function attributeUtil.GetChildrenWithAttribute(parent: Instance, attribute: string): Array
	assert(GetChildrenWithAttribute_Check(parent, attribute))

	local cache = {}
	for _, child: Instance in ipairs(parent:GetChildren()) do
		if GetAttribute(child, attribute) ~= nil then
			table.insert(cache, child)
		end
	end
	return cache
end

local GetDescendantsWithAttribute_Check = t.tuple(t.Instance, t.string)
function attributeUtil.GetDescendantsWithAttribute(ancestor: Instance, attribute: string): Array
	assert(GetDescendantsWithAttribute_Check(ancestor, attribute))

	local cache = {}
	for _, descendant: Instance in ipairs(ancestor:GetDescendants()) do
		if GetAttribute(descendant, attribute) ~= nil then
			table.insert(cache, descendant)
		end
	end
	return cache
end

local SetAttribute_Check = t.tuple(t.Instance, t.union(t.string, t.integer), t.optional(t.any))
function attributeUtil.SetAttribute(instance: Instance, key: string, value: any)
	assert(SetAttribute_Check(instance, key, value))

	key = string.gsub(tostring(key):gsub("%f[%w]%l", string.upper), "[^%w_]+", "")

	if IsSupportedType(value) then
		instance:SetAttribute(key, value)
	elseif IsSpecialType(value) then
		instance:SetAttribute(key, Codec.Encode(value))
	end
end
local SetAttribute = attributeUtil.SetAttribute

local SetAttributes_Check = t.tuple(t.Instance, t.table)
function attributeUtil.SetAttributes(instance: Instance, attributes: Dictionary)
	assert(SetAttributes_Check(instance, attributes))

	for key: string, value: any in pairs(attributes) do
		SetAttribute(instance, key, value)
	end
end

local WaitForChildWithAttribute_Check = t.tuple(t.Instance, t.string, t.optional(t.number))
function attributeUtil.WaitForChildWithAttribute(parent: Instance, attribute: string, timeOut: number?): Instance | nil
	assert(WaitForChildWithAttribute_Check(parent, attribute, timeOut))

	local START_TIME = os.clock()
	local YIELD_UNTIL = (timeOut and timeOut + START_TIME or math.huge)

	local function yieldTooLongWarning()
		local CURRENT_TIME = os.clock()
		if CURRENT_TIME - START_TIME >= 5 then
			warn("Infinite yield possible on WaitForChildWithAttribute:", parent.Name, attribute)
			yieldTooLongWarning = nil
		end
	end

	local CURRENT_TIME = os.clock()
	while YIELD_UNTIL >= CURRENT_TIME do
		for _, child: Instance in ipairs(parent:GetChildren()) do
			if child:GetAttribute(attribute) then
				return child
			end
		end
		if yieldTooLongWarning then
			yieldTooLongWarning()
		end
		task.wait()
		CURRENT_TIME = os.clock()
	end

	return nil
end

local Display_Check = t.tuple(t.Instance, t.table)
function attributeUtil.Display(instance: Instance, dictionary: Dictionary)
	assert(Display_Check(instance, dictionary))

	for key: string, value: any in pairs(JSON.Filter(dictionary, "Display")) do
		if typeof(key) == "number" or typeof(key) == "string" then
			if typeof(value) == "table" then
				local configuration = instance:FindFirstChild(key) or Instance.new("Folder")
				configuration.Name = key
				configuration.Parent = instance
				attributeUtil.Display(configuration, value)
			else
				SetAttribute(instance, key, value)
			end
		end
	end
end

do
	local cache = {}

	local function isClone(instance: Instance): boolean
		return not cache[instance] and instance:GetAttribute("GUID")
	end

	local function setGUID(instance: Instance)
		local GUID = JSON.GenerateGUID(false)
		if isClone(instance) then
			local guid = instance:GetAttribute("GUID")
			CollectionService:RemoveTag(instance, guid)
		end

		instance:SetAttribute("GUID", GUID)
		CollectionService:AddTag(instance, GUID)
		cache[instance] = GUID
	end

	instanceUtil.doForAllDescendantsOf(game, function(descendant: Instance)
		pcall(setGUID, descendant)
	end)
end

return attributeUtil
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="44">
        <Properties>
          <string name="Name">characterUtil</string>
          <string name="Source"><![CDATA[local characterUtil = { script = script }

local Players = game:GetService("Players")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Network = require(ReplicatedStorage.Network)

local Configurations = require(ReplicatedStorage.Configurations)

local Utilities = ReplicatedStorage.Utilities
local Janitor = require(Utilities.Janitor)
local instanceUtil = require(Utilities.instanceUtil)
local playerUtil = require(Utilities.playerUtil)
local t = require(Utilities.t)
local TypeChecks = require(Utilities.TypeChecks)
local waitUntil = require(Utilities.waitUntil)

local connections = Janitor.new()

local RunService = game:GetService("RunService")

local QUICK_CHARACTER_LOADING = false

local function getHumanoidDescriptionFromUserId(player: Player): HumanoidDescription | boolean
	TypeChecks.Strict.Player(player)
	local success: boolean, result = pcall(Players.GetHumanoidDescriptionFromUserId, Players, player.UserId)
	if success then
		return result
	end
	return false
end

local function loadCharacterWithHumanoidDescription(player: Player): boolean
	TypeChecks.Strict.Player(player)
	local humanoidDescription = getHumanoidDescriptionFromUserId(player)
	if humanoidDescription then
		local sucess: boolean = pcall(player.LoadCharacterWithHumanoidDescription, player, humanoidDescription)
		return sucess
	end
	return false
end

local cache = {}
local function getCharacterAppearance(player: Player): Model | boolean
	TypeChecks.Strict.Player(player)
	if cache[player] then
		return cache[player]
	else
		local success, result = pcall(Players.GetCharacterAppearanceAsync, Players, player.UserId)
		if success then
			cache[player] = result
			return result
		end
		return false
	end
end

local function setCharacterAppearance(player: Player, characterAppearance: Model)
	local character: Model = player.Character
	local head: BasePart = character:WaitForChild("Head")
	local humanoid: Humanoid = character:WaitForChild("Humanoid")

	for _, v: Instance in ipairs(characterAppearance:GetChildren()) do
		if v.Name == "R15ArtistIntent" or v.Name == "R15" or v.Name == "R15Fixed" then
			local bodyparts = v
			for _, child: Instance in ipairs(bodyparts:GetChildren()) do
				local bodyPart: BasePart = character:FindFirstChild(child.Name)
				if bodyPart then
					humanoid:ReplaceBodyPartR15(humanoid:GetBodyPartR15(bodyPart), child)
				end
			end
		elseif v.Name == "R15Anim" then
			local animations = v
			for _, child: Instance in ipairs(animations:GetChildren()) do
				local animation: Animation = character.Animate:FindFirstChild(child.Name)
				if animation then
					animation:Destroy()
					child.Parent = character.Animate
				end
			end
		elseif v:IsA("Accessory") then
			humanoid:AddAccessory(v)
		elseif v:IsA("Decal") then
			local face: Decal = head:FindFirstChildOfClass("Decal")
			if face then
				face.Texture = v.Texture
			else
				v.Parent = head
			end
		elseif v:IsA("SpecialMesh") then
			v.Parent = head
		elseif v:IsA("CharacterAppearance") then
			v.Parent = character
		end
	end

	humanoid:BuildRigFromAttachments()
	characterAppearance:Destroy()
end

local function loadCharacterWithAppearance(player: Player)
	TypeChecks.Strict.Player(player)
	local characterAppearance = getCharacterAppearance(player)
	if characterAppearance then
		setCharacterAppearance(player, characterAppearance:Clone())
	end
end

function characterUtil.loadCharacter(player: Player): Model
	TypeChecks.Strict.Player(player)
	if QUICK_CHARACTER_LOADING and RunService:IsStudio() then
		pcall(player.LoadCharacter, player)
		warn("QUICK_CHARACTER_LOADING")
		return player.Character
	end

	if player:IsDescendantOf(Players) then
		if loadCharacterWithHumanoidDescription(player) then
			return player.Character
		elseif pcall(player.LoadCharacter, player) then
			loadCharacterWithAppearance(player)
		end
	end
	return player.Character
end

local MaterialWhitelist = {
	[Enum.Material.Neon] = true,
	[Enum.Material.ForceField] = true,
	[Enum.Material.Glass] = true,
}

local function isWhitelistMaterial(material: EnumItem): boolean
	return MaterialWhitelist[material]
end

local function setMaterial(basepart: BasePart, material: EnumItem)
	if not isWhitelistMaterial(basepart.Material) then
		basepart.Material = material
	end
end

function characterUtil.setCharacterMaterial(character: Model, material: EnumItem)
	for _, descendant: Instance in ipairs(character:GetDescendants()) do
		if descendant:IsA("BasePart") then
			local basePart: BasePart = descendant
			setMaterial(basePart, material)
		end
	end
end

function characterUtil.disableHumanoidStates(humanoid: Humanoid, states: EnumItem)
	if humanoid and humanoid:IsA("Humanoid") then
		for state: EnumItem, enable: boolean in pairs(states or Configurations.HUMANOID_STATES) do
			humanoid:SetStateEnabled(state, enable)
		end
	end
end

function characterUtil.setCharacterMassless(character: Model, bool: boolean)
	for _: ingeter, descendant: Instance in ipairs(character:GetDescendants()) do
		if descendant:IsA("BasePart") then
			local basePart: BasePart = descendant
			basePart.Massless = bool
		end
	end
end

function characterUtil.setCharacterShadow(character: Model, bool: boolean)
	for _, descendant: Instance in ipairs(character:GetDescendants()) do
		if descendant:IsA("BasePart") then
			local basePart: BasePart = descendant
			basePart.CastShadow = bool
		end
	end
end

function characterUtil.setCharacterTransparency(character: Model, transparency: number)
	for _, descendant: Instance in ipairs(character:GetDescendants()) do
		if descendant:IsA("BasePart") then
			local basePart: BasePart = descendant
			basePart.Transparency = transparency
		end
	end
end

function characterUtil.setAccessoryCollisionPhysics(humanoid: Humanoid, bool: boolean)
	for _, accessory: Accessory in ipairs(humanoid:GetAccessories()) do
		accessory.Handle.CanCollide = bool
		accessory.Handle.CanTouch = bool
		accessory.Handle.CanQuery = bool
	end
end

characterUtil.Default_ClassBlacklist = {
	"Beam",
	"Fire",
	"Light",
	"Model",
	"ParticleEmitter",
	"PointLight",
	"Smoke",
	"Sound",
	"Sparkles",
	"SpotLight",
	"Tool",
	"Trail",
}

function characterUtil.cloneCharacterWithFilter(character: Model, classBlacklist: Array<string>?): Model
	local clone: Model = character:Clone()
	instanceUtil.clearAllDescendantsOfClasses(clone, classBlacklist or characterUtil.Default_ClassBlacklist)

	instanceUtil.forEachDescendantsOfClassDo(clone, "BasePart", function(bodypart: BasePart)
		instanceUtil.setProperties(bodypart, {
			-- When an Instance is cloned all properties are copied including Velocity, so we must clear it
			Velocity = Vector3.new(0, 0, 0),
			Transparency = 0,
		})
		if bodypart.Name == "HumanoidRootPart" then
			bodypart.Transparency = 1
		end
	end)

	return clone
end

if RunService:IsClient() then
	local characterUtil_Remote = Network.get("characterUtil_Remote")

	function characterUtil.teleportCharacter(character: Model, cframe: CFrame)
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			character:SetAttribute("LastTeleportLocation", cframe.Position)
			character:SetPrimaryPartCFrame(cframe + Vector3.new(0, humanoid.hipHeight, 0))
			character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
		end
	end

	Network.handleClientEvents(characterUtil_Remote, {
		teleportCharacter = t.wrap(characterUtil.teleportCharacter, TypeChecks.Model, t.CFrame),
	})
elseif RunService:IsServer() then
	local characterUtil_Remote = Network.create("characterUtil_Remote")
	function characterUtil.teleportCharacter(character: Model, cframe: CFrame)
		local player = Players:GetPlayerFromCharacter(character)
		if player then
			characterUtil_Remote.FireClient(player, "teleportCharacter", character, cframe)
		end
	end
end

function characterUtil.isPlayerCharacter(player: Player, model: Model): boolean
	return model.Name == player.Name
end

local Characters = {}

local DEAD = Enum.HumanoidStateType.Dead

function characterUtil.handleCharacterAdded(player: Player, callback)
	table.insert(Characters[player].CharacterAdded, callback)

	if player.Character then
		if characterUtil.isPlayerCharacter(player, player.Character) then
			waitUntil(workspace).IsAncestorOf(player.Character)
			player.Character:WaitForChild("Humanoid")
			callback(player.Character)
		end
	end
end

function characterUtil.handleCharacterRemoving(player: Player, callback)
	table.insert(Characters[player].CharacterRemoving, callback)
end

function characterUtil.handleCharacterDied(player: Player, callback)
	table.insert(Characters[player].Died, callback)
end

playerUtil.handlePlayerAdded(function(player: Player)
	Characters[player] = {
		CharacterAdded = {},
		CharacterRemoving = {},
		Died = {},
	}

	local humanoid: Humanoid

	local function characterAdded(character: Model)
		if Characters[player] then
			if characterUtil.isPlayerCharacter(player, character) then
				waitUntil(workspace).IsAncestorOf(character)

				humanoid = character:WaitForChild("Humanoid")

				for _, callback in ipairs(Characters[player].CharacterAdded) do
					task.spawn(callback, character)
				end

				local function died()
					connections:Remove(humanoid)

					if Characters[player] then
						for _, callback in ipairs(Characters[player].Died) do
							task.spawn(callback, humanoid)
						end
					end
				end

				connections:Add(humanoid.Died:Connect(died), "Disconnect", humanoid)
			end
		end
	end

	task.spawn(characterAdded, player.Character or player.CharacterAdded:Wait())

	player.CharacterAdded:Connect(characterAdded)

	local function characterRemoving(character: Model)
		humanoid:SetStateEnabled(DEAD, true)
		humanoid:ChangeState(DEAD)

		if Characters[player] then
			for _, callback in ipairs(Characters[player].CharacterRemoving) do
				task.spawn(callback, character)
			end
		end
	end

	player.CharacterRemoving:Connect(characterRemoving)
end)

playerUtil.handlePlayerRemoving(t.wrap(function(player: Player)
	Characters[player] = nil
end, TypeChecks.Player))

return characterUtil
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="45">
        <Properties>
          <string name="Name">collisiongroupUtil</string>
          <string name="Source"><![CDATA[local collisiongroupUtil = {}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Configurations = require(ReplicatedStorage.Configurations)

local CollectionService = game:GetService("CollectionService")
local PhysicsService = game:GetService("PhysicsService")

local function setupCollisionGroups()
	for collisiongroupName: string, _ in pairs(Configurations.COLLISION_GROUPS) do
		PhysicsService:CreateCollisionGroup(collisiongroupName)
	end

	for collisiongroupName: string, collisiongroupData in pairs(Configurations.COLLISION_GROUPS) do
		for otherCollisiongroup, canCollide in pairs(collisiongroupData) do
			PhysicsService:CollisionGroupSetCollidable(collisiongroupName, otherCollisiongroup, canCollide)
		end
	end
end
setupCollisionGroups()

local function setCollisionGroup(BasePart: BasePart, CollisionGroupName: string)
	if BasePart:IsA("BasePart") then
		local previousCollisionGroup = PhysicsService:GetCollisionGroupName(BasePart.CollisionGroupId)
		CollectionService:RemoveTag(BasePart, previousCollisionGroup)
		PhysicsService:SetPartCollisionGroup(BasePart, CollisionGroupName)
		CollectionService:AddTag(BasePart, CollisionGroupName)
	end
end
collisiongroupUtil.setCollisionGroup = setCollisionGroup

function collisiongroupUtil.setAccessoriesCollisionGroup(humanoid: Humanoid, CollisionGroupName: string)
	for _, accessory: Accessory in ipairs(humanoid:GetAccessories()) do
		setCollisionGroup(accessory.Handle, CollisionGroupName)
	end
end

function collisiongroupUtil.setCharacterCollisionGroup(character: Model, CollisionGroupName: string)
	for _, descendants in ipairs(character:GetDescendants()) do
		setCollisionGroup(descendants, CollisionGroupName)
	end
end

return collisiongroupUtil
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="46">
        <Properties>
          <string name="Name">dictionary</string>
          <string name="Source"><![CDATA[export type Dictionary = { random: (Dictionary) -> any?, randoms: (Dictionary, integer) -> any? }

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local Array = require(Utilities.array)

local Dictionary: dictionary = {}

function Dictionary.convertToArrayWithKey(dictionary: Dictionary): Array
	local array = {}
	for k, _ in pairs(dictionary) do
		table.insert(array, k)
	end
	return array
end

function Dictionary.convertToArrayWithValue(dictionary: Dictionary): Array
	local array = {}
	for _, v in pairs(dictionary) do
		table.insert(array, v)
	end
	return array
end

function Dictionary.convertToArrayWithKeyValue(dictionary: Dictionary): Array
	local array = {}
	for k, v in pairs(dictionary) do
		table.insert(array, { k, v })
	end
	return array
end

function Dictionary.isEmpty(dictionary: Dictionary): boolean
	return next(dictionary) == nil
end

function Dictionary.randomValue(dictionary: Dictionary): any?
	local array = Dictionary.convertToArrayWithKey(dictionary)

	return dictionary[Array.random(array)]
end

function Dictionary.randomKeys(dictionary: Dictionary, entries: integer): any?
	local array = Dictionary.convertToArrayWithKey(dictionary)

	return Array.randoms(array, entries)
end

function Dictionary.clear(dictionary: Dictionary): Dictionary
	for k, _ in pairs(dictionary) do
		if typeof(k) ~= "number" then
			dictionary[k] = nil
		end
	end
	return dictionary
end

return Dictionary
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="47">
        <Properties>
          <string name="Name">guiUtil</string>
          <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local instanceUtil = require(Utilities.instanceUtil)

local guiUtil = {}

guiUtil.AnchorPoint = require(script.AnchorPoint)

guiUtil.Position = require(script.Position)

guiUtil.Size = require(script.Size)

guiUtil.Transparency = require(script.Transparency)

guiUtil.registerUI = require(script.registerUI)

guiUtil.createUI = instanceUtil.create

function guiUtil.setProperties(instance: Instance, properties)
	for property: string, value: any in pairs(properties) do
		instance[property] = value
	end
end

function guiUtil.updateCanvasSize(scrollingFrame: ScrollingFrame)
	local UIGridStyleLayout: UIGridStyleLayout = scrollingFrame:FindFirstChildWhichIsA("UIGridStyleLayout")
	scrollingFrame.CanvasSize = UDim2.fromOffset(0, UIGridStyleLayout.AbsoluteContentSize.Y)
	UIGridStyleLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
		scrollingFrame.CanvasSize = UDim2.fromOffset(0, UIGridStyleLayout.AbsoluteContentSize.Y)
	end)
end

return guiUtil
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="48">
          <Properties>
            <string name="Name">AnchorPoint</string>
            <string name="Source"><![CDATA[local AnchorPoint = {
	Top_Left = Vector2.new(0, 0),
	Top = Vector2.new(0.5, 0),
	Top_Right = Vector2.new(1, 0),

	Left = Vector2.new(0, 0.5),

	Center = Vector2.new(0.5, 0.5),

	Right = Vector2.new(1, 0.5),

	Bottom_Left = Vector2.new(0, 1),
	Bottom = Vector2.new(0.5, 1),
	Bottom_Right = Vector2.new(1, 1),
}

return AnchorPoint
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="49">
          <Properties>
            <string name="Name">Position</string>
            <string name="Source"><![CDATA[local Position = {
	Top_Left = UDim2.fromScale(0, 0),
	Top = UDim2.fromScale(0.5, 0),
	Top_Right = UDim2.fromScale(1, 0),

	Left = UDim2.fromScale(0, 0.5),

	Center = UDim2.fromScale(0.5, 0.5),

	Right = UDim2.fromScale(1, 0.5),

	Bottom_Left = UDim2.fromScale(0, 1),
	Bottom = UDim2.fromScale(0.5, 1),
	Bottom_Right = UDim2.fromScale(1, 1),
}

return Position
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="50">
          <Properties>
            <string name="Name">Size</string>
            <string name="Source"><![CDATA[local Size = {
	Full = UDim2.fromScale(1, 1),
	Half = UDim2.fromScale(0.5, 0.5),
	Quarter = UDim2.fromScale(0.25, 0.25),

	One_Thrid = UDim2.fromScale(0.33, 0.33),
	One_Forth = UDim2.fromScale(0.25, 0.25),
	One_Fifth = UDim2.fromScale(0.2, 0.2),
	One_Eight = UDim2.fromScale(0.125, 0.125),
}

return Size
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="51">
          <Properties>
            <string name="Name">Transparency</string>
            <string name="Source"><![CDATA[local Transparency = {
	Transparent = 1,
	Semi_Transparent = 0.5,
	Semi_Opaque = 0.5,
	Opaque = 0,
}

return Transparency
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="52">
          <Properties>
            <string name="Name">registerUI</string>
            <string name="Source"><![CDATA[local SoundService = game:GetService("SoundService")
local SoundSystem = require(SoundService.SoundSystem)

local TweenService = game:GetService("TweenService")

local CustomUIHandler = require(script.CustomUIHandler)

local registerUI = {}

local function setPositionAttribute(ui: GuiObject)
	if not ui:GetAttribute("Position") then
		ui.Visible = true
		ui:SetAttribute("Position", ui.Position)
		ui.Position = UDim2.fromScale(0.5, -1)
	end
end

local currentMenuFrame

function registerUI.showUI(ui: GuiObject)
	setPositionAttribute(ui)
	ui.Visible = true
	ui:TweenPosition(ui:GetAttribute("Position"), "Out", "Back", 0.5, true)
	currentMenuFrame = ui
end

function registerUI.hideUI(ui: GuiObject)
	setPositionAttribute(ui)
	ui:TweenPosition(UDim2.fromScale(0.5, -1), "In", "Quad", 0.25, true)
	currentMenuFrame = nil
end

function registerUI.WithMenuButton(menu: GuiObject, button: GuiButton)
	setPositionAttribute(menu)

	local Events = CustomUIHandler.create(button)

	Events.UIPress:Connect(function()
		if currentMenuFrame ~= menu then
			SoundSystem.PlaySFX("Bubble Click", button)

			registerUI.hideUI(currentMenuFrame or menu)
			registerUI.showUI(menu)
		elseif currentMenuFrame == menu then
			SoundSystem.PlaySFX("Click Swoosh", button)

			registerUI.hideUI(menu)
		end
	end)
end

function registerUI.WithMenuCloseButton(menu: GuiObject, closeButton: GuiButton)
	setPositionAttribute(menu)

	local Events = CustomUIHandler.create(closeButton)

	Events.UIPress:Connect(function()
		SoundSystem.PlaySFX("Button Click", closeButton)
		menu.Visible = false
		registerUI.hideUI(menu)
	end)

	if closeButton:IsA("ImageButton") then
		Events.UIHoverEnter:Connect(function()
			closeButton.ImageTransparency = 0
		end)

		Events.UIHoverLeave:Connect(function()
			closeButton.ImageTransparency = 0.5
		end)
	end
end

local Sine = Enum.EasingStyle.Sine

local In = Enum.EasingDirection.In
local Out = Enum.EasingDirection.Out

local hoverIn = TweenInfo.new(0.1, Sine, Out)
local hoverOut = TweenInfo.new(0.05, Sine, In)

function registerUI.WithUIScale(ui: GuiObject, uiScale: UIScale, Scales: { [string]: number })
	local tweenHoverEnter = TweenService:Create(uiScale, hoverIn, { Scale = Scales.HoverEnter })
	local tweenHoverLeave = TweenService:Create(uiScale, hoverOut, { Scale = Scales.HoverLeave })
	local tweenPress = TweenService:Create(uiScale, hoverOut, { Scale = Scales.HoverLeave * 0.85 })
	local tweenRelease = TweenService:Create(uiScale, hoverIn, { Scale = Scales.HoverEnter * 0.95 })

	local Events = CustomUIHandler.create(ui)

	Events.UIHoverEnter:Connect(function()
		SoundSystem.PlaySFX("Info Click", ui)
		tweenHoverEnter:Play()
	end)

	Events.UIHoverLeave:Connect(function()
		tweenHoverLeave:Play()
	end)

	Events.UIPress:Connect(function()
		tweenPress:Play()
	end)

	Events.UIRelease:Connect(function()
		tweenRelease:Play()
	end)

	uiScale.Scale = Scales.HoverLeave
end

function registerUI.WithHoverEnterUIEvent(ui: GuiObject, callback): Connection
	local Events = CustomUIHandler.create(ui)

	return Events.UIHoverEnter:Connect(callback)
end

function registerUI.WithHoverLeaveUIEvent(ui: GuiObject, callback): Connection
	local Events = CustomUIHandler.create(ui)

	return Events.UIHoverLeave:Connect(callback)
end

function registerUI.WithPressUIEvent(ui: GuiObject, callback): Connection
	local Events = CustomUIHandler.create(ui)

	return Events.UIPress:Connect(callback)
end

function registerUI.WithReleaseUIEvent(ui: GuiObject, callback): Connection
	local Events = CustomUIHandler.create(ui)

	return Events.UIRelease:Connect(callback)
end

return registerUI
]]></string>
          </Properties>
          <Item class="ModuleScript" referent="53">
            <Properties>
              <string name="Name">CustomUIHandler</string>
              <string name="Source"><![CDATA[local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local playerGui = localPlayer.PlayerGui
local mouse = localPlayer:GetMouse()

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local array = require(Utilities.array)
local Janitor = require(Utilities.Janitor)
local connections = Janitor.new()
local Signals = require(Utilities.Signals)

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local CustomUIHandler = {
	Enabled = not RunService:IsStudio(),
	_GUIsAtMouse = {},
	IS_CYCLICAL = true,
}
CustomUIHandler.__index = CustomUIHandler

local UIList = {}
local UIMap = {}

export type CustomUIObject = {
	IsPress: boolean,

	IsHovering: boolean,
	WasHovering: boolean,

	Disable: () -> void,
	Enable: () -> void,

	UIHoverEnter: Signal,
	UIHoverLeave: Signal,
	UIPress: Signal,
	UIRelease: Signal,
}

function CustomUIHandler.create(ui: GuiObject): CustomUIObject
	if not UIMap[ui] then
		local customUIObject = setmetatable({
			Instance = ui,

			UIPress = Signals.create(),
			UIRelease = Signals.create(),

			UIHoverEnter = Signals.create(),
			UIHoverLeave = Signals.create(),

			USING_METATABLE = true,
			--Metatable = UIHover,
		}, CustomUIHandler)

		ui.Destroying:Connect(function()
			if UIMap[ui] then
				UIMap[ui] = nil
				array.remove(UIList, customUIObject)
			end
		end)

		UIMap[ui] = customUIObject

		table.insert(UIList, customUIObject)
	end

	return UIMap[ui]
end

function CustomUIHandler.get(ui: GuiObject): CustomUIObject
	return UIMap[ui]
end

function CustomUIHandler:Enable()
	self.Instance.Active = true
end

function CustomUIHandler:Disable()
	self.Instance.Active = false
end

function CustomUIHandler:_IsOnUI(): boolean
	local ui = self.Instance
	if table.find(CustomUIHandler._GUIsAtMouse, ui) then
		return true
	end
	return false
end

function CustomUIHandler:_UpdateUIHoverEnter()
	local customUIObject = self
	if customUIObject.IsHovering and not customUIObject.WasHovering then
		customUIObject.WasHovering = true
		customUIObject.UIHoverEnter:Fire(customUIObject.Instance :: GuiObject)

		-- print("UIHoverEnter", customUIObject.Instance)
	end
end

function CustomUIHandler:_UpdateUIHoverLeave()
	local customUIObject = self
	if not customUIObject.IsHovering and customUIObject.WasHovering then
		customUIObject.WasHovering = false

		customUIObject:_UpdateUIRelease()

		customUIObject.UIHoverLeave:Fire(customUIObject.Instance :: GuiObject)

		-- print("UIHoverLeave", customUIObject.Instance)
	end
end

function CustomUIHandler:_UpdateUIHover()
	local customUIObject = self
	customUIObject.IsHovering = customUIObject:_IsOnUI()

	customUIObject:_UpdateUIHoverLeave()

	-- print("UpdateUIHover", customUIObject.Instance)
end

function CustomUIHandler:_UpdateUIPress()
	local customUIObject = self
	if customUIObject.IsHovering and not customUIObject.IsPress then
		customUIObject.IsPress = true
		customUIObject.UIPress:Fire(customUIObject.Instance :: GuiObject)

		-- print("UIPress", customUIObject.Instance)
	end
end

function CustomUIHandler:_UpdateUIRelease()
	local customUIObject = self
	if customUIObject.IsPress then
		customUIObject.IsPress = false
		customUIObject.UIRelease:Fire(customUIObject.Instance :: GuiObject)

		-- print("UIRelease", customUIObject.Instance)
	end
end

local MOUSEBUTTON1 = Enum.UserInputType.MouseButton1

local function listenForMouse1Down()
	connections:Add(
		UserInputService.InputBegan:Connect(function(input: InputObject, gameProcessed: boolean)
			if gameProcessed then
				if input.UserInputType == MOUSEBUTTON1 then
					for _, ui: GuiObject in ipairs(CustomUIHandler._GUIsAtMouse) do
						local customUIObject: CustomUIObject = CustomUIHandler.get(ui)
						if customUIObject then
							customUIObject:_UpdateUIPress()
							break
						end
					end
				end
			end
		end),
		"Disconnect"
	)
end

local function listenForMouse1Up()
	connections:Add(
		UserInputService.InputEnded:Connect(function(input: InputObject)
			if input.UserInputType == MOUSEBUTTON1 then
				for _, customUIObject: CustomUIObject in ipairs(UIList) do
					customUIObject:_UpdateUIRelease()
				end
			end
		end),
		"Disconnect"
	)
end

local function bindUpdateMouseStateToRenderStep()
	RunService:BindToRenderStep("Update MouseState", Enum.RenderPriority.First.Value, function()
		if CustomUIHandler.Enabled then
			CustomUIHandler._GUIsAtMouse = playerGui:GetGuiObjectsAtPosition(mouse.X, mouse.Y)
			for _, customUIObject: CustomUIObject in ipairs(UIList) do
				customUIObject:_UpdateUIHover()
			end

			for _, ui: GuiObject in ipairs(CustomUIHandler._GUIsAtMouse) do
				local customUIObject: CustomUIObject = CustomUIHandler.get(ui)
				if customUIObject then
					customUIObject:_UpdateUIHoverEnter()
					break
				end
			end
		end
	end)
end

local function listenForMouseInputs()
	if UserInputService.MouseEnabled then
		listenForMouse1Down()

		listenForMouse1Up()

		bindUpdateMouseStateToRenderStep()
	end
end

local TOUCH = Enum.UserInputType.Touch

local function listenForTouchStarted()
	connections:Add(
		UserInputService.TouchStarted:Connect(function(input: InputObject, gameProcessed: boolean)
			if gameProcessed then
				if input.UserInputType == TOUCH then
					CustomUIHandler._GUIsAtMouse = playerGui:GetGuiObjectsAtPosition(input.Position.X, input.Position.Y)
					for _, customUIObject: CustomUIObject in ipairs(UIList) do
						customUIObject:_UpdateUIHover()
					end

					for _, ui: GuiObject in ipairs(CustomUIHandler._GUIsAtMouse) do
						local customUIObject: CustomUIObject = CustomUIHandler.get(ui)
						if customUIObject then
							customUIObject:_UpdateUIHoverEnter()
							customUIObject:_UpdateUIPress()
							break
						end
					end
				end
			end
		end),
		"Disconnect"
	)
end

local function listenForTouchMoved()
	connections:Add(
		UserInputService.TouchMoved:Connect(function(input: InputObject)
			if input.UserInputType == TOUCH then
				CustomUIHandler._GUIsAtMouse = playerGui:GetGuiObjectsAtPosition(input.Position.X, input.Position.Y)
				for _, customUIObject: CustomUIObject in ipairs(UIList) do
					customUIObject:_UpdateUIHover()
				end

				for _, ui: GuiObject in ipairs(CustomUIHandler._GUIsAtMouse) do
					local customUIObject: CustomUIObject = CustomUIHandler.get(ui)
					if customUIObject then
						customUIObject:_UpdateUIHoverEnter()
						break
					end
				end
			end
		end),
		"Disconnect"
	)
end

local function listenForTouchEnded()
	connections:Add(
		UserInputService.TouchEnded:Connect(function(input: InputObject)
			if input.UserInputType == TOUCH then
				CustomUIHandler._GUIsAtMouse = {}
				for _, customUIObject: CustomUIObject in ipairs(UIList) do
					customUIObject:_UpdateUIHover()
				end
			end
		end),
		"Disconnect"
	)
end

local function listenForTouchInputs()
	if UserInputService.TouchEnabled then
		listenForTouchStarted()

		listenForTouchMoved()

		listenForTouchEnded()
	end
end

local function listenforInputs()
	listenForTouchInputs()
	listenForMouseInputs()
end

function CustomUIHandler.DisableInputs()
	CustomUIHandler.Enabled = false
	connections:Destroy()
	connections = Janitor.new()
	RunService:UnbindFromRenderStep("UpdateMouseState")
end

function CustomUIHandler.EnableInputs()
	CustomUIHandler.Enabled = true
	listenforInputs()
end
CustomUIHandler.EnableInputs()

return CustomUIHandler
]]></string>
            </Properties>
          </Item>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="54">
        <Properties>
          <string name="Name">instanceUtil</string>
          <string name="Source"><![CDATA[type Properties = { [string]: any }

export type InstanceUtil = {
	create: (className: string, properties: Properties, parent: Instance?) -> (Instance),
	setProperties: (instance: Instance, properties: Properties) -> (Instance),
	clearAllDescendantsOfClass: (ancestor: Instance, className: string) -> void,
	clearAllDescendantsOfClasses: (ancestor: Instance, classNames: Array<string>) -> void,
	doForAllDescendantsOf: (ancestor: Instance, callback: (Instance) -> void) -> void,
	forEachDescendantsOfClassDo: (ancestor: Instance, className: string, callback: (Instance) -> void) -> void,
	getAllDescendantsOfClass: (ancestor: Instance, className: string) -> (Array<Instance>),
}

--[[
	@class instanceUtil

	Utility functions for creating and setting properties on instances.
]]
local instanceUtil = {}

--[=[
    Sets the properties of an instance.

    @within instanceUtil
    @param instance Instance -- The instance you wanna set properties on
    @param properties Properties -- The properties you wanna set on the instance
]=]
function instanceUtil.setProperties(instance: Instance, properties: Properties, parent: Instance?)
	for property: string, value: any in pairs(properties) do
		instance[property] = value
	end

	if parent then
		instance.Parent = parent
	end
end

--[=[
    Creates an instance.

    @within instanceUtil
    @param className: string -- The name of the class you wanna create
    @param properties Properties -- The properties you wanna set on the instance
	@param parent Instance? -- The parent of the instance you wanna create
	@param instance Instance -- The instance you wanna create
]=]
function instanceUtil.create(className: string, properties: Properties, parent: Instance?): Instance
	local instance = Instance.new(className)

	instanceUtil.setProperties(instance, properties)

	instance.Parent = parent

	return instance
end

function instanceUtil.clearAllDescendantsOfClass(ancestor: Instance, className: string)
	for _, descendant: Instance in ipairs(ancestor:GetDescendants()) do
		if descendant:IsA(className) then
			descendant:Destroy()
		end
	end
end

function instanceUtil.clearAllDescendantsOfClasses(ancestor: Instance, classNames: Array<string>)
	for _, className: string in ipairs(classNames) do
		instanceUtil.clearAllDescendantsOfClass(ancestor, className)
	end
end

function instanceUtil.doForAllDescendantsOf(ancestor: Instance, callback: (Instance) -> void)
	for _, descendant: Instance in ipairs(ancestor:GetDescendants()) do
		task.spawn(callback, descendant)
	end

	ancestor.DescendantAdded:Connect(function(descendant: Instance)
		callback(descendant)
	end)
end

function instanceUtil.forEachDescendantsOfClassDo(ancestor: Instance, className: string, callback: (Instance) -> void)
	for _, descendant: Instance in ipairs(ancestor:GetDescendants()) do
		if descendant:IsA(className) then
			task.spawn(callback, descendant)
		end
	end
end

function instanceUtil.getAllDescendantsOfClass(ancestor: Instance, className: string): Array<Instance>
	local descendants = {}
	for _, descendant: Instance in ipairs(ancestor:GetDescendants()) do
		if descendant:IsA(className) then
			table.insert(descendants, descendant)
		end
	end
	return descendants
end

return instanceUtil
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="55">
        <Properties>
          <string name="Name">marketplaceUtil</string>
          <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local BackUp = require(ReplicatedStorage.Backup)

local Utilities = ReplicatedStorage.Utilities
local Promise = require(Utilities.Promise)

local MarketplaceService = game:GetService("MarketplaceService")

local marketplaceUtil = {}

marketplaceUtil.getProductInfo = Promise.promisify(function(assetId: number, infoType: EnumItem)
	local productInfo = BackUp.getProductInfo(assetId, infoType)
	if not productInfo then
		return MarketplaceService:GetProductInfo(assetId, infoType)
	end
	return productInfo
end)

return marketplaceUtil
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="56">
        <Properties>
          <string name="Name">playerUtil</string>
          <string name="Source"><![CDATA[local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local TypeChecks = require(Utilities.TypeChecks)

local CollectionService = game:GetService("CollectionService")

local playerUtil = { PlayerAdded = {}, PlayerRemoving = {}, TeamChanged = {}, script = script }

function playerUtil.freezeHumanoid(humanoid: Humanoid)
	TypeChecks.Strict.Humanoid(humanoid)

	local walkspeed = humanoid.WalkSpeed
	local jumppower = humanoid.JumpPower
	humanoid.WalkSpeed = 0
	humanoid.JumpPower = 0
	return function()
		humanoid.WalkSpeed = walkspeed
		humanoid.JumpPower = jumppower
	end
end

function playerUtil.getPlayerFromPart(basepart: BasePart): Player?
	TypeChecks.Strict.BasePart(basepart)

	local character: Model = basepart:FindFirstAncestorOfClass("Model")
	local player: Player = character
		and (
			Players:GetPlayerFromCharacter(character)
			or CollectionService:GetTagged(character:GetAttribute("Player") or "")[1]
		)
	return player
end

function playerUtil.getPlayerFromHumanoid(humanoid: Humanoid): Player?
	TypeChecks.Strict.Humanoid(humanoid)
	local player: Player = Players:GetPlayerFromCharacter(humanoid:FindFirstAncestorOfClass("Model"))
	return player
end

local function getCharacterFromPart(basepart: BasePart): Model?
	TypeChecks.Strict.BasePart(basepart)

	local player: Player = playerUtil.getPlayerFromPart(basepart)
	local character: Model = player and player.Character
	return character
end
playerUtil.getCharacterFromPart = getCharacterFromPart

function playerUtil.getHumanoidFromPart(basepart: BasePart): Humanoid?
	TypeChecks.Strict.BasePart(basepart)

	local character: Model = getCharacterFromPart(basepart)
	local humanoid: Humanoid = character and character:FindFirstChildOfClass("Humanoid")
	return humanoid
end

function playerUtil.getPlayerInfoFromPart(basepart: BasePart): PlayerInfo
	TypeChecks.Strict.BasePart(basepart)

	local character: Model = basepart:FindFirstAncestorOfClass("Model")
	local player: Player = character
		and (
			Players:GetPlayerFromCharacter(character)
			or CollectionService:GetTagged(character:GetAttribute("Player") or "")[1]
		)
	local humanoid: Humanoid = character and character:FindFirstChildOfClass("Humanoid")
	local rootpart: BasePart = humanoid and humanoid.RootPart
	return {
		Player = player,
		Character = character,
		Humanoid = humanoid,
		Head = character.Head,
		RootPart = rootpart,
		HumanoidRootPart = rootpart,
	}
end

export type PlayerInfo = {
	Player: Player,
	Character: Model,
	Humanoid: Humanoid,
	Head: BasePart,
	RootPart: BasePart,
	HumanoidRootPart: BasePart,
}

function playerUtil.getPlayerInfo(player: Player): PlayerInfo
	TypeChecks.Strict.Player(player)

	local character: Model = player:IsA("Player") and player.Character
		or CollectionService:GetTagged(player:GetAttribute("Character") or "")[1]
	local humanoid: Humanoid = character and character:FindFirstChildOfClass("Humanoid")
	local rootpart: BasePart = humanoid and humanoid.RootPart
	return {
		Player = player,
		Character = character,
		Humanoid = humanoid,
		Head = character.Head,
		RootPart = rootpart,
		HumanoidRootPart = rootpart,
	}
end

function playerUtil.getHumanoidOfPlayer(player: Player): Humanoid?
	TypeChecks.Strict.Player(player)

	return player.Character and player.Character:FindFirstChildOfClass("Humanoid")
end

function playerUtil.isHumanoidAlive(humanoid: Humanoid): boolean
	TypeChecks.Strict.Humanoid(humanoid)

	return humanoid.Health > 0
end

local DEAD = Enum.HumanoidStateType.Dead

function playerUtil.killHumanoid(humanoid: Humanoid)
	TypeChecks.Strict.Humanoid(humanoid)

	humanoid:SetStateEnabled(DEAD, true)
	humanoid:ChangeState(DEAD)
	humanoid.Health = 0
end

function playerUtil.isValidCharacter(character: Model): boolean
	TypeChecks.Strict.Model(character)

	return character and character:FindFirstChildOfClass("Humanoid") and character.Humanoid.RootPart and true
end

function playerUtil.validateTarget(targetInfo): boolean?
	if targetInfo then
		local player: Player = targetInfo.Player
		local character: Model = targetInfo.Character
		local humanoid: Humanoid = targetInfo.Humanoid

		if player and character and humanoid then
			if player:IsA("Player") and player.Character == character then
				if playerUtil.getHumanoidOfPlayer(player) == humanoid then
					return humanoid.Health > 0
				end
			elseif player:IsA("Configuration") then
				return humanoid.Health > 0
			end
		end
	end
end

function playerUtil.getPlayerFromHumanoid(humanoid: Humanoid): Player
	TypeChecks.Strict.Humanoid(humanoid)
	local character: Model = humanoid:FindFirstAncestorOfClass("Model")
	local player: Player = Players:GetPlayerFromCharacter(character)
	return player
end

function playerUtil.handlePlayerAdded(callback)
	table.insert(playerUtil.PlayerAdded, callback)

	for _, player: Player in ipairs(Players:GetPlayers()) do
		task.spawn(callback, player)
	end
end

Players.PlayerAdded:Connect(function(player: Player)
	for _, callback in ipairs(playerUtil.PlayerAdded) do
		task.spawn(callback, player)
	end
end)

function playerUtil.handlePlayerRemoving(callback)
	table.insert(playerUtil.PlayerRemoving, callback)
end

Players.PlayerRemoving:Connect(function(player: Player)
	for _, callback in ipairs(playerUtil.PlayerRemoving) do
		task.spawn(callback, player)
	end
end)

if localPlayer then
	function playerUtil.isLocalPlayer(player: Player): boolean
		return player == localPlayer
	end

	function playerUtil.handleTeamChanged(callback)
		table.insert(playerUtil.TeamChanged, callback)

		for _, player: Player in ipairs(Players:GetPlayers()) do
			task.spawn(callback, player)
		end
	end

	localPlayer:GetPropertyChangedSignal("Team"):Connect(function()
		for _, callback in ipairs(playerUtil.TeamChanged) do
			task.spawn(callback)
		end
	end)
end

return playerUtil
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="57">
        <Properties>
          <string name="Name">playfabUtil</string>
          <string name="Source"><![CDATA[local AnalyticsService = game:GetService("AnalyticsService")

-- local RunService = game:GetService("RunService")
local DISABLE_ANALYTICS = true
local IsStudio = DISABLE_ANALYTICS --RunService:IsStudio()

local playfabUtil = {}

export type ProgressionInfo = {
	Player: Player,
	Category: string,
	ProgressionStatus: EnumItem,
	Location: Dictionary,
	Statistics: Dictionary?,
	CustomData: (number | string | table)?,
}

-- playfabUtil.ProgressionInfo = {}

function playfabUtil.Progression(progressionInfo)
	if not IsStudio then
		AnalyticsService:FirePlayerProgressionEvent(
			progressionInfo.Player,
			progressionInfo.Category,
			progressionInfo.ProgressionStatus,
			progressionInfo.Location,
			progressionInfo.Statistics,
			progressionInfo.CustomData
		)
	end
end

export type EconomyInfo = {
	Player: Player,
	ItemName: string,
	EconomyAction: EnumItem,
	ItemCategory: string,
	Amount: integer,
	Currency: string,
	Location: Dictionary,
	CustomData: (number | string | table)?,
}

-- playfabUtil.EconomyInfo = {}

function playfabUtil.Economy(economyInfo)
	if not IsStudio then
		AnalyticsService:FireInGameEconomyEvent(
			economyInfo.Player,
			economyInfo.ItemName,
			economyInfo.EconomyAction,
			economyInfo.ItemCategory,
			economyInfo.Amount,
			economyInfo.Currency,
			economyInfo.Location,
			economyInfo.CustomData
		)
	end
end

export type LogInfo = {
	Player: Player?,
	LogLevel: EnumItem,
	Message: string,
	DebugInfo: {
		errorCode: string,
		stackTrace: string,
	}?,
	CustomData: (number | string | table)?,
}

-- playfabUtil.LogInfo = {}

function playfabUtil.Log(logInfo)
	if not IsStudio then
		AnalyticsService:FireLogEvent(
			logInfo.Player,
			logInfo.LogLevel,
			logInfo.Message,
			logInfo.DebugInfo,
			logInfo.CustomData
		)
	end
end

export type CustomInfo = {
	Player: Player?,
	EventCategory: string,
	CustomData: (number | string | table)?,
}

-- playfabUtil.CustomInfo = {}

function playfabUtil.Custom(customInfo)
	if not IsStudio then
		AnalyticsService:FireCustomEvent(customInfo.Player, customInfo.EventCategory, customInfo.CustomData)
	end
end

return playfabUtil
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="58">
        <Properties>
          <string name="Name">random</string>
          <string name="Source"><![CDATA[local RANDOM = {}

local rng = Random.new()

function RANDOM.integer(min: integer, max: integer): integer
	return rng:NextInteger(min, max)
end

function RANDOM.number(min: number?, max: number?): number
	return rng:NextNumber(min or 0, max or 1)
end

function RANDOM.getRandoms(min: number, max: number, amount: integer): any
	local numbers = {}
	for _ = 1, amount do
		table.insert(numbers, RANDOM.number(min, max))
	end
	return table.unpack(numbers)
end

function RANDOM.fromArray(array: Array): any?
	if #array > 0 then
		return array[RANDOM.integer(1, #array)]
	end
end

-- function random.fromDictionary(dictionary: Dictionary): any?

-- end

function RANDOM.CFrameFromPart(basePart: BasePart): CFrame
	local sizeX = basePart.Size.X / 2
	local sizeY = basePart.Size.Y / 2
	local sizeZ = basePart.Size.Z / 2

	local x = RANDOM.integer(-sizeX, sizeX)
	local y = RANDOM.integer(-sizeY, sizeY)
	local z = RANDOM.integer(-sizeZ, sizeZ)
	return basePart.CFrame * CFrame.new(x, y, z)
end

function RANDOM.Vector3FromPart(basePart: BasePart): Vector3
	return RANDOM.CFrameFromPart(basePart).Position
end

function RANDOM.Vector3(min: number, max: number): Vector3
	return Vector3.new(RANDOM.getRandoms(min, max, 3))
end

function RANDOM.NumberRange(min: number, max: number): NumberRange
	return NumberRange.new(RANDOM.number(min, max))
end

function RANDOM.weight(lootTable, random): any
	local totalWeight = 0

	for _, v in ipairs(lootTable) do
		for _: string, vv in pairs(v) do
			totalWeight += vv
		end
	end

	local number = (random:NextNumber() or rng:NextNumber()) * totalWeight

	for _, v in ipairs(lootTable) do
		for name: string, weight in pairs(v) do
			if number < weight then
				return name
			end
			number -= weight
		end
	end
end

return RANDOM
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="59">
        <Properties>
          <string name="Name">raycastUtil</string>
          <string name="Source"><![CDATA[local camera = workspace.CurrentCamera

local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local mouse

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Utilities = ReplicatedStorage.Utilities
local characterUtil = require(Utilities.characterUtil)

local CollectionService = game:GetService("CollectionService")

local RunService = game:GetService("RunService")

local raycastUtil = {}

local raycastParams = RaycastParams.new()
raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
raycastParams.IgnoreWater = true

local DEFAULT_MAX_DISTANCE = 1000

local WorldRootIgnoreLists = {}

local function _getIgnoredPartsForWorldRoot(worldroot: WorldRoot)
	if not WorldRootIgnoreLists[worldroot] then
		local IgnoredParts = {}
		for _, descendant: Instance in ipairs(worldroot:GetDescendants()) do
			if descendant:IsA("BasePart") then
				local BasePart: BasePart = descendant
				if not BasePart.CanCollide or BasePart.Transparency == 1 then
					if not CollectionService:HasTag(BasePart, "RaycastWhitelist") then
						table.insert(IgnoredParts, BasePart)
					end
				end
			end
		end
		WorldRootIgnoreLists[worldroot] = IgnoredParts
	end
	return WorldRootIgnoreLists[worldroot]
end
raycastUtil.getIgnoredPartsForWorldRoot = _getIgnoredPartsForWorldRoot

local function _handleIgnoredPartsForWorldRoot(worldroot: WorldRoot)
	if not WorldRootIgnoreLists[worldroot] then
		local IgnoredParts = {}

		for _, descendant: Instance in ipairs(worldroot:GetDescendants()) do
			if descendant:IsA("BasePart") then
				local BasePart: BasePart = descendant
				if not BasePart.CanCollide or BasePart.Transparency == 1 then
					if not CollectionService:HasTag(BasePart, "RaycastWhitelist") then
						table.insert(IgnoredParts, BasePart)
					end
				end
			end
		end

		worldroot.DescendantAdded:Connect(function(AddedDescendant: Instance)
			if AddedDescendant:IsA("BasePart") then
				local BasePart: BasePart = AddedDescendant
				if not BasePart.CanCollide or BasePart.Transparency == 1 then
					if not CollectionService:HasTag(BasePart, "RaycastWhitelist") then
						table.insert(IgnoredParts, BasePart)
					end
				end
			end
		end)

		worldroot.DescendantRemoving:Connect(function(RemovedDescendant: Instance)
			if RemovedDescendant:IsA("BasePart") then
				local BasePart: BasePart = RemovedDescendant
				table.remove(IgnoredParts, table.find(IgnoredParts, BasePart))
			end
		end)

		WorldRootIgnoreLists[worldroot] = IgnoredParts
	end
end
raycastUtil.handleIgnoredPartsForWorldRoot = _handleIgnoredPartsForWorldRoot

function raycastUtil.RaycastFromMouse(IgnoredParts: table?, maxDistance: number?): RaycastResult?
	local mouseRay: Ray = camera:ScreenPointToRay(mouse.X, mouse.Y)
	raycastParams.FilterDescendantsInstances = IgnoredParts
	return workspace:Raycast(mouseRay.Origin, mouseRay.Direction * (maxDistance or DEFAULT_MAX_DISTANCE), raycastParams)
end

function raycastUtil.Raycast(worldroot: WorldRoot, Origin: Vector3, Direction: Vector3): RaycastResult?
	raycastParams.FilterDescendantsInstances = _getIgnoredPartsForWorldRoot(worldroot)
	return worldroot:Raycast(Origin, Direction, raycastParams)
end

if RunService:IsClient() then
	mouse = localPlayer:GetMouse()

	_handleIgnoredPartsForWorldRoot(workspace)
	local IgnoredParts = _getIgnoredPartsForWorldRoot(workspace)

	characterUtil.handleCharacterDied(localPlayer, function(character: Model)
		task.wait()
		table.insert(IgnoredParts, character)
	end)

	characterUtil.handleCharacterRemoving(localPlayer, function(character: Model)
		task.wait()
		table.remove(IgnoredParts, table.find(IgnoredParts, character))
	end)
end

return raycastUtil
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="60">
        <Properties>
          <string name="Name">region3Util</string>
          <string name="Source"><![CDATA[local region3Util = {}

return region3Util
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="61">
        <Properties>
          <string name="Name">tagUtil</string>
          <string name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")

local tagUtil = {}

function tagUtil.AddTag(instance: Instance, tag: string)
	CollectionService:AddTag(instance, tag)
end

function tagUtil.ClearAllTags(instance: Instance)
	for _, tag: string in ipairs(CollectionService:GetTags(instance)) do
		tagUtil.Remove(instance, tag)
	end
end

function tagUtil.HasTag(instance: Instance, tag: string): boolean
	return CollectionService:HasTag(instance, tag)
end

function tagUtil.RemoveTag(instance: Instance, tag: string)
	CollectionService:RemoveTag(instance, tag)
end

function tagUtil.doForTagged(tag: (string), callback: (Instance) -> void): RBXScriptConnection
	for _, instance: Instance in ipairs(CollectionService:GetTagged(tag)) do
		task.spawn(callback, instance)
	end

	return CollectionService:GetInstanceAddedSignal(tag):Connect(callback)
end

do
	local function setClassName(instance: Instance)
		if not game:FindService(instance.ClassName) then
			CollectionService:AddTag(instance, instance.ClassName)
		end
	end

	for _, descendant: Instance in ipairs(game:GetDescendants()) do
		task.spawn(pcall, setClassName, descendant)
	end

	game.DescendantAdded:Connect(function(descendant: Instance)
		task.defer(pcall, setClassName, descendant)
	end)
end

return tagUtil
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="62">
        <Properties>
          <string name="Name">tweenUtil</string>
          <string name="Source"><![CDATA[local tweenUtil = {}

tweenUtil.EasingStyle = {
	Linear = Enum.EasingStyle.Linear,
	Sine = Enum.EasingStyle.Sine,
	Back = Enum.EasingStyle.Back,
	Quad = Enum.EasingStyle.Quad,
	Quart = Enum.EasingStyle.Quart,
	Quint = Enum.EasingStyle.Quint,
	Bounce = Enum.EasingStyle.Bounce,
	Elastic = Enum.EasingStyle.Elastic,
	Exponential = Enum.EasingStyle.Exponential,
	Circular = Enum.EasingStyle.Circular,
	Cubic = Enum.EasingStyle.Cubic,
}

tweenUtil.EasingDirection = {
	In = Enum.EasingDirection.In,
	Out = Enum.EasingDirection.Out,
	InOut = Enum.EasingDirection.InOut,
}

return tweenUtil
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="63">
        <Properties>
          <string name="Name">waitUntil</string>
          <string name="Source"><![CDATA[local function waitUntil(ancestor: Instance)
	return {
		IsAncestorOf = function(descendant: Instance)
			while not ancestor:IsAncestorOf(descendant) do
				descendant.AncestryChanged:Wait()
			end
		end,
		IsDescendantOf = function(descendant: Instance)
			while not descendant:IsDescendantOf(ancestor) do
				descendant.AncestryChanged:Wait()
			end
		end,
	}
end

return waitUntil
]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="64">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Folder" referent="65">
      <Properties>
        <string name="Name">ServerCore</string>
      </Properties>
      <Item class="Script" referent="66">
        <Properties>
          <string name="Name">ServerScriptsRunner</string>
          <string name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local TestService = game:GetService("TestService")

local function runScripts(require)
	for _, modulescript: ModuleScript in ipairs(CollectionService:GetTagged("Auto-Run")) do
		task.spawn(require, modulescript)
	end

	CollectionService:GetInstanceAddedSignal("Auto-Run"):Connect(function(modulescript: ModuleScript)
		task.spawn(require, modulescript)
	end)

	for _, modulescript: ModuleScript in ipairs(CollectionService:GetTagged("Auto-Run [Server]")) do
		task.spawn(require, modulescript)
	end

	CollectionService:GetInstanceAddedSignal("Auto-Run [Server]"):Connect(function(modulescript: ModuleScript)
		task.spawn(require, modulescript)
	end)
end

if RunService:IsStudio() and TestService.ENABLE_BENCHMARKER.Value then
	local timeMap = {}
	local timeList = {}
	local totalTime = 0

	runScripts(function(modulescript: ModuleScript)
		local startTime = os.clock()
		require(modulescript)
		local endTime = os.clock()
		local runTime = endTime - startTime
		totalTime += runTime

		timeMap[runTime] = modulescript
		table.insert(timeList, runTime)
	end)

	local function results()
		table.sort(timeList)
		for _, runTime: number in ipairs(timeList) do
			warn(timeMap[runTime], runTime)
		end
		warn("Total Runtime:", totalTime)
	end
	results()
else
	runScripts(require)
end
]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="ServerStorage" referent="67">
    <Properties>
      <string name="Name">ServerStorage</string>
    </Properties>
    <Item class="Folder" referent="68">
      <Properties>
        <string name="Name">ServerPackages</string>
      </Properties>
      <Item class="Folder" referent="69">
        <Properties>
          <string name="Name">_Index</string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="SoundService" referent="70">
    <Properties>
      <string name="Name">SoundService</string>
    </Properties>
  </Item>
  <Item class="StarterPlayer" referent="71">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="72">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="LocalScript" referent="73">
        <Properties>
          <string name="Name">PlayerScriptsLoader</string>
          <string name="Source"></string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="74">
        <Properties>
          <string name="Name">RbxCharacterSounds</string>
          <string name="Source"></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="75">
        <Properties>
          <string name="Name">ClientCore</string>
        </Properties>
        <Item class="LocalScript" referent="76">
          <Properties>
            <string name="Name">ClientScriptsRunner</string>
            <string name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local TestService = game:GetService("TestService")

local function runScripts(require)
	for _, modulescript: ModuleScript in ipairs(CollectionService:GetTagged("Auto-Run")) do
		task.spawn(require, modulescript)
	end

	CollectionService:GetInstanceAddedSignal("Auto-Run"):Connect(function(modulescript: ModuleScript)
		task.spawn(require, modulescript)
	end)

	for _, modulescript: ModuleScript in ipairs(CollectionService:GetTagged("Auto-Run [Client]")) do
		task.spawn(require, modulescript)
	end

	CollectionService:GetInstanceAddedSignal("Auto-Run [Client]"):Connect(function(modulescript: ModuleScript)
		task.spawn(require, modulescript)
	end)
end

if RunService:IsStudio() and TestService.ENABLE_BENCHMARKER.Value then
	local timeMap = {}
	local timeList = {}
	local totalTime = 0

	runScripts(function(modulescript: ModuleScript)
		local startTime = os.clock()
		require(modulescript)
		local endTime = os.clock()
		local runTime = endTime - startTime
		totalTime += runTime

		timeMap[runTime] = modulescript
		table.insert(timeList, runTime)
	end)

	local function results()
		table.sort(timeList)
		for _, runTime: number in ipairs(timeList) do
			warn(timeMap[runTime], runTime)
		end
		warn("Total Runtime:", totalTime)
	end
	results()
else
	runScripts(require)
end
]]></string>
          </Properties>
        </Item>
        <Item class="LocalScript" referent="77">
          <Properties>
            <string name="Name">UIController</string>
            <string name="Source"><![CDATA[local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local PlayerGui = localPlayer.PlayerGui
local PlayerScripts = localPlayer.PlayerScripts

local ContentProvider = game:GetService("ContentProvider")

for _, child: Instance in ipairs(PlayerScripts:WaitForChild("UI"):GetChildren()) do
	if child:IsA("ModuleScript") then
		local moduleScript: ModuleScript = child
		task.spawn(function()
			local UI = require(moduleScript)
			moduleScript.Parent = UI
			UI.Parent = PlayerGui
			script:SetAttribute(moduleScript.Name, true)
		end)
	end
end

ContentProvider:PreloadAsync({ PlayerGui })
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="78">
        <Properties>
          <string name="Name">UI</string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="TestService" referent="79">
    <Properties>
      <string name="Name">TestService</string>
    </Properties>
    <Item class="ModuleScript" referent="80">
      <Properties>
        <string name="Name">ClientTests</string>
        <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

if RunService:IsStudio() then
	local TestService = game:GetService("TestService")
	if TestService.ENABLE_TESTS.Value then
		local TestEZ = require(TestService.testez)
		if RunService:IsClient() then
			local results = TestEZ.TestBootstrap:run({ script })
			if results.failureCount == 0 then
				print(script, "")
			else
				print(script, "")
				error("Tests failed")
			end
		end
	end
end

return {}
]]></string>
        <BinaryString name="Tags">QXV0by1SdW4gW0NsaWVudF0AV2FsbHk=</BinaryString>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="81">
      <Properties>
        <string name="Name">FakePlayers</string>
        <string name="Source"><![CDATA[local Players = game:GetService("Players")

local FakePlayers = {
	Array = {},
	Dictionary = {},
}

function FakePlayers.create(name: string): Configuration
	local fakeplayer = Instance.new("Configuration")
	fakeplayer.Name = name
	FakePlayers.Dictionary[name] = fakeplayer
	table.insert(FakePlayers.Array, fakeplayer)
	fakeplayer.Parent = Players
	return fakeplayer
end

function FakePlayers.get(name: string): Configuration
	return FakePlayers.Dictionary[name]
end

function FakePlayers.getPlayers()
	return FakePlayers.Array
end

function FakePlayers.remove(name: string)
	local fakeplayer = FakePlayers.get(name)
	FakePlayers.Dictionary[name] = nil
	local index = table.find(FakePlayers.Array, name)
	table.remove(FakePlayers.Array, index)
	fakeplayer:Destroy()
end

FakePlayers.create("mesa4070")

return FakePlayers
]]></string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="82">
      <Properties>
        <string name="Name">ServerTests</string>
        <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

if RunService:IsStudio() then
	local TestService = game:GetService("TestService")
	if TestService.ENABLE_TESTS.Value then
		local TestEZ = require(TestService.testez)
		if RunService:IsServer() then
			local results = TestEZ.TestBootstrap:run({ script })
			if results.failureCount == 0 then
				print(script, "")
			else
				print(script, "")
				error("Tests failed")
			end
		end
	end
end

return {}
]]></string>
        <BinaryString name="Tags">QXV0by1SdW4gW1NlcnZlcl0AV2FsbHk=</BinaryString>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="83">
      <Properties>
        <string name="Name">testez</string>
        <string name="Source"><![CDATA[return require(game.TestService.DevPackages.testez)

]]></string>
      </Properties>
    </Item>
    <Item class="Folder" referent="84">
      <Properties>
        <string name="Name">DevPackages</string>
      </Properties>
      <Item class="Folder" referent="85">
        <Properties>
          <string name="Name">_Index</string>
        </Properties>
        <Item class="Folder" referent="86">
          <Properties>
            <string name="Name">ruizukun-dev_testez@0.4.8</string>
          </Properties>
          <Item class="ModuleScript" referent="87">
            <Properties>
              <string name="Name">testez</string>
              <string name="Source"><![CDATA[local Expectation = require(script.Expectation)
local TestBootstrap = require(script.TestBootstrap)
local TestEnum = require(script.TestEnum)
local TestPlan = require(script.TestPlan)
local TestPlanner = require(script.TestPlanner)
local TestResults = require(script.TestResults)
local TestRunner = require(script.TestRunner)
local TestSession = require(script.TestSession)
local TextReporter = require(script.Reporters.TextReporter)
local TextReporterQuiet = require(script.Reporters.TextReporterQuiet)
local TeamCityReporter = require(script.Reporters.TeamCityReporter)

local function run(testRoot, callback)
	local modules = TestBootstrap:getModules(testRoot)
	local plan = TestPlanner.createPlan(modules)
	local results = TestRunner.runPlan(plan)

	callback(results)
end

local TestEZ = {
	run = run,
	Expectation = Expectation,
	TestBootstrap = TestBootstrap,
	TestEnum = TestEnum,
	TestPlan = TestPlan,
	TestPlanner = TestPlanner,
	TestResults = TestResults,
	TestRunner = TestRunner,
	TestSession = TestSession,
	Reporters = {
		TextReporter = TextReporter,
		TextReporterQuiet = TextReporterQuiet,
		TeamCityReporter = TeamCityReporter,
	},
}

return TestEZ
]]></string>
              <BinaryString name="Tags">V2FsbHk=</BinaryString>
            </Properties>
            <Item class="ModuleScript" referent="88">
              <Properties>
                <string name="Name">Context</string>
                <string name="Source"><![CDATA[local Context = {}

function Context.new(parent)
	local meta = {}
	local index = {}

	meta.__index = index

	if parent then
		for key, value in pairs(getmetatable(parent).__index) do
			index[key] = value
		end
	end

	function meta.__newindex(_obj, key, value)
		assert(index[key] == nil, string.format("Cannot reassign %s in context", tostring(key)))

		index[key] = value
	end

	return setmetatable({}, meta)
end

return Context
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="89">
              <Properties>
                <string name="Name">Expectation</string>
                <string name="Source"><![CDATA[local Expectation = {}
local SELF_KEYS = {
	to = true,
	be = true,
	been = true,
	have = true,
	was = true,
	at = true,
}
local NEGATION_KEYS = { never = true }

local function assertLevel(condition, message, level)
	message = message or "Assertion failed!"
	level = level or 1

	if not condition then
		error(message, level + 1)
	end
end
local function bindSelf(self, method)
	return function(firstArg, ...)
		if firstArg == self then
			return method(self, ...)
		else
			return method(self, firstArg, ...)
		end
	end
end
local function formatMessage(result, trueMessage, falseMessage)
	if result then
		return trueMessage
	else
		return falseMessage
	end
end

function Expectation.new(value)
	local self = {
		value = value,
		successCondition = true,
		condition = false,
		matchers = {},
		_boundMatchers = {},
	}

	setmetatable(self, Expectation)

	self.a = bindSelf(self, self.a)
	self.an = self.a
	self.ok = bindSelf(self, self.ok)
	self.equal = bindSelf(self, self.equal)
	self.throw = bindSelf(self, self.throw)
	self.near = bindSelf(self, self.near)

	return self
end
function Expectation.checkMatcherNameCollisions(name)
	if SELF_KEYS[name] or NEGATION_KEYS[name] or Expectation[name] then
		return false
	end

	return true
end
function Expectation:extend(matchers)
	self.matchers = matchers or {}

	for name, implementation in pairs(self.matchers) do
		self._boundMatchers[name] = bindSelf(self, function(_self, ...)
			local result = implementation(self.value, ...)
			local pass = result.pass == self.successCondition

			assertLevel(pass, result.message, 3)
			self:_resetModifiers()

			return self
		end)
	end

	return self
end
function Expectation.__index(self, key)
	if SELF_KEYS[key] then
		return self
	end
	if NEGATION_KEYS[key] then
		local newExpectation = Expectation.new(self.value):extend(self.matchers)

		newExpectation.successCondition = not self.successCondition

		return newExpectation
	end
	if self._boundMatchers[key] then
		return self._boundMatchers[key]
	end

	return Expectation[key]
end
function Expectation:_resetModifiers()
	self.successCondition = true
end
function Expectation:a(typeName)
	local result = (type(self.value) == typeName) == self.successCondition
	local message = formatMessage(
		self.successCondition,
		("Expected value of type %q, got value %q of type %s"):format(typeName, tostring(self.value), type(self.value)),
		("Expected value not of type %q, got value %q of type %s"):format(
			typeName,
			tostring(self.value),
			type(self.value)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

Expectation.an = Expectation.a

function Expectation:ok()
	local result = (self.value ~= nil) == self.successCondition
	local message = formatMessage(
		self.successCondition,
		("Expected value %q to be non-nil"):format(tostring(self.value)),
		("Expected value %q to be nil"):format(tostring(self.value))
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end
function Expectation:equal(otherValue)
	local result = (self.value == otherValue) == self.successCondition
	local message = formatMessage(
		self.successCondition,
		("Expected value %q (%s), got %q (%s) instead"):format(
			tostring(otherValue),
			type(otherValue),
			tostring(self.value),
			type(self.value)
		),
		("Expected anything but value %q (%s)"):format(tostring(otherValue), type(otherValue))
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end
function Expectation:near(otherValue, limit)
	assert(type(self.value) == "number", "Expectation value must be a number to use 'near'")
	assert(type(otherValue) == "number", "otherValue must be a number")
	assert(type(limit) == "number" or limit == nil, "limit must be a number or nil")

	limit = limit or 1e-7

	local result = (math.abs(self.value - otherValue) <= limit) == self.successCondition
	local message = formatMessage(
		self.successCondition,
		("Expected value to be near %f (within %f) but got %f instead"):format(otherValue, limit, self.value),
		([[Expected value to not be near %f (within %f) but got %f instead]]):format(otherValue, limit, self.value)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end
function Expectation:throw(messageSubstring)
	local ok, err = pcall(self.value)
	local result = ok ~= self.successCondition

	if messageSubstring and not ok then
		if self.successCondition then
			result = err:find(messageSubstring, 1, true) ~= nil
		else
			result = err:find(messageSubstring, 1, true) == nil
		end
	end

	local message

	if messageSubstring then
		message = formatMessage(
			self.successCondition,
			([[Expected function to throw an error containing %q, but it %s]]):format(
				messageSubstring,
				err and ("threw: %s"):format(err) or "did not throw."
			),
			([[Expected function to never throw an error containing %q, but it threw: %s]]):format(
				messageSubstring,
				tostring(err)
			)
		)
	else
		message = formatMessage(
			self.successCondition,
			"Expected function to throw an error, but it did not throw.",
			("Expected function to succeed, but it threw an error: %s"):format(tostring(err))
		)
	end

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

return Expectation
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="90">
              <Properties>
                <string name="Name">ExpectationContext</string>
                <string name="Source"><![CDATA[local Expectation = require(script.Parent.Expectation)
local checkMatcherNameCollisions = Expectation.checkMatcherNameCollisions

local function copy(t)
	local result = {}

	for key, value in pairs(t) do
		result[key] = value
	end

	return result
end

local ExpectationContext = {}

ExpectationContext.__index = ExpectationContext

function ExpectationContext.new(parent)
	local self = {
		_extensions = parent and copy(parent._extensions) or {},
	}

	return setmetatable(self, ExpectationContext)
end
function ExpectationContext:startExpectationChain(...)
	return Expectation.new(...):extend(self._extensions)
end
function ExpectationContext:extend(config)
	for key, value in pairs(config) do
		assert(self._extensions[key] == nil, string.format("Cannot reassign %q in expect.extend", key))
		assert(checkMatcherNameCollisions(key), string.format("Cannot overwrite matcher %q; it already exists", key))

		self._extensions[key] = value
	end
end

return ExpectationContext
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="91">
              <Properties>
                <string name="Name">LifecycleHooks</string>
                <string name="Source"><![CDATA[local TestEnum = require(script.Parent.TestEnum)
local LifecycleHooks = {}

LifecycleHooks.__index = LifecycleHooks

function LifecycleHooks.new()
	local self = { _stack = {} }

	return setmetatable(self, LifecycleHooks)
end
function LifecycleHooks:getBeforeEachHooks()
	local key = TestEnum.NodeType.BeforeEach
	local hooks = {}

	for _, level in ipairs(self._stack) do
		for _, hook in ipairs(level[key]) do
			table.insert(hooks, hook)
		end
	end

	return hooks
end
function LifecycleHooks:getAfterEachHooks()
	local key = TestEnum.NodeType.AfterEach
	local hooks = {}

	for _, level in ipairs(self._stack) do
		for _, hook in ipairs(level[key]) do
			table.insert(hooks, 1, hook)
		end
	end

	return hooks
end
function LifecycleHooks:popHooks()
	table.remove(self._stack, #self._stack)
end
function LifecycleHooks:pushHooksFrom(planNode)
	assert(planNode ~= nil)
	table.insert(self._stack, {
		[TestEnum.NodeType.BeforeAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeAll),
		[TestEnum.NodeType.AfterAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterAll),
		[TestEnum.NodeType.BeforeEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeEach),
		[TestEnum.NodeType.AfterEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterEach),
	})
end
function LifecycleHooks:getBeforeAllHooks()
	return self._stack[#self._stack][TestEnum.NodeType.BeforeAll]
end
function LifecycleHooks:getAfterAllHooks()
	return self._stack[#self._stack][TestEnum.NodeType.AfterAll]
end
function LifecycleHooks:_getHooksOfType(nodes, key)
	local hooks = {}

	for _, node in ipairs(nodes) do
		if node.type == key then
			table.insert(hooks, node.callback)
		end
	end

	return hooks
end

return LifecycleHooks
]]></string>
              </Properties>
            </Item>
            <Item class="Folder" referent="92">
              <Properties>
                <string name="Name">Reporters</string>
              </Properties>
              <Item class="ModuleScript" referent="93">
                <Properties>
                  <string name="Name">TeamCityReporter</string>
                  <string name="Source"><![CDATA[local TestService = game:GetService("TestService")
local TestEnum = require(script.Parent.Parent.TestEnum)
local TeamCityReporter = {}

local function teamCityEscape(str)
	str = string.gsub(str, "([]|'[])", "|%1")
	str = string.gsub(str, "\r", "|r")
	str = string.gsub(str, "\n", "|n")

	return str
end
local function teamCityEnterSuite(suiteName)
	return string.format("##teamcity[testSuiteStarted name='%s']", teamCityEscape(suiteName))
end
local function teamCityLeaveSuite(suiteName)
	return string.format("##teamcity[testSuiteFinished name='%s']", teamCityEscape(suiteName))
end
local function teamCityEnterCase(caseName)
	return string.format("##teamcity[testStarted name='%s']", teamCityEscape(caseName))
end
local function teamCityLeaveCase(caseName)
	return string.format("##teamcity[testFinished name='%s']", teamCityEscape(caseName))
end
local function teamCityFailCase(caseName, errorMessage)
	return string.format(
		"##teamcity[testFailed name='%s' message='%s']",
		teamCityEscape(caseName),
		teamCityEscape(errorMessage)
	)
end
local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end
	if node.planNode.type == TestEnum.NodeType.Describe then
		table.insert(buffer, teamCityEnterSuite(node.planNode.phrase))

		for _, child in ipairs(node.children) do
			reportNode(child, buffer, level + 1)
		end

		table.insert(buffer, teamCityLeaveSuite(node.planNode.phrase))
	else
		table.insert(buffer, teamCityEnterCase(node.planNode.phrase))

		if node.status == TestEnum.TestStatus.Failure then
			table.insert(buffer, teamCityFailCase(node.planNode.phrase, table.concat(node.errors, "\n")))
		end

		table.insert(buffer, teamCityLeaveCase(node.planNode.phrase))
	end
end
local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end
local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TeamCityReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(results.successCount, results.failureCount, results.skippedCount),
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end
	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)
			print("")
		end
	end
end

return TeamCityReporter
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="94">
                <Properties>
                  <string name="Name">TextReporter</string>
                  <string name="Source"><![CDATA[local TestService = game:GetService("TestService")
local TestEnum = require(script.Parent.Parent.TestEnum)
local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~",
}
local UNKNOWN_STATUS_SYMBOL = "?"
local TextReporter = {}

local function compareNodes(a, b)
	return a.planNode.phrase:lower() < b.planNode.phrase:lower()
end
local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(INDENT:rep(level), symbol, node.planNode.phrase)
	else
		line = ("%s%s"):format(INDENT:rep(level), node.planNode.phrase)
	end

	table.insert(buffer, line)
	table.sort(node.children, compareNodes)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end
local function reportRoot(node)
	local buffer = {}

	table.sort(node.children, compareNodes)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end
local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(results.successCount, results.failureCount, results.skippedCount),
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end
	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)
			print("")
		end
	end
end

return TextReporter
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="95">
                <Properties>
                  <string name="Name">TextReporterQuiet</string>
                  <string name="Source"><![CDATA[local TestService = game:GetService("TestService")
local TestEnum = require(script.Parent.Parent.TestEnum)
local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~",
}
local UNKNOWN_STATUS_SYMBOL = "?"
local TextReporterQuiet = {}

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status ~= TestEnum.TestStatus.Success then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(INDENT:rep(level), symbol, node.planNode.phrase)
	end

	table.insert(buffer, line)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end
local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end
local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporterQuiet.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(results.successCount, results.failureCount, results.skippedCount),
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end
	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)
			print("")
		end
	end
end

return TextReporterQuiet
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="96">
              <Properties>
                <string name="Name">TestBootstrap</string>
                <string name="Source"><![CDATA[local TestPlanner = require(script.Parent.TestPlanner)
local TestRunner = require(script.Parent.TestRunner)
local TextReporter = require(script.Parent.Reporters.TextReporter)
local TestBootstrap = {}

local function stripSpecSuffix(name)
	return (name:gsub("%.spec$", ""))
end
local function isSpecScript(aScript)
	return aScript:IsA("ModuleScript") and aScript.Name:match("%.spec$")
end
local function getPath(module, root)
	root = root or game

	local path = {}
	local last = module

	if last.Name == "init.spec" then
		last = last.Parent
	end

	while last ~= nil and last ~= root do
		table.insert(path, stripSpecSuffix(last.Name))

		last = last.Parent
	end

	table.insert(path, stripSpecSuffix(root.Name))

	return path
end
local function toStringPath(tablePath)
	local stringPath = ""
	local first = true

	for _, element in ipairs(tablePath) do
		if first then
			stringPath = element
			first = false
		else
			stringPath = element .. " " .. stringPath
		end
	end

	return stringPath
end

function TestBootstrap:getModulesImpl(root, modules, current)
	modules = modules or {}
	current = current or root

	if isSpecScript(current) then
		local method = require(current)
		local path = getPath(current, root)
		local pathString = toStringPath(path)

		table.insert(modules, {
			method = method,
			path = path,
			pathStringForSorting = pathString:lower(),
		})
	end
end
function TestBootstrap:getModules(root)
	local modules = {}

	self:getModulesImpl(root, modules)

	for _, child in ipairs(root:GetDescendants()) do
		self:getModulesImpl(root, modules, child)
	end

	return modules
end
function TestBootstrap:run(roots, reporter, otherOptions)
	reporter = reporter or TextReporter
	otherOptions = otherOptions or {}

	local showTimingInfo = otherOptions.showTimingInfo or false
	local testNamePattern = otherOptions.testNamePattern
	local extraEnvironment = otherOptions.extraEnvironment or {}

	if type(roots) ~= "table" then
		error(([[Bad argument #1 to TestBootstrap:run. Expected table, got %s]]):format(typeof(roots)), 2)
	end

	local startTime = tick()
	local modules = {}

	for _, subRoot in ipairs(roots) do
		local newModules = self:getModules(subRoot)

		for _, newModule in ipairs(newModules) do
			table.insert(modules, newModule)
		end
	end

	local afterModules = tick()
	local plan = TestPlanner.createPlan(modules, testNamePattern, extraEnvironment)
	local afterPlan = tick()
	local results = TestRunner.runPlan(plan)
	local afterRun = tick()

	reporter.report(results)

	local afterReport = tick()

	if showTimingInfo then
		local timing = {
			("Took %f seconds to locate test modules"):format(afterModules - startTime),
			("Took %f seconds to create test plan"):format(afterPlan - afterModules),
			("Took %f seconds to run tests"):format(afterRun - afterPlan),
			("Took %f seconds to report tests"):format(afterReport - afterRun),
		}

		print(table.concat(timing, "\n"))
	end

	return results
end

return TestBootstrap
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="97">
              <Properties>
                <string name="Name">TestEnum</string>
                <string name="Source"><![CDATA[local TestEnum = {}

TestEnum.TestStatus = {
	Success = "Success",
	Failure = "Failure",
	Skipped = "Skipped",
}
TestEnum.NodeType = {
	Describe = "Describe",
	It = "It",
	BeforeAll = "BeforeAll",
	AfterAll = "AfterAll",
	BeforeEach = "BeforeEach",
	AfterEach = "AfterEach",
}
TestEnum.NodeModifier = {
	None = "None",
	Skip = "Skip",
	Focus = "Focus",
}

return TestEnum
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="98">
              <Properties>
                <string name="Name">TestPlan</string>
                <string name="Source"><![CDATA[local TestEnum = require(script.Parent.TestEnum)
local Expectation = require(script.Parent.Expectation)

local function newEnvironment(currentNode, extraEnvironment)
	local env = {}

	if extraEnvironment then
		if type(extraEnvironment) ~= "table" then
			error(("Bad argument #2 to newEnvironment. Expected table, got %s"):format(typeof(extraEnvironment)), 2)
		end

		for key, value in pairs(extraEnvironment) do
			env[key] = value
		end
	end

	local function addChild(phrase, callback, nodeType, nodeModifier)
		local node = currentNode:addChild(phrase, nodeType, nodeModifier)

		node.callback = callback

		if nodeType == TestEnum.NodeType.Describe then
			node:expand()
		end

		return node
	end

	function env.describeFOCUS(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Focus)
	end
	function env.describeSKIP(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Skip)
	end
	function env.describe(phrase, callback, nodeModifier)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.None)
	end
	function env.itFOCUS(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Focus)
	end
	function env.itSKIP(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)
	end
	function env.itFIXME(phrase, callback)
		local node = addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)

		warn("FIXME: broken test", node:getFullName())
	end
	function env.it(phrase, callback, nodeModifier)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.None)
	end

	local lifecyclePhaseId = 0
	local lifecycleHooks = {
		[TestEnum.NodeType.BeforeAll] = "beforeAll",
		[TestEnum.NodeType.AfterAll] = "afterAll",
		[TestEnum.NodeType.BeforeEach] = "beforeEach",
		[TestEnum.NodeType.AfterEach] = "afterEach",
	}

	for nodeType, name in pairs(lifecycleHooks) do
		env[name] = function(callback)
			addChild(name .. "_" .. tostring(lifecyclePhaseId), callback, nodeType, TestEnum.NodeModifier.None)

			lifecyclePhaseId = lifecyclePhaseId + 1
		end
	end

	function env.FIXME(optionalMessage)
		warn("FIXME: broken test", currentNode:getFullName(), optionalMessage or "")

		currentNode.modifier = TestEnum.NodeModifier.Skip
	end
	function env.FOCUS()
		currentNode.modifier = TestEnum.NodeModifier.Focus
	end
	function env.SKIP()
		currentNode.modifier = TestEnum.NodeModifier.Skip
	end
	function env.HACK_NO_XPCALL()
		warn(
			[[HACK_NO_XPCALL is deprecated. It is now safe to yield in an xpcall, so this is no longer necessary. It can be safely deleted.]]
		)
	end

	env.fit = env.itFOCUS
	env.xit = env.itSKIP
	env.fdescribe = env.describeFOCUS
	env.xdescribe = env.describeSKIP
	env.expect = setmetatable({
		extend = function(...)
			error('Cannot call "expect.extend" from within a "describe" node.')
		end,
	}, {
		__call = function(_self, ...)
			return Expectation.new(...)
		end,
	})

	return env
end

local TestNode = {}

TestNode.__index = TestNode

function TestNode.new(plan, phrase, nodeType, nodeModifier)
	nodeModifier = nodeModifier or TestEnum.NodeModifier.None

	local node = {
		plan = plan,
		phrase = phrase,
		type = nodeType,
		modifier = nodeModifier,
		children = {},
		callback = nil,
		parent = nil,
	}

	node.environment = newEnvironment(node, plan.extraEnvironment)

	return setmetatable(node, TestNode)
end

local function getModifier(name, pattern, modifier)
	if pattern and (modifier == nil or modifier == TestEnum.NodeModifier.None) then
		if name:match(pattern) then
			return TestEnum.NodeModifier.Focus
		else
			return TestEnum.NodeModifier.Skip
		end
	end

	return modifier
end

function TestNode:addChild(phrase, nodeType, nodeModifier)
	if nodeType == TestEnum.NodeType.It then
		for _, child in pairs(self.children) do
			if child.phrase == phrase then
				error("Duplicate it block found: " .. child:getFullName())
			end
		end
	end

	local childName = self:getFullName() .. " " .. phrase

	nodeModifier = getModifier(childName, self.plan.testNamePattern, nodeModifier)

	local child = TestNode.new(self.plan, phrase, nodeType, nodeModifier)

	child.parent = self

	table.insert(self.children, child)

	return child
end
function TestNode:getFullName()
	if self.parent then
		local parentPhrase = self.parent:getFullName()

		if parentPhrase then
			return parentPhrase .. " " .. self.phrase
		end
	end

	return self.phrase
end
function TestNode:expand()
	local originalEnv = getfenv(self.callback)
	local callbackEnv = setmetatable({}, { __index = originalEnv })

	for key, value in pairs(self.environment) do
		callbackEnv[key] = value
	end

	callbackEnv.script = originalEnv.script

	setfenv(self.callback, callbackEnv)

	local success, result = xpcall(self.callback, function(message)
		return debug.traceback(tostring(message), 2)
	end)

	if not success then
		self.loadError = result
	end
end

local TestPlan = {}

TestPlan.__index = TestPlan

function TestPlan.new(testNamePattern, extraEnvironment)
	local plan = {
		children = {},
		testNamePattern = testNamePattern,
		extraEnvironment = extraEnvironment,
	}

	return setmetatable(plan, TestPlan)
end
function TestPlan:addChild(phrase, nodeType, nodeModifier)
	nodeModifier = getModifier(phrase, self.testNamePattern, nodeModifier)

	local child = TestNode.new(self, phrase, nodeType, nodeModifier)

	table.insert(self.children, child)

	return child
end
function TestPlan:addRoot(path, method)
	local curNode = self

	for i = #path, 1, -1 do
		local nextNode = nil

		for _, child in ipairs(curNode.children) do
			if child.phrase == path[i] then
				nextNode = child

				break
			end
		end

		if nextNode == nil then
			nextNode = curNode:addChild(path[i], TestEnum.NodeType.Describe)
		end

		curNode = nextNode
	end

	curNode.callback = method

	curNode:expand()
end
function TestPlan:visitAllNodes(callback, root, level)
	root = root or self
	level = level or 0

	for _, child in ipairs(root.children) do
		callback(child, level)
		self:visitAllNodes(callback, child, level + 1)
	end
end
function TestPlan:visualize()
	local buffer = {}

	self:visitAllNodes(function(node, level)
		table.insert(buffer, (" "):rep(3 * level) .. node.phrase)
	end)

	return table.concat(buffer, "\n")
end
function TestPlan:findNodes(callback)
	local results = {}

	self:visitAllNodes(function(node)
		if callback(node) then
			table.insert(results, node)
		end
	end)

	return results
end

return TestPlan
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="99">
              <Properties>
                <string name="Name">TestPlanner</string>
                <string name="Source"><![CDATA[local TestPlan = require(script.Parent.TestPlan)
local TestPlanner = {}

function TestPlanner.createPlan(modulesList, testNamePattern, extraEnvironment)
	local plan = TestPlan.new(testNamePattern, extraEnvironment)

	table.sort(modulesList, function(a, b)
		return a.pathStringForSorting < b.pathStringForSorting
	end)

	for _, module in ipairs(modulesList) do
		plan:addRoot(module.path, module.method)
	end

	return plan
end

return TestPlanner
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="100">
              <Properties>
                <string name="Name">TestResults</string>
                <string name="Source"><![CDATA[local TestEnum = require(script.Parent.TestEnum)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~",
}
local TestResults = {}

TestResults.__index = TestResults

function TestResults.new(plan)
	local self = {
		successCount = 0,
		failureCount = 0,
		skippedCount = 0,
		planNode = plan,
		children = {},
		errors = {},
	}

	setmetatable(self, TestResults)

	return self
end
function TestResults.createNode(planNode)
	local node = {
		planNode = planNode,
		children = {},
		errors = {},
		status = nil,
	}

	return node
end
function TestResults:visitAllNodes(callback, root)
	root = root or self

	for _, child in ipairs(root.children) do
		callback(child)
		self:visitAllNodes(callback, child)
	end
end
function TestResults:visualize(root, level)
	root = root or self
	level = level or 0

	local buffer = {}

	for _, child in ipairs(root.children) do
		if child.planNode.type == TestEnum.NodeType.It then
			local symbol = STATUS_SYMBOLS[child.status] or "?"
			local str = ("%s[%s] %s"):format((" "):rep(3 * level), symbol, child.planNode.phrase)

			if child.messages and #child.messages > 0 then
				str = str
					.. "\n "
					.. (" "):rep(3 * level)
					.. table.concat(child.messages, "\n " .. (" "):rep(3 * level))
			end

			table.insert(buffer, str)
		else
			local str = ("%s%s"):format((" "):rep(3 * level), child.planNode.phrase or "")

			if child.status then
				str = str .. (" (%s)"):format(child.status)
			end

			table.insert(buffer, str)

			if #child.children > 0 then
				local text = self:visualize(child, level + 1)

				table.insert(buffer, text)
			end
		end
	end

	return table.concat(buffer, "\n")
end

return TestResults
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="101">
              <Properties>
                <string name="Name">TestRunner</string>
                <string name="Source"><![CDATA[local TestEnum = require(script.Parent.TestEnum)
local TestSession = require(script.Parent.TestSession)
local LifecycleHooks = require(script.Parent.LifecycleHooks)
local RUNNING_GLOBAL = "__TESTEZ_RUNNING_TEST__"
local TestRunner = { environment = {} }

local function wrapExpectContextWithPublicApi(expectationContext)
	return setmetatable({
		extend = function(...)
			expectationContext:extend(...)
		end,
	}, {
		__call = function(_self, ...)
			return expectationContext:startExpectationChain(...)
		end,
	})
end

function TestRunner.runPlan(plan)
	local session = TestSession.new(plan)
	local lifecycleHooks = LifecycleHooks.new()
	local exclusiveNodes = plan:findNodes(function(node)
		return node.modifier == TestEnum.NodeModifier.Focus
	end)

	session.hasFocusNodes = #exclusiveNodes > 0

	TestRunner.runPlanNode(session, plan, lifecycleHooks)

	return session:finalize()
end
function TestRunner.runPlanNode(session, planNode, lifecycleHooks)
	local function runCallback(callback, messagePrefix)
		local success = true
		local errorMessage

		_G[RUNNING_GLOBAL] = true
		messagePrefix = messagePrefix or ""

		local testEnvironment = getfenv(callback)

		for key, value in pairs(TestRunner.environment) do
			testEnvironment[key] = value
		end

		testEnvironment.fail = function(message)
			if message == nil then
				message = "fail() was called."
			end

			success = false
			errorMessage = messagePrefix .. debug.traceback(tostring(message), 2)
		end
		testEnvironment.expect = wrapExpectContextWithPublicApi(session:getExpectationContext())

		local context = session:getContext()
		local nodeSuccess, nodeResult = xpcall(function()
			callback(context)
		end, function(message)
			return messagePrefix .. debug.traceback(tostring(message), 2)
		end)

		if not nodeSuccess then
			success = false
			errorMessage = nodeResult
		end

		_G[RUNNING_GLOBAL] = nil

		return success, errorMessage
	end
	local function runNode(childPlanNode)
		for _, hook in ipairs(lifecycleHooks:getBeforeEachHooks()) do
			local success, errorMessage = runCallback(hook, "beforeEach hook: ")

			if not success then
				return false, errorMessage
			end
		end

		local testSuccess, testErrorMessage = runCallback(childPlanNode.callback)

		for _, hook in ipairs(lifecycleHooks:getAfterEachHooks()) do
			local success, errorMessage = runCallback(hook, "afterEach hook: ")

			if not success then
				if not testSuccess then
					return false,
						testErrorMessage .. [[

While cleaning up the failed test another error was found:
]] .. errorMessage
				end

				return false, errorMessage
			end
		end

		if not testSuccess then
			return false, testErrorMessage
		end

		return true, nil
	end

	lifecycleHooks:pushHooksFrom(planNode)

	local halt = false

	for _, hook in ipairs(lifecycleHooks:getBeforeAllHooks()) do
		local success, errorMessage = runCallback(hook, "beforeAll hook: ")

		if not success then
			session:addDummyError("beforeAll", errorMessage)

			halt = true
		end
	end

	if not halt then
		for _, childPlanNode in ipairs(planNode.children) do
			if childPlanNode.type == TestEnum.NodeType.It then
				session:pushNode(childPlanNode)

				if session:shouldSkip() then
					session:setSkipped()
				else
					local success, errorMessage = runNode(childPlanNode)

					if success then
						session:setSuccess()
					else
						session:setError(errorMessage)
					end
				end

				session:popNode()
			elseif childPlanNode.type == TestEnum.NodeType.Describe then
				session:pushNode(childPlanNode)
				TestRunner.runPlanNode(session, childPlanNode, lifecycleHooks)

				if childPlanNode.loadError then
					local message = "Error during planning: " .. childPlanNode.loadError

					session:setError(message)
				else
					session:setStatusFromChildren()
				end

				session:popNode()
			end
		end
	end

	for _, hook in ipairs(lifecycleHooks:getAfterAllHooks()) do
		local success, errorMessage = runCallback(hook, "afterAll hook: ")

		if not success then
			session:addDummyError("afterAll", errorMessage)
		end
	end

	lifecycleHooks:popHooks()
end

return TestRunner
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="102">
              <Properties>
                <string name="Name">TestSession</string>
                <string name="Source"><![CDATA[local TestEnum = require(script.Parent.TestEnum)
local TestResults = require(script.Parent.TestResults)
local Context = require(script.Parent.Context)
local ExpectationContext = require(script.Parent.ExpectationContext)
local TestSession = {}

TestSession.__index = TestSession

function TestSession.new(plan)
	local self = {
		results = TestResults.new(plan),
		nodeStack = {},
		contextStack = {},
		expectationContextStack = {},
		hasFocusNodes = false,
	}

	setmetatable(self, TestSession)

	return self
end
function TestSession:calculateTotals()
	local results = self.results

	results.successCount = 0
	results.failureCount = 0
	results.skippedCount = 0

	results:visitAllNodes(function(node)
		local status = node.status
		local nodeType = node.planNode.type

		if nodeType == TestEnum.NodeType.It then
			if status == TestEnum.TestStatus.Success then
				results.successCount = results.successCount + 1
			elseif status == TestEnum.TestStatus.Failure then
				results.failureCount = results.failureCount + 1
			elseif status == TestEnum.TestStatus.Skipped then
				results.skippedCount = results.skippedCount + 1
			end
		end
	end)
end
function TestSession:gatherErrors()
	local results = self.results

	results.errors = {}

	results:visitAllNodes(function(node)
		if #node.errors > 0 then
			for _, message in ipairs(node.errors) do
				table.insert(results.errors, message)
			end
		end
	end)
end
function TestSession:finalize()
	if #self.nodeStack ~= 0 then
		error("Cannot finalize TestResults with nodes still on the stack!", 2)
	end

	self:calculateTotals()
	self:gatherErrors()

	return self.results
end
function TestSession:pushNode(planNode)
	local node = TestResults.createNode(planNode)
	local lastNode = self.nodeStack[#self.nodeStack] or self.results

	table.insert(lastNode.children, node)
	table.insert(self.nodeStack, node)

	local lastContext = self.contextStack[#self.contextStack]
	local context = Context.new(lastContext)

	table.insert(self.contextStack, context)

	local lastExpectationContext = self.expectationContextStack[#self.expectationContextStack]
	local expectationContext = ExpectationContext.new(lastExpectationContext)

	table.insert(self.expectationContextStack, expectationContext)
end
function TestSession:popNode()
	assert(#self.nodeStack > 0, "Tried to pop from an empty node stack!")
	table.remove(self.nodeStack, #self.nodeStack)
	table.remove(self.contextStack, #self.contextStack)
	table.remove(self.expectationContextStack, #self.expectationContextStack)
end
function TestSession:getContext()
	assert(#self.contextStack > 0, "Tried to get context from an empty stack!")

	return self.contextStack[#self.contextStack]
end
function TestSession:getExpectationContext()
	assert(#self.expectationContextStack > 0, "Tried to get expectationContext from an empty stack!")

	return self.expectationContextStack[#self.expectationContextStack]
end
function TestSession:shouldSkip()
	if self.hasFocusNodes then
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end
			if node.planNode.modifier == TestEnum.NodeModifier.Focus then
				return false
			end
		end

		return true
	else
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end
		end
	end

	return false
end
function TestSession:setSuccess()
	assert(#self.nodeStack > 0, "Attempting to set success status on empty stack")

	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Success
end
function TestSession:setSkipped()
	assert(#self.nodeStack > 0, "Attempting to set skipped status on empty stack")

	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Skipped
end
function TestSession:setError(message)
	assert(#self.nodeStack > 0, "Attempting to set error status on empty stack")

	local last = self.nodeStack[#self.nodeStack]

	last.status = TestEnum.TestStatus.Failure

	table.insert(last.errors, message)
end
function TestSession:addDummyError(phrase, message)
	self:pushNode({
		type = TestEnum.NodeType.It,
		phrase = phrase,
	})
	self:setError(message)
	self:popNode()

	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Failure
end
function TestSession:setStatusFromChildren()
	assert(#self.nodeStack > 0, "Attempting to set status from children on empty stack")

	local last = self.nodeStack[#self.nodeStack]
	local status = TestEnum.TestStatus.Success
	local skipped = true

	for _, child in ipairs(last.children) do
		if child.status ~= TestEnum.TestStatus.Skipped then
			skipped = false

			if child.status == TestEnum.TestStatus.Failure then
				status = TestEnum.TestStatus.Failure
			end
		end
	end

	if skipped then
		status = TestEnum.TestStatus.Skipped
	end

	last.status = status
end

return TestSession
]]></string>
              </Properties>
            </Item>
          </Item>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="103">
        <Properties>
          <string name="Name">testez</string>
          <string name="Source"><![CDATA[return require(script.Parent._Index["ruizukun-dev_testez@0.4.8"]["testez"])
]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="BoolValue" referent="104">
      <Properties>
        <string name="Name">ENABLE_BENCHMARKER</string>
      </Properties>
    </Item>
    <Item class="BoolValue" referent="105">
      <Properties>
        <string name="Name">ENABLE_DEBUG</string>
      </Properties>
    </Item>
    <Item class="BoolValue" referent="106">
      <Properties>
        <string name="Name">ENABLE_TESTS</string>
      </Properties>
    </Item>
  </Item>
</roblox>